/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_deriv_deriv-api_dist_DerivAPIBasic_js"],{

/***/ "../../../node_modules/@deriv/deriv-api/dist/DerivAPIBasic.js":
/*!********************************************************************!*\
  !*** ../../../node_modules/@deriv/deriv-api/dist/DerivAPIBasic.js ***!
  \********************************************************************/
/***/ (function(module) {

eval("/*\n * ATTENTION: The \"eval\" devtool has been used (maybe by default in mode: \"development\").\n * This devtool is neither made for production nor for readable output files.\n * It uses \"eval()\" calls to create a separate source file in the browser devtools.\n * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)\n * or disable the default devtool with \"devtool: false\".\n * If you are looking for production-ready output files, see mode: \"production\" (https://webpack.js.org/configuration/mode/).\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ \"./node_modules/@babel/runtime/regenerator/index.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!\n  \\**********************************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\neval(\"module.exports = __webpack_require__(/*! regenerator-runtime */ \\\"./node_modules/regenerator-runtime/runtime.js\\\");\\n\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/@babel/runtime/regenerator/index.js?\");\n\n/***/ }),\n\n/***/ \"./src/deriv_api/Cache.js\":\n/*!********************************!*\\\n  !*** ./src/deriv_api/Cache.js ***!\n  \\********************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ Cache)\\n/* harmony export */ });\\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \\\"./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \\\"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \\\"./node_modules/@babel/runtime/helpers/esm/createClass.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ \\\"./node_modules/@babel/runtime/helpers/esm/inherits.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \\\"./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \\\"./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\\\");\\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/regenerator */ \\\"./node_modules/@babel/runtime/regenerator/index.js\\\");\\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6__);\\n/* harmony import */ var _DerivAPICalls__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./DerivAPICalls */ \\\"./src/deriv_api/DerivAPICalls.js\\\");\\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./errors */ \\\"./src/deriv_api/errors.js\\\");\\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils */ \\\"./src/deriv_api/utils.js\\\");\\n\\n\\n\\n\\n\\n\\n\\n\\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, result); }; }\\n\\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \\\"undefined\\\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \\\"function\\\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\\n\\n\\n\\n\\n/**\\n * Cache - A class for implementing in-memory and persistent cache\\n *\\n * The real implementation of the underlying cache is delegated to the storage\\n * object (See the params).\\n *\\n * The storage object needs to implement the API.\\n *\\n * @example\\n * // Read the latest active symbols\\n * const symbols = await api.activeSymbols();\\n *\\n * // Read the data from cache if available\\n * const cached_symbols = await api.cache.activeSymbols();\\n *\\n * @param {DerivAPIBasic} api API instance to get data that is not cached\\n * @param {Object} storage A storage instance to use for caching\\n */\\n\\nvar Cache = /*#__PURE__*/function (_DerivAPICalls) {\\n  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(Cache, _DerivAPICalls);\\n\\n  var _super = _createSuper(Cache);\\n\\n  function Cache(api, storage) {\\n    var _this;\\n\\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.default)(this, Cache);\\n\\n    if (!api) {\\n      throw new _errors__WEBPACK_IMPORTED_MODULE_8__.ConstructionError('Cache object needs an API to work');\\n    }\\n\\n    _this = _super.call(this);\\n    _this.api = api;\\n    _this.storage = storage;\\n    return _this;\\n  }\\n\\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.default)(Cache, [{\\n    key: \\\"send\\\",\\n    value: function () {\\n      var _send = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6___default().mark(function _callee(request) {\\n        var response;\\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6___default().wrap(function _callee$(_context) {\\n          while (1) {\\n            switch (_context.prev = _context.next) {\\n              case 0:\\n                _context.next = 2;\\n                return this.has(request);\\n\\n              case 2:\\n                if (!_context.sent) {\\n                  _context.next = 4;\\n                  break;\\n                }\\n\\n                return _context.abrupt(\\\"return\\\", this.get(request));\\n\\n              case 4:\\n                _context.next = 6;\\n                return this.api.send(request);\\n\\n              case 6:\\n                response = _context.sent;\\n                _context.next = 9;\\n                return this.set(request, response);\\n\\n              case 9:\\n                return _context.abrupt(\\\"return\\\", response);\\n\\n              case 10:\\n              case \\\"end\\\":\\n                return _context.stop();\\n            }\\n          }\\n        }, _callee, this);\\n      }));\\n\\n      function send(_x) {\\n        return _send.apply(this, arguments);\\n      }\\n\\n      return send;\\n    }()\\n  }, {\\n    key: \\\"has\\\",\\n    value: function () {\\n      var _has = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6___default().mark(function _callee2(request) {\\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6___default().wrap(function _callee2$(_context2) {\\n          while (1) {\\n            switch (_context2.prev = _context2.next) {\\n              case 0:\\n                return _context2.abrupt(\\\"return\\\", this.storage.has((0,_utils__WEBPACK_IMPORTED_MODULE_9__.objectToCacheKey)(request)));\\n\\n              case 1:\\n              case \\\"end\\\":\\n                return _context2.stop();\\n            }\\n          }\\n        }, _callee2, this);\\n      }));\\n\\n      function has(_x2) {\\n        return _has.apply(this, arguments);\\n      }\\n\\n      return has;\\n    }()\\n    /* Redirected to the method defined by the storage */\\n\\n  }, {\\n    key: \\\"get\\\",\\n    value: function () {\\n      var _get = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6___default().mark(function _callee3(request) {\\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6___default().wrap(function _callee3$(_context3) {\\n          while (1) {\\n            switch (_context3.prev = _context3.next) {\\n              case 0:\\n                return _context3.abrupt(\\\"return\\\", this.storage.get((0,_utils__WEBPACK_IMPORTED_MODULE_9__.objectToCacheKey)(request)));\\n\\n              case 1:\\n              case \\\"end\\\":\\n                return _context3.stop();\\n            }\\n          }\\n        }, _callee3, this);\\n      }));\\n\\n      function get(_x3) {\\n        return _get.apply(this, arguments);\\n      }\\n\\n      return get;\\n    }()\\n    /* Redirected to the method defined by the storage */\\n\\n  }, {\\n    key: \\\"getByMsgType\\\",\\n    value: function () {\\n      var _getByMsgType = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6___default().mark(function _callee4(type) {\\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6___default().wrap(function _callee4$(_context4) {\\n          while (1) {\\n            switch (_context4.prev = _context4.next) {\\n              case 0:\\n                return _context4.abrupt(\\\"return\\\", this.storage.getByMsgType(type));\\n\\n              case 1:\\n              case \\\"end\\\":\\n                return _context4.stop();\\n            }\\n          }\\n        }, _callee4, this);\\n      }));\\n\\n      function getByMsgType(_x4) {\\n        return _getByMsgType.apply(this, arguments);\\n      }\\n\\n      return getByMsgType;\\n    }()\\n    /* Redirected to the method defined by the storage */\\n\\n  }, {\\n    key: \\\"set\\\",\\n    value: function () {\\n      var _set = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6___default().mark(function _callee5(request, response) {\\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6___default().wrap(function _callee5$(_context5) {\\n          while (1) {\\n            switch (_context5.prev = _context5.next) {\\n              case 0:\\n                return _context5.abrupt(\\\"return\\\", this.storage.set((0,_utils__WEBPACK_IMPORTED_MODULE_9__.objectToCacheKey)(request), response));\\n\\n              case 1:\\n              case \\\"end\\\":\\n                return _context5.stop();\\n            }\\n          }\\n        }, _callee5, this);\\n      }));\\n\\n      function set(_x5, _x6) {\\n        return _set.apply(this, arguments);\\n      }\\n\\n      return set;\\n    }()\\n  }]);\\n\\n  return Cache;\\n}(_DerivAPICalls__WEBPACK_IMPORTED_MODULE_7__.default);\\n\\n\\n\\n//# sourceURL=webpack://DerivAPIBasic/./src/deriv_api/Cache.js?\");\n\n/***/ }),\n\n/***/ \"./src/deriv_api/CustomPromise.js\":\n/*!****************************************!*\\\n  !*** ./src/deriv_api/CustomPromise.js ***!\n  \\****************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ CustomPromise)\\n/* harmony export */ });\\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \\\"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \\\"./node_modules/@babel/runtime/helpers/esm/createClass.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ \\\"./node_modules/@babel/runtime/helpers/esm/inherits.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \\\"./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \\\"./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/wrapNativeSuper */ \\\"./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\\\");\\n\\n\\n\\n\\n\\n\\n\\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__.default)(this, result); }; }\\n\\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \\\"undefined\\\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \\\"function\\\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\\n\\nvar CustomPromise = /*#__PURE__*/function (_Promise) {\\n  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__.default)(CustomPromise, _Promise);\\n\\n  var _super = _createSuper(CustomPromise);\\n\\n  function CustomPromise() {\\n    var _this;\\n\\n    var cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\\n\\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, CustomPromise);\\n\\n    var resolve;\\n    var reject;\\n    _this = _super.call(this, function (parentResolve, parentReject) {\\n      resolve = parentResolve;\\n      reject = parentReject;\\n    });\\n    cb(resolve, reject);\\n    _this.resolveCallback = resolve;\\n    _this.rejectCallback = reject;\\n    _this.state = 'pending';\\n    return _this;\\n  }\\n\\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(CustomPromise, [{\\n    key: \\\"resolve\\\",\\n    value: function resolve(data) {\\n      this.resolveCallback(data);\\n      this.state = 'resolved';\\n      return this;\\n    }\\n  }, {\\n    key: \\\"reject\\\",\\n    value: function reject(error) {\\n      this.rejectCallback(error);\\n      this.state = 'rejected';\\n      return this;\\n    }\\n  }, {\\n    key: \\\"isPending\\\",\\n    value: function isPending() {\\n      return this.state === 'pending';\\n    }\\n  }, {\\n    key: \\\"isRejected\\\",\\n    value: function isRejected() {\\n      return this.state === 'rejected';\\n    }\\n  }, {\\n    key: \\\"isResolved\\\",\\n    value: function isResolved() {\\n      return this.state === 'resolved';\\n    }\\n  }], [{\\n    key: \\\"wrap\\\",\\n    value: function wrap(promise) {\\n      if (promise instanceof this) return promise;\\n      var custom_promise = new this();\\n      promise.then(custom_promise.resolve.bind(custom_promise), custom_promise.reject.bind(custom_promise));\\n      return custom_promise;\\n    }\\n  }]);\\n\\n  return CustomPromise;\\n}( /*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_5__.default)(Promise));\\n\\n\\n\\n//# sourceURL=webpack://DerivAPIBasic/./src/deriv_api/CustomPromise.js?\");\n\n/***/ }),\n\n/***/ \"./src/deriv_api/DerivAPIBasic.js\":\n/*!****************************************!*\\\n  !*** ./src/deriv_api/DerivAPIBasic.js ***!\n  \\****************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ DerivAPIBasic)\\n/* harmony export */ });\\n/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ \\\"./node_modules/@babel/runtime/helpers/esm/slicedToArray.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ \\\"./node_modules/@babel/runtime/helpers/esm/typeof.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \\\"./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \\\"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \\\"./node_modules/@babel/runtime/helpers/esm/createClass.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \\\"./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ \\\"./node_modules/@babel/runtime/helpers/esm/inherits.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \\\"./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \\\"./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\\\");\\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @babel/runtime/regenerator */ \\\"./node_modules/@babel/runtime/regenerator/index.js\\\");\\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9__);\\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! rxjs/operators */ \\\"./node_modules/rxjs/dist/esm5/internal/operators/first.js\\\");\\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! rxjs/operators */ \\\"./node_modules/rxjs/dist/esm5/internal/operators/filter.js\\\");\\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! rxjs/operators */ \\\"./node_modules/rxjs/dist/esm5/internal/operators/share.js\\\");\\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! rxjs */ \\\"./node_modules/rxjs/dist/esm5/internal/Subject.js\\\");\\n/* harmony import */ var _Cache__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Cache */ \\\"./src/deriv_api/Cache.js\\\");\\n/* harmony import */ var _CustomPromise__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./CustomPromise */ \\\"./src/deriv_api/CustomPromise.js\\\");\\n/* harmony import */ var _DerivAPICalls__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./DerivAPICalls */ \\\"./src/deriv_api/DerivAPICalls.js\\\");\\n/* harmony import */ var _InMemory__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./InMemory */ \\\"./src/deriv_api/InMemory.js\\\");\\n/* harmony import */ var _SubscriptionManager__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./SubscriptionManager */ \\\"./src/deriv_api/SubscriptionManager.js\\\");\\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./errors */ \\\"./src/deriv_api/errors.js\\\");\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_7__.default)(this, result); }; }\\n\\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \\\"undefined\\\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \\\"function\\\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * The minimum functionality provided by DerivAPI, provides direct calls to the\\n * API.\\n * `api.cache` is available if you want to use the cached data (see {@link Cache})\\n *\\n * @example\\n * const apiFromOpenConnection = new DerivAPI({ connection });\\n * const apiFromEndpoint = new DerivAPI({ endpoint: 'ws.binaryws.com', app_id: 1234 });\\n *\\n * @param {Object}     options\\n * @param {WebSocket=} options.connection - A ready to use connection\\n * @param {String}     options.endpoint   - API server to connect to\\n * @param {Number}     options.app_id     - Application ID of the API user\\n * @param {String}     options.lang       - Language of the API communication\\n * @param {String}     options.brand      - Brand name\\n * @param {Object}     options.middleware - A middleware to call on certain API actions\\n *\\n * @property {Observable} events\\n * @property {Cache} cache - Temporary cache default to @link{InMemory}\\n * @property {Cache} storage - If specified, uses a more presistent cache (local storage, etc.)\\n */\\n\\nvar DerivAPIBasic = /*#__PURE__*/function (_DerivAPICalls) {\\n  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__.default)(DerivAPIBasic, _DerivAPICalls);\\n\\n  var _super = _createSuper(DerivAPIBasic);\\n\\n  function DerivAPIBasic() {\\n    var _this;\\n\\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\\n        storage = _ref.storage,\\n        app_id = _ref.app_id,\\n        connection = _ref.connection,\\n        _ref$cache = _ref.cache,\\n        cache = _ref$cache === void 0 ? new _InMemory__WEBPACK_IMPORTED_MODULE_13__.default() : _ref$cache,\\n        _ref$endpoint = _ref.endpoint,\\n        endpoint = _ref$endpoint === void 0 ? 'frontend.binaryws.com' : _ref$endpoint,\\n        _ref$lang = _ref.lang,\\n        lang = _ref$lang === void 0 ? 'EN' : _ref$lang,\\n        _ref$brand = _ref.brand,\\n        brand = _ref$brand === void 0 ? '' : _ref$brand,\\n        _ref$middleware = _ref.middleware,\\n        middleware = _ref$middleware === void 0 ? {} : _ref$middleware;\\n\\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3__.default)(this, DerivAPIBasic);\\n\\n    _this = _super.call(this);\\n    _this.events = new rxjs__WEBPACK_IMPORTED_MODULE_16__.Subject();\\n\\n    if (connection) {\\n      _this.connection = connection;\\n    } else {\\n      if (!app_id) throw Error('An app_id is required to connect to the API');\\n      _this.shouldReconnect = true;\\n      _this.connectionArgs = {\\n        app_id: app_id,\\n        endpointUrl: getUrl(endpoint),\\n        lang: lang.toUpperCase(),\\n        brand: brand.toLowerCase()\\n      };\\n\\n      _this.connect();\\n    }\\n\\n    _this.lang = lang;\\n    _this.reqId = 0;\\n    _this.connected = new _CustomPromise__WEBPACK_IMPORTED_MODULE_11__.default();\\n    _this.sanityErrors = new rxjs__WEBPACK_IMPORTED_MODULE_16__.Subject();\\n    _this.middleware = middleware;\\n    _this.pendingRequests = {};\\n    _this.expect_response_types = {};\\n    _this.subscription_manager = new _SubscriptionManager__WEBPACK_IMPORTED_MODULE_14__.default((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this));\\n    _this.reconnect_timeout = false;\\n    _this.keep_alive_interval = false;\\n\\n    if (storage) {\\n      _this.storage = new _Cache__WEBPACK_IMPORTED_MODULE_10__.default((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), storage);\\n    } // If we have the storage look that one up\\n\\n\\n    _this.cache = new _Cache__WEBPACK_IMPORTED_MODULE_10__.default(_this.storage ? _this.storage : (0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__.default)(_this), cache);\\n\\n    _this.connectionHandlers();\\n\\n    return _this;\\n  }\\n\\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4__.default)(DerivAPIBasic, [{\\n    key: \\\"connectionHandlers\\\",\\n    value: function connectionHandlers() {\\n      this.connection.onopen = this.openHandler.bind(this);\\n      this.connection.onclose = this.closeHandler.bind(this);\\n      this.connection.onmessage = this.messageHandler.bind(this);\\n      this.connection.onerror = this.errorHandler.bind(this);\\n    }\\n  }, {\\n    key: \\\"connect\\\",\\n    value: function connect() {\\n      if (!this.connectionArgs) {\\n        throw new _errors__WEBPACK_IMPORTED_MODULE_15__.ConstructionError('Connection arguments are required to create a connection.');\\n      }\\n\\n      this.events.next({\\n        name: 'connect'\\n      });\\n      var _this$connectionArgs = this.connectionArgs,\\n          endpointUrl = _this$connectionArgs.endpointUrl,\\n          lang = _this$connectionArgs.lang,\\n          app_id = _this$connectionArgs.app_id,\\n          brand = _this$connectionArgs.brand;\\n      this.connection = new WebSocket(\\\"\\\".concat(endpointUrl.toString(), \\\"websockets/v3?app_id=\\\").concat(app_id, \\\"&l=\\\").concat(lang, \\\"&brand=\\\").concat(brand));\\n    }\\n  }, {\\n    key: \\\"disconnect\\\",\\n    value: function disconnect() {\\n      this.shouldReconnect = false; // prevents re-connecting automatically\\n\\n      this.connection.close();\\n    }\\n  }, {\\n    key: \\\"isConnectionClosed\\\",\\n    value: function isConnectionClosed() {\\n      return this.connection.readyState === 2 || this.connection.readyState === 3;\\n    }\\n  }, {\\n    key: \\\"sendAndGetSource\\\",\\n    value: function sendAndGetSource(request) {\\n      var _this2 = this;\\n\\n      var pending = new rxjs__WEBPACK_IMPORTED_MODULE_16__.Subject();\\n      request.req_id = request.req_id || ++this.reqId;\\n      this.pendingRequests[request.req_id] = pending;\\n      this.connected.then(function () {\\n        if (_this2.isConnectionClosed()) return;\\n\\n        _this2.connection.send(JSON.stringify(request));\\n      })[\\\"catch\\\"](function (e) {\\n        return pending.error(e);\\n      });\\n      return pending;\\n    }\\n  }, {\\n    key: \\\"send\\\",\\n    value: function () {\\n      var _send = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__.default)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9___default().mark(function _callee() {\\n        var _this3 = this;\\n\\n        var _len,\\n            args,\\n            _key,\\n            send_will_be_called,\\n            request,\\n            response_promise,\\n            send_is_called,\\n            _args = arguments;\\n\\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9___default().wrap(function _callee$(_context) {\\n          while (1) {\\n            switch (_context.prev = _context.next) {\\n              case 0:\\n                for (_len = _args.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\\n                  args[_key] = _args[_key];\\n                }\\n\\n                send_will_be_called = this.callMiddleware('sendWillBeCalled', {\\n                  args: args\\n                });\\n\\n                if (!send_will_be_called) {\\n                  _context.next = 4;\\n                  break;\\n                }\\n\\n                return _context.abrupt(\\\"return\\\", send_will_be_called);\\n\\n              case 4:\\n                request = args[0];\\n                this.events.next({\\n                  name: 'send',\\n                  data: request\\n                });\\n                this.deleteFromExpectResponse(request);\\n                response_promise = this.sendAndGetSource(request).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_17__.first)()).toPromise();\\n                response_promise.then(function (response) {\\n                  _this3.cache.set(request, response);\\n\\n                  if (_this3.storage) {\\n                    _this3.storage.set(request, response);\\n                  }\\n                }, function () {}); // Ignore errors here\\n\\n                send_is_called = this.callMiddleware('sendIsCalled', {\\n                  response_promise: response_promise,\\n                  args: args\\n                });\\n\\n                if (!send_is_called) {\\n                  _context.next = 12;\\n                  break;\\n                }\\n\\n                return _context.abrupt(\\\"return\\\", send_is_called);\\n\\n              case 12:\\n                return _context.abrupt(\\\"return\\\", response_promise);\\n\\n              case 13:\\n              case \\\"end\\\":\\n                return _context.stop();\\n            }\\n          }\\n        }, _callee, this);\\n      }));\\n\\n      function send() {\\n        return _send.apply(this, arguments);\\n      }\\n\\n      return send;\\n    }()\\n  }, {\\n    key: \\\"callMiddleware\\\",\\n    value: function callMiddleware(name, args) {\\n      if (!(name in this.middleware)) return undefined;\\n      return this.middleware[name](args);\\n    }\\n  }, {\\n    key: \\\"subscribe\\\",\\n    value: function subscribe(request) {\\n      return this.subscription_manager.subscribe(request);\\n    }\\n  }, {\\n    key: \\\"forget\\\",\\n    value: function () {\\n      var _forget = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__.default)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9___default().mark(function _callee2(id) {\\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9___default().wrap(function _callee2$(_context2) {\\n          while (1) {\\n            switch (_context2.prev = _context2.next) {\\n              case 0:\\n                return _context2.abrupt(\\\"return\\\", this.subscription_manager.forget(id));\\n\\n              case 1:\\n              case \\\"end\\\":\\n                return _context2.stop();\\n            }\\n          }\\n        }, _callee2, this);\\n      }));\\n\\n      function forget(_x) {\\n        return _forget.apply(this, arguments);\\n      }\\n\\n      return forget;\\n    }()\\n  }, {\\n    key: \\\"forgetAll\\\",\\n    value: function () {\\n      var _forgetAll = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__.default)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9___default().mark(function _callee3() {\\n        var _this$subscription_ma;\\n\\n        var _args3 = arguments;\\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9___default().wrap(function _callee3$(_context3) {\\n          while (1) {\\n            switch (_context3.prev = _context3.next) {\\n              case 0:\\n                return _context3.abrupt(\\\"return\\\", (_this$subscription_ma = this.subscription_manager).forgetAll.apply(_this$subscription_ma, _args3));\\n\\n              case 1:\\n              case \\\"end\\\":\\n                return _context3.stop();\\n            }\\n          }\\n        }, _callee3, this);\\n      }));\\n\\n      function forgetAll() {\\n        return _forgetAll.apply(this, arguments);\\n      }\\n\\n      return forgetAll;\\n    }()\\n  }, {\\n    key: \\\"keepAlivePing\\\",\\n    value: function keepAlivePing() {\\n      this.ping({\\n        ping: 1\\n      });\\n      this.reconnect_timeout = setTimeout(this.reconnect.bind(this), 5000);\\n    }\\n  }, {\\n    key: \\\"pong\\\",\\n    value: function pong() {\\n      if (this.reconnect_timeout) {\\n        clearTimeout(this.reconnect_timeout);\\n        this.reconnect_timeout = false;\\n      }\\n    }\\n  }, {\\n    key: \\\"openHandler\\\",\\n    value: function openHandler() {\\n      this.events.next({\\n        name: 'open'\\n      });\\n\\n      if (this.shouldReconnect) {\\n        this.keep_alive_interval = setInterval(this.keepAlivePing.bind(this), 30000);\\n      }\\n\\n      if (this.connection.readyState === 1) {\\n        this.connected.resolve();\\n      } else {\\n        setTimeout(this.openHandler.bind(this), 50);\\n      }\\n    }\\n  }, {\\n    key: \\\"messageHandler\\\",\\n    value: function messageHandler(msg) {\\n      if (!msg.data) {\\n        this.sanityErrors.next(new _errors__WEBPACK_IMPORTED_MODULE_15__.APIError('Something went wrong while receiving the response from API.'));\\n        return;\\n      }\\n\\n      var response = JSON.parse(msg.data);\\n\\n      if (this.reconnect_timeout && response.ping === 'pong') {\\n        this.pong();\\n      }\\n\\n      this.events.next({\\n        name: 'message',\\n        data: response\\n      });\\n      var reqId = response.req_id;\\n\\n      if (reqId in this.pendingRequests) {\\n        var expect_response = this.expect_response_types[response.msg_type];\\n\\n        if (expect_response && expect_response.isPending()) {\\n          expect_response.resolve(response);\\n        }\\n\\n        var request = response.echo_req; // When one of the child subscriptions of `proposal_open_contract` has an error in the response,\\n        // it should be handled in the callback of consumer instead. Calling `error()` with parent subscription\\n        // will mark the parent subscription as complete and all child subscriptions will be forgotten.\\n\\n        var is_parent_subscription = request && request.proposal_open_contract && !request.contract_id;\\n\\n        if (response.error && !is_parent_subscription) {\\n          this.pendingRequests[reqId].error(response);\\n        } else if (this.pendingRequests[reqId].isStopped && response.subscription) {\\n          // Source is already marked as completed. In this case we should\\n          // send a forget request with the subscription id and ignore the response received.\\n          var id = response.subscription.id;\\n          this.forget(id);\\n        } else {\\n          this.pendingRequests[reqId].next(response);\\n        }\\n      } else {\\n        this.sanityErrors.next(new _errors__WEBPACK_IMPORTED_MODULE_15__.APIError('Extra response'));\\n      }\\n    }\\n    /**\\n     * Reconnects to the API in case of connection error, unless connection is\\n     * passed as an argument, in that case reconnecting should be handled in the\\n     * API user side.\\n     * */\\n\\n  }, {\\n    key: \\\"closeHandler\\\",\\n    value: function closeHandler() {\\n      this.events.next({\\n        name: 'close'\\n      });\\n\\n      if (this.shouldReconnect) {\\n        this.events.next({\\n          name: 'reconnecting'\\n        });\\n        this.reconnect();\\n      }\\n    }\\n    /**\\n     * Clears previous connection keeplive ping timeout and connect & assign the handles\\n     */\\n\\n  }, {\\n    key: \\\"reconnect\\\",\\n    value: function reconnect() {\\n      if (this.shouldReconnect) {\\n        if (this.keep_alive_interval) {\\n          clearInterval(this.keep_alive_interval);\\n          this.keep_alive_interval = false;\\n        }\\n\\n        this.pong(); // clear all previous timeout\\n\\n        this.connect();\\n        this.connectionHandlers();\\n      }\\n    }\\n  }, {\\n    key: \\\"errorHandler\\\",\\n    value: function errorHandler() {\\n      this.sanityErrors.next(new _errors__WEBPACK_IMPORTED_MODULE_15__.APIError('Something went wrong while receiving the response from API.'));\\n    }\\n    /**\\n     * @returns {Observable} for close events\\n     */\\n\\n  }, {\\n    key: \\\"onClose\\\",\\n    value: function onClose() {\\n      return this.events.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_18__.filter)(function (e) {\\n        return e.name === 'close';\\n      }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_19__.share)());\\n    }\\n    /**\\n     * @returns {Observable} for open events\\n     */\\n\\n  }, {\\n    key: \\\"onOpen\\\",\\n    value: function onOpen() {\\n      return this.events.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_18__.filter)(function (e) {\\n        return e.name === 'open';\\n      }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_19__.share)());\\n    }\\n    /**\\n     * @returns {Observable} for new messages\\n     */\\n\\n  }, {\\n    key: \\\"onMessage\\\",\\n    value: function onMessage() {\\n      return this.events.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_18__.filter)(function (e) {\\n        return e.name === 'message';\\n      }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_19__.share)());\\n    }\\n    /**\\n     * @param {String} types Expect these types to be received by the API\\n     *\\n     * @returns {Promise<Object>|Promise<Array>} Resolves to a single response or an array\\n     */\\n\\n  }, {\\n    key: \\\"expectResponse\\\",\\n    value: function () {\\n      var _expectResponse = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__.default)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9___default().mark(function _callee4() {\\n        var _this4 = this;\\n\\n        var _len2,\\n            types,\\n            _key2,\\n            _args4 = arguments;\\n\\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9___default().wrap(function _callee4$(_context4) {\\n          while (1) {\\n            switch (_context4.prev = _context4.next) {\\n              case 0:\\n                for (_len2 = _args4.length, types = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\\n                  types[_key2] = _args4[_key2];\\n                }\\n\\n                types.forEach(function (type) {\\n                  if (!(type in _this4.expect_response_types)) {\\n                    _this4.expect_response_types[type] = transformUndefinedToPromise(_this4.cache.getByMsgType(type).then(function (value) {\\n                      if (!value && _this4.storage) return _this4.storage.getByMsgType(type);\\n                      return value;\\n                    }));\\n                  }\\n                }); // expect on a single response returns a single response, not a list\\n\\n                if (!(types.length === 1)) {\\n                  _context4.next = 4;\\n                  break;\\n                }\\n\\n                return _context4.abrupt(\\\"return\\\", this.expect_response_types[types[0]]);\\n\\n              case 4:\\n                return _context4.abrupt(\\\"return\\\", Promise.all(types.map(function (type) {\\n                  return _this4.expect_response_types[type];\\n                })));\\n\\n              case 5:\\n              case \\\"end\\\":\\n                return _context4.stop();\\n            }\\n          }\\n        }, _callee4, this);\\n      }));\\n\\n      function expectResponse() {\\n        return _expectResponse.apply(this, arguments);\\n      }\\n\\n      return expectResponse;\\n    }()\\n  }, {\\n    key: \\\"deleteFromExpectResponse\\\",\\n    value: function deleteFromExpectResponse(request) {\\n      var response_type = Object.keys(this.expect_response_types).find(function (type) {\\n        return type in request;\\n      });\\n\\n      if (this.expect_response_types[response_type] && !this.expect_response_types[response_type].isPending()) {\\n        delete this.expect_response_types[response_type];\\n      }\\n    }\\n  }]);\\n\\n  return DerivAPIBasic;\\n}(_DerivAPICalls__WEBPACK_IMPORTED_MODULE_12__.default);\\n\\n\\n\\nfunction getUrl(originalEndpoint) {\\n  if (typeof originalEndpoint !== 'string') {\\n    throw new _errors__WEBPACK_IMPORTED_MODULE_15__.ConstructionError(\\\"Endpoint must be a string, passed: \\\".concat((0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_1__.default)(originalEndpoint)));\\n  }\\n\\n  var url;\\n\\n  try {\\n    // eslint-disable-next-line no-unused-vars\\n    var _originalEndpoint$mat = originalEndpoint.match(/((?:\\\\w*:\\\\/\\\\/)*)(.*)/),\\n        _originalEndpoint$mat2 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__.default)(_originalEndpoint$mat, 3),\\n        _ = _originalEndpoint$mat2[0],\\n        protocol = _originalEndpoint$mat2[1],\\n        endpoint = _originalEndpoint$mat2[2];\\n\\n    url = new URL(\\\"\\\".concat(protocol === 'ws://' ? protocol : 'wss://').concat(endpoint));\\n  } catch (e) {\\n    throw new _errors__WEBPACK_IMPORTED_MODULE_15__.ConstructionError(\\\"Invalid URL: \\\".concat(originalEndpoint));\\n  }\\n\\n  return url;\\n}\\n\\nfunction transformUndefinedToPromise(promise) {\\n  return _CustomPromise__WEBPACK_IMPORTED_MODULE_11__.default.wrap(promise.then(function (value) {\\n    if (!value) return new _CustomPromise__WEBPACK_IMPORTED_MODULE_11__.default();\\n    return value;\\n  }));\\n}\\n\\n//# sourceURL=webpack://DerivAPIBasic/./src/deriv_api/DerivAPIBasic.js?\");\n\n/***/ }),\n\n/***/ \"./src/deriv_api/DerivAPICalls.js\":\n/*!****************************************!*\\\n  !*** ./src/deriv_api/DerivAPICalls.js ***!\n  \\****************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ DerivAPICalls)\\n/* harmony export */ });\\n/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ \\\"./node_modules/@babel/runtime/helpers/esm/typeof.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \\\"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \\\"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \\\"./node_modules/@babel/runtime/helpers/esm/createClass.js\\\");\\n\\n\\n\\n\\n\\n// This file was automatically generated by regen-js.pl at 20210913-235246\\n// applies JSON schema to generate Deriv API\\n\\n/* eslint-disable max-len */\\n// =======================\\n// ----- API Methods -----\\n// =======================\\nvar DerivAPICalls = /*#__PURE__*/function () {\\n  function DerivAPICalls() {\\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__.default)(this, DerivAPICalls);\\n  }\\n\\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__.default)(DerivAPICalls, [{\\n    key: \\\"accountClosure\\\",\\n    value: // To be implemented by the sub-class\\n    // constructor() { }\\n\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.account_closure - Must be `1`\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.reason - Reason for closing off accounts.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n    function accountClosure() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        account_closure: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        reason: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'account_closure',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.account_security - Must be `1`\\n     * @param {String} args.otp - [Optional] OTP (one-time passcode) generated by a 2FA application like Authy, Google Authenticator or Yubikey.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {String} args.totp_action - [Optional] Action to be taken for managing TOTP (time-based one-time password, RFC6238). Generate will create a secret key which is then returned in the secret_key response field, you can then enable by using that code in a 2FA application.\\n     */\\n\\n  }, {\\n    key: \\\"accountSecurity\\\",\\n    value: function accountSecurity() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        account_security: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        otp: {\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        totp_action: {\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'account_security',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.account_statistics - Must be `1`\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"accountStatistics\\\",\\n    value: function accountStatistics() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        account_statistics: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'account_statistics',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.active_symbols - If you use `brief`, only a subset of fields will be returned.\\n     * @param {String} args.landing_company - [Optional] If you specify this field, only symbols available for trading by that landing company will be returned. If you are logged in, only symbols available for trading by your landing company will be returned regardless of what you specify in this field.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.product_type - [Optional] If you specify this field, only symbols that can be traded through that product type will be returned.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"activeSymbols\\\",\\n    value: function activeSymbols() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        active_symbols: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        landing_company: {\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        product_type: {\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'active_symbols',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.account_opening_reason - [Optional] Purpose and reason for requesting the account opening.\\n     * @param {String} args.account_turnover - [Optional] The anticipated account turnover.\\n     * @param {String} args.address_city - [Optional] Within 100 characters.\\n     * @param {String} args.address_line_1 - Within 70 characters, with no leading whitespaces and may contain letters/numbers and/or any of following characters '.,:;()@#/-\\n     * @param {String} args.address_line_2 - [Optional] Within 70 characters.\\n     * @param {String} args.address_postcode - [Optional] Within 20 characters and may not contain '+'.\\n     * @param {String} args.address_state - [Optional] Possible value receive from `states_list` call.\\n     * @param {Number} args.affiliate_account_add - Must be `1`\\n     * @param {String} args.affiliate_plan - The affiliate plan the account will subscribe to\\n     * @param {String} args.affiliate_token - [Optional] Affiliate token, within 32 characters.\\n     * @param {Any} args.citizen - [Optional] Country of legal citizenship, 2-letter country code.\\n     * @param {String} args.client_type - [Optional] Indicates whether this is for a client requesting an account with professional status.\\n     * @param {String} args.currency - [Optional] To set currency of the account. List of supported currencies can be acquired with `payout_currencies` call.\\n     * @param {String} args.date_of_birth - Date of birth format: `yyyy-mm-dd`.\\n     * @param {String} args.first_name - Within 2-50 characters, use only letters, spaces, hyphens, full-stops or apostrophes.\\n     * @param {String} args.last_name - Within 2-50 characters, use only letters, spaces, hyphens, full-stops or apostrophes.\\n     * @param {Number} args.non_pep_declaration - [Optional] Indicates client's self-declaration of not being a PEP/RCA (Politically Exposed Person/Relatives and Close Associates).\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Any} args.phone - [Optional] Starting with `+` followed by 9-35 digits, hyphens or space.\\n     * @param {String} args.place_of_birth - [Optional] Place of birth, 2-letter country code.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {String} args.residence - 2-letter country code, possible value receive from `residence_list` call.\\n     * @param {String} args.salutation - [Optional] Accept any value in enum list.\\n     * @param {String} args.secret_answer - [Optional] Answer to secret question, within 4-50 characters. Required for new account and existing client details will be used if client open another account.\\n     * @param {String} args.secret_question - [Optional] Accept any value in enum list. Required for new account and existing client details will be used if client open another account.\\n     * @param {String} args.tax_identification_number - [Optional] Tax identification number. Only applicable for real money account. Required for `maltainvest` landing company.\\n     * @param {String} args.tax_residence - [Optional] Residence for tax purpose. Comma separated iso country code if multiple jurisdictions. Only applicable for real money account. Required for `maltainvest` landing company.\\n     */\\n\\n  }, {\\n    key: \\\"affiliateAccountAdd\\\",\\n    value: function affiliateAccountAdd() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        account_opening_reason: {\\n          type: 'string'\\n        },\\n        account_turnover: {\\n          type: 'string'\\n        },\\n        address_city: {\\n          type: 'string'\\n        },\\n        address_line_1: {\\n          type: 'string'\\n        },\\n        address_line_2: {\\n          type: 'string'\\n        },\\n        address_postcode: {\\n          type: 'string'\\n        },\\n        address_state: {\\n          type: 'string'\\n        },\\n        affiliate_account_add: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        affiliate_plan: {\\n          type: 'string'\\n        },\\n        affiliate_token: {\\n          type: 'string'\\n        },\\n        citizen: {},\\n        client_type: {\\n          type: 'string'\\n        },\\n        currency: {\\n          type: 'string'\\n        },\\n        date_of_birth: {\\n          type: 'string'\\n        },\\n        first_name: {\\n          type: 'string'\\n        },\\n        last_name: {\\n          type: 'string'\\n        },\\n        non_pep_declaration: {\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        phone: {},\\n        place_of_birth: {\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        residence: {\\n          type: 'string'\\n        },\\n        salutation: {\\n          type: 'string'\\n        },\\n        secret_answer: {\\n          type: 'string'\\n        },\\n        secret_question: {\\n          type: 'string'\\n        },\\n        tax_identification_number: {\\n          type: 'string'\\n        },\\n        tax_residence: {\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'affiliate_account_add',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.api_token - Must be `1`\\n     * @param {String} args.delete_token - [Optional] The token to remove.\\n     * @param {String} args.new_token - [Optional] The name of the created token.\\n     * @param {Any} args.new_token_scopes - [Optional] List of permission scopes to provide with the token.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.valid_for_current_ip_only - [Optional] If you set this parameter during token creation, then the token created will only work for the IP address that was used to create the token\\n     */\\n\\n  }, {\\n    key: \\\"apiToken\\\",\\n    value: function apiToken() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        api_token: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        delete_token: {\\n          type: 'string'\\n        },\\n        new_token: {\\n          type: 'string'\\n        },\\n        new_token_scopes: {},\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        valid_for_current_ip_only: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'api_token',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.app_delete - Application app_id\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"appDelete\\\",\\n    value: function appDelete() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        app_delete: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'app_delete',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.app_get - Application app_id\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"appGet\\\",\\n    value: function appGet() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        app_get: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'app_get',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.app_list - Must be `1`\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"appList\\\",\\n    value: function appList() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        app_list: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'app_list',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.app_id - [Optional] Specific application `app_id` to report on.\\n     * @param {Number} args.app_markup_details - Must be `1`\\n     * @param {String} args.client_loginid - [Optional] Specific client loginid to report on, like CR12345\\n     * @param {String} args.date_from - Start date (epoch or YYYY-MM-DD HH:MM:SS). Results are inclusive of this time.\\n     * @param {String} args.date_to - End date (epoch or YYYY-MM-DD HH::MM::SS). Results are inclusive of this time.\\n     * @param {Number} args.description - [Optional] If set to 1, will return `app_markup` transaction details.\\n     * @param {Number} args.limit - [Optional] Apply upper limit to count of transactions received.\\n     * @param {Number} args.offset - [Optional] Number of transactions to skip.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {String} args.sort - [Optional] Sort direction on `transaction_time`. Other fields sort order is ASC.\\n     * @param {Any} args.sort_fields - [Optional] One or more of the specified fields to sort on. Default sort field is by `transaction_time`.\\n     */\\n\\n  }, {\\n    key: \\\"appMarkupDetails\\\",\\n    value: function appMarkupDetails() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        app_id: {\\n          type: 'numeric'\\n        },\\n        app_markup_details: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        client_loginid: {\\n          type: 'string'\\n        },\\n        date_from: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        date_to: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        description: {\\n          type: 'numeric'\\n        },\\n        limit: {\\n          type: 'numeric'\\n        },\\n        offset: {\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        sort: {\\n          type: 'string'\\n        },\\n        sort_fields: {}\\n      };\\n      var allArgs = {\\n        method: 'app_markup_details',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.app_markup_percentage - [Optional] Markup to be added to contract prices (as a percentage of contract payout).\\n     * @param {Number} args.app_register - Must be `1`\\n     * @param {String} args.appstore - [Optional] Application's App Store URL (if applicable).\\n     * @param {String} args.github - [Optional] Application's GitHub page (for open-source projects).\\n     * @param {String} args.googleplay - [Optional] Application's Google Play URL (if applicable).\\n     * @param {String} args.homepage - [Optional] Application's homepage URL.\\n     * @param {String} args.name - Application name.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.redirect_uri - [Optional] The URL to redirect to after a successful login. Required if charging markup percentage\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Any} args.scopes - List of permission scopes to grant the application.\\n     * @param {String} args.verification_uri - [Optional] Used when `verify_email` called. If available, a URL containing the verification token will be sent to the client's email, otherwise only the token will be sent.\\n     */\\n\\n  }, {\\n    key: \\\"appRegister\\\",\\n    value: function appRegister() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        app_markup_percentage: {\\n          type: 'numeric'\\n        },\\n        app_register: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        appstore: {\\n          type: 'string'\\n        },\\n        github: {\\n          type: 'string'\\n        },\\n        googleplay: {\\n          type: 'string'\\n        },\\n        homepage: {\\n          type: 'string'\\n        },\\n        name: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        redirect_uri: {\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        scopes: {\\n          required: 1\\n        },\\n        verification_uri: {\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'app_register',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.app_markup_percentage - [Optional] Markup to be added to contract prices (as a percentage of contract payout).\\n     * @param {Number} args.app_update - Application app_id.\\n     * @param {String} args.appstore - [Optional] Application's App Store URL (if applicable).\\n     * @param {String} args.github - [Optional] Application's GitHub page (for open-source projects).\\n     * @param {String} args.googleplay - [Optional] Application's Google Play URL (if applicable).\\n     * @param {String} args.homepage - [Optional] Application's homepage URL.\\n     * @param {String} args.name - Application name.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.redirect_uri - [Optional] The URL to redirect to after a successful login. Required if charging markup percentage.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Any} args.scopes - Change scopes will revoke all user's grants and log them out.\\n     * @param {String} args.verification_uri - [Optional] Used when `verify_email` called. If available, a URL containing the verification token will send to the client's email, otherwise only the token will be sent.\\n     */\\n\\n  }, {\\n    key: \\\"appUpdate\\\",\\n    value: function appUpdate() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        app_markup_percentage: {\\n          type: 'numeric'\\n        },\\n        app_update: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        appstore: {\\n          type: 'string'\\n        },\\n        github: {\\n          type: 'string'\\n        },\\n        googleplay: {\\n          type: 'string'\\n        },\\n        homepage: {\\n          type: 'string'\\n        },\\n        name: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        redirect_uri: {\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        scopes: {\\n          required: 1\\n        },\\n        verification_uri: {\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'app_update',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.asset_index - Must be `1`\\n     * @param {String} args.landing_company - [Optional] If specified, will return only the underlyings for the specified landing company.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"assetIndex\\\",\\n    value: function assetIndex() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        asset_index: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        landing_company: {\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'asset_index',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.add_to_login_history - [Optional] Send this when you use api tokens for authorization and want to track activity using `login_history` call.\\n     * @param {String} args.authorize - Authentication token. May be retrieved from https://www.binary.com/en/user/security/api_tokenws.html\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"authorize\\\",\\n    value: function authorize() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        add_to_login_history: {\\n          type: 'numeric'\\n        },\\n        authorize: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'authorize',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.account - [Optional] If set to `all`, return the balances of all accounts one by one; if set to `current`, return the balance of current account; if set as an account id, return the balance of that account.\\n     * @param {Number} args.balance - Must be `1`\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.subscribe - [Optional] If set to 1, will send updates whenever the balance changes.\\n     */\\n\\n  }, {\\n    key: \\\"balance\\\",\\n    value: function balance() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        account: {\\n          type: 'string'\\n        },\\n        balance: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        subscribe: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'balance',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.buy - Either the ID received from a Price Proposal (`proposal` call), or `1` if contract buy parameters are passed in the `parameters` field.\\n     * @param {Any} args.parameters -\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.price - Maximum price at which to purchase the contract.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.subscribe - [Optional] `1` to stream.\\n     */\\n\\n  }, {\\n    key: \\\"buy\\\",\\n    value: function buy() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        buy: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        parameters: {\\n          amount: {\\n            type: 'numeric'\\n          },\\n          app_markup_percentage: {\\n            type: 'numeric'\\n          },\\n          barrier: {\\n            type: 'string'\\n          },\\n          barrier2: {\\n            type: 'string'\\n          },\\n          basis: {\\n            type: 'string'\\n          },\\n          cancellation: {\\n            type: 'string'\\n          },\\n          contract_type: {\\n            required: 1,\\n            type: 'string'\\n          },\\n          currency: {\\n            required: 1,\\n            type: 'string'\\n          },\\n          date_expiry: {\\n            type: 'numeric'\\n          },\\n          date_start: {\\n            type: 'numeric'\\n          },\\n          duration: {\\n            type: 'numeric'\\n          },\\n          duration_unit: {\\n            type: 'string'\\n          },\\n          limit_order: {\\n            stop_loss: {\\n              type: 'numeric'\\n            },\\n            take_profit: {\\n              type: 'numeric'\\n            }\\n          },\\n          multiplier: {\\n            type: 'numeric'\\n          },\\n          product_type: {\\n            type: 'string'\\n          },\\n          selected_tick: {\\n            type: 'numeric'\\n          },\\n          symbol: {\\n            required: 1,\\n            type: 'string'\\n          },\\n          trading_period_start: {\\n            type: 'numeric'\\n          }\\n        },\\n        passthrough: {},\\n        price: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        subscribe: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'buy',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.buy_contract_for_multiple_accounts - Either the ID received from a Price Proposal (`proposal` call), or `1` if contract buy parameters are passed in the `parameters` field.\\n     * @param {Any} args.parameters -\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.price - Maximum price at which to purchase the contract.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Any} args.tokens - List of API tokens identifying the accounts for which the contract is bought. Note: If the same token appears multiple times or if multiple tokens designate the same account, the contract is bought multiple times for this account.\\n     */\\n\\n  }, {\\n    key: \\\"buyContractForMultipleAccounts\\\",\\n    value: function buyContractForMultipleAccounts() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        buy_contract_for_multiple_accounts: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        parameters: {\\n          amount: {\\n            type: 'numeric'\\n          },\\n          app_markup_percentage: {\\n            type: 'numeric'\\n          },\\n          barrier: {\\n            type: 'string'\\n          },\\n          barrier2: {\\n            type: 'string'\\n          },\\n          basis: {\\n            type: 'string'\\n          },\\n          contract_type: {\\n            required: 1,\\n            type: 'string'\\n          },\\n          currency: {\\n            required: 1,\\n            type: 'string'\\n          },\\n          date_expiry: {\\n            type: 'numeric'\\n          },\\n          date_start: {\\n            type: 'numeric'\\n          },\\n          duration: {\\n            type: 'numeric'\\n          },\\n          duration_unit: {\\n            type: 'string'\\n          },\\n          multiplier: {\\n            type: 'numeric'\\n          },\\n          selected_tick: {\\n            type: 'numeric'\\n          },\\n          symbol: {\\n            required: 1,\\n            type: 'string'\\n          }\\n        },\\n        passthrough: {},\\n        price: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        tokens: {\\n          required: 1\\n        }\\n      };\\n      var allArgs = {\\n        method: 'buy_contract_for_multiple_accounts',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.cancel - Value should be the `contract_id` which received from the `portfolio` call.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"cancel\\\",\\n    value: function cancel() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        cancel: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'cancel',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.address - [Optional] Address for crypto withdrawal. Only applicable for `api` type.\\n     * @param {Number} args.amount - [Optional] Amount for crypto withdrawal. Only applicable for `api` type.\\n     * @param {String} args.cashier - Operation which needs to be requested from cashier\\n     * @param {Number} args.dry_run - [Optional] If set to `1`, only validation is performed. Only applicable for `withdraw` using `crypto` provider and `api` type.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.provider - [Optional] Cashier provider. `crypto` will be default option for crypto currency accounts.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {String} args.type - [Optional] Data need to be returned from cashier. `api` is supported only for `crypto` provider.\\n     * @param {String} args.verification_code - [Optional] Email verification code (received from a `verify_email` call, which must be done first)\\n     */\\n\\n  }, {\\n    key: \\\"cashier\\\",\\n    value: function cashier() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        address: {\\n          type: 'string'\\n        },\\n        amount: {\\n          type: 'numeric'\\n        },\\n        cashier: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        dry_run: {\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        provider: {\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        type: {\\n          type: 'string'\\n        },\\n        verification_code: {\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'cashier',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.cashier_payments - Must be `1`\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.provider - [Optional] Cashier provider. `crypto` will be default option for crypto currency accounts.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.subscribe - [Optional] If set to 1, will send updates whenever there is update to crypto payments.\\n     * @param {String} args.transaction_type - [Optional] Type of transactions to receive.\\n     */\\n\\n  }, {\\n    key: \\\"cashierPayments\\\",\\n    value: function cashierPayments() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        cashier_payments: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        provider: {\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        subscribe: {\\n          type: 'numeric'\\n        },\\n        transaction_type: {\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'cashier_payments',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.cashier_withdrawal_cancel - Must be `1`\\n     * @param {String} args.id - The unique identifier for the transaction.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"cashierWithdrawalCancel\\\",\\n    value: function cashierWithdrawalCancel() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        cashier_withdrawal_cancel: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        id: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'cashier_withdrawal_cancel',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.change_password - Must be `1`\\n     * @param {String} args.new_password - New password (Accepts any printable ASCII character. Must be within 8-25 characters, and include numbers, lowercase and uppercase letters. Must not be the same as the user's email address)\\n     * @param {String} args.old_password - Old password for validation (non-empty string, accepts any printable ASCII character)\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"changePassword\\\",\\n    value: function changePassword() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        change_password: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        new_password: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        old_password: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'change_password',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.contract_id - Internal unique contract identifier.\\n     * @param {Number} args.contract_update - Must be `1`\\n     * @param {Any} args.limit_order -\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"contractUpdate\\\",\\n    value: function contractUpdate() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        contract_id: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        contract_update: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        limit_order: {\\n          stop_loss: {},\\n          take_profit: {}\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'contract_update',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.contract_id - Internal unique contract identifier.\\n     * @param {Number} args.contract_update_history - Must be `1`\\n     * @param {Number} args.limit - [Optional] Maximum number of historical updates to receive.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"contractUpdateHistory\\\",\\n    value: function contractUpdateHistory() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        contract_id: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        contract_update_history: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        limit: {\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'contract_update_history',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.contracts_for - The short symbol name (obtained from `active_symbols` call).\\n     * @param {String} args.currency - [Optional] Currency of the contract's stake and payout (obtained from `payout_currencies` call).\\n     * @param {String} args.landing_company - [Optional] Indicates which landing company to get a list of contracts for. If you are logged in, your account's landing company will override this field.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.product_type - [Optional] If you specify this field, only contracts tradable through that contract type will be returned.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"contractsFor\\\",\\n    value: function contractsFor() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        contracts_for: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        currency: {\\n          type: 'string'\\n        },\\n        landing_company: {\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        product_type: {\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'contracts_for',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.assets - [Optional] Used to set assets to be copied. E.x [\\\"frxUSDJPY\\\", \\\"R_50\\\"]\\n     * @param {String} args.copy_start - API tokens identifying the accounts of trader which will be used to copy trades\\n     * @param {Number} args.max_trade_stake - [Optional] Used to set maximum trade stake to be copied.\\n     * @param {Number} args.min_trade_stake - [Optional] Used to set minimal trade stake to be copied.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Any} args.trade_types - [Optional] Used to set trade types to be copied. E.x [\\\"CALL\\\", \\\"PUT\\\"]\\n     */\\n\\n  }, {\\n    key: \\\"copyStart\\\",\\n    value: function copyStart() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        assets: {},\\n        copy_start: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        max_trade_stake: {\\n          type: 'numeric'\\n        },\\n        min_trade_stake: {\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        trade_types: {}\\n      };\\n      var allArgs = {\\n        method: 'copy_start',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.copy_stop - API tokens identifying the accounts which needs not to be copied\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"copyStop\\\",\\n    value: function copyStop() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        copy_stop: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'copy_stop',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.copytrading_list - Must be `1`\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"copytradingList\\\",\\n    value: function copytradingList() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        copytrading_list: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'copytrading_list',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.copytrading_statistics - Must be `1`\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {String} args.trader_id - The ID of the target trader.\\n     */\\n\\n  }, {\\n    key: \\\"copytradingStatistics\\\",\\n    value: function copytradingStatistics() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        copytrading_statistics: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        trader_id: {\\n          required: 1,\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'copytrading_statistics',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.document_format - Document file format\\n     * @param {String} args.document_id - [Optional] Document ID (required for Passport, Proof of ID and Driver's License)\\n     * @param {String} args.document_issuing_country - [Optional] 2-letter country code\\n     * @param {String} args.document_type - Document type\\n     * @param {Number} args.document_upload - Must be `1`\\n     * @param {String} args.expected_checksum - The checksum of the file to be uploaded\\n     * @param {String} args.expiration_date - [Optional] Document expiration date (required for Passport, Proof of ID and Driver's License)\\n     * @param {Number} args.file_size - Document size (should be less than 10MB)\\n     * @param {Number} args.lifetime_valid - [Optional] Boolean value that indicates whether this document is lifetime valid (only applies to POI document types, cancels out the expiration_date given if any)\\n     * @param {String} args.page_type - [Optional] To determine document side\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"documentUpload\\\",\\n    value: function documentUpload() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        document_format: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        document_id: {\\n          type: 'string'\\n        },\\n        document_issuing_country: {\\n          type: 'string'\\n        },\\n        document_type: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        document_upload: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        expected_checksum: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        expiration_date: {\\n          type: 'string'\\n        },\\n        file_size: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        lifetime_valid: {\\n          type: 'numeric'\\n        },\\n        page_type: {\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'document_upload',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.currency - [Optional] Currency symbol.\\n     * @param {Number} args.economic_calendar - Must be `1`\\n     * @param {Number} args.end_date - [Optional] End date.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.start_date - [Optional] Start date.\\n     */\\n\\n  }, {\\n    key: \\\"economicCalendar\\\",\\n    value: function economicCalendar() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        currency: {\\n          type: 'string'\\n        },\\n        economic_calendar: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        end_date: {\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        start_date: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'economic_calendar',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.base_currency - Base currency (can be obtained from `payout_currencies` call)\\n     * @param {Number} args.exchange_rates - Must be `1`\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"exchangeRates\\\",\\n    value: function exchangeRates() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        base_currency: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        exchange_rates: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'exchange_rates',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.forget - ID of the real-time stream of messages to cancel.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"forget\\\",\\n    value: function forget() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        forget: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'forget',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.forget_all - Cancel all streams by type. The value can be either a single type e.g. `\\\"ticks\\\"`, or an array of multiple types e.g. `[\\\"candles\\\", \\\"ticks\\\"]`.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"forgetAll\\\",\\n    value: function forgetAll() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        forget_all: {\\n          required: 1\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'forget_all',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.get_account_status - Must be `1`\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"getAccountStatus\\\",\\n    value: function getAccountStatus() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        get_account_status: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'get_account_status',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.get_financial_assessment - Must be `1`\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"getFinancialAssessment\\\",\\n    value: function getFinancialAssessment() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        get_financial_assessment: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'get_financial_assessment',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.get_limits - Must be `1`\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"getLimits\\\",\\n    value: function getLimits() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        get_limits: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'get_limits',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.get_self_exclusion - Must be `1`\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"getSelfExclusion\\\",\\n    value: function getSelfExclusion() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        get_self_exclusion: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'get_self_exclusion',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.get_settings - Must be `1`\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"getSettings\\\",\\n    value: function getSettings() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        get_settings: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'get_settings',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.document_number - The identification number of the document.\\n     * @param {String} args.document_type - The type of the document based on provided `issuing_country` (can obtained from `residence_list` call).\\n     * @param {Number} args.identity_verification_document_add - Must be `1`\\n     * @param {String} args.issuing_country - 2-letter country code (can obtained from `residence_list` call).\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"identityVerificationDocumentAdd\\\",\\n    value: function identityVerificationDocumentAdd() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        document_number: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        document_type: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        identity_verification_document_add: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        issuing_country: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'identity_verification_document_add',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.landing_company - Client's 2-letter country code (obtained from `residence_list` call).\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"landingCompany\\\",\\n    value: function landingCompany() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        landing_company: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'landing_company',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.landing_company_details - Landing company shortcode.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"landingCompanyDetails\\\",\\n    value: function landingCompanyDetails() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        landing_company_details: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'landing_company_details',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.client_id - The unique identifier for this trading account.\\n     * @param {Number} args.link_wallet - Must be `1`\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {String} args.wallet_id - The unique identifier for this wallet.\\n     */\\n\\n  }, {\\n    key: \\\"linkWallet\\\",\\n    value: function linkWallet() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        client_id: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        link_wallet: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        wallet_id: {\\n          required: 1,\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'link_wallet',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.limit - [Optional] Apply limit to count of login history records.\\n     * @param {Number} args.login_history - Must be `1`\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"loginHistory\\\",\\n    value: function loginHistory() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        limit: {\\n          type: 'numeric'\\n        },\\n        login_history: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'login_history',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.logout - Must be `1`\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"logout\\\",\\n    value: function logout() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        logout: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'logout',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.amount - Amount to deposit (in the currency of from_binary); min = $1 or an equivalent amount, max = $20000 or an equivalent amount\\n     * @param {String} args.from_binary - Binary account loginid to transfer money from\\n     * @param {Number} args.mt5_deposit - Must be `1`\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {String} args.to_mt5 - MT5 account login to deposit money to\\n     */\\n\\n  }, {\\n    key: \\\"mt5Deposit\\\",\\n    value: function mt5Deposit() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        amount: {\\n          type: 'numeric'\\n        },\\n        from_binary: {\\n          type: 'string'\\n        },\\n        mt5_deposit: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        to_mt5: {\\n          required: 1,\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'mt5_deposit',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.login - MT5 user login\\n     * @param {Number} args.mt5_get_settings - Must be `1`\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"mt5GetSettings\\\",\\n    value: function mt5GetSettings() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        login: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        mt5_get_settings: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'mt5_get_settings',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.mt5_login_list - Must be `1`\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"mt5LoginList\\\",\\n    value: function mt5LoginList() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        mt5_login_list: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'mt5_login_list',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.account_type - Account type. If set to 'financial', setting 'mt5_account_type' is also required.\\n     * @param {String} args.address - [Optional] The address of the user. The maximum length of this address field is 128 characters.\\n     * @param {String} args.city - [Optional] User's city of residence.\\n     * @param {String} args.company - [Optional] Name of the client's company. The maximum length of the company name is 64 characters.\\n     * @param {String} args.country - [Optional] 2-letter country code (value received from `residence_list` call).\\n     * @param {String} args.currency - [Optional] MT5 account currency, the default value will be the qualified account currency.\\n     * @param {Number} args.dry_run - [Optional] If set to 1, only validation is performed.\\n     * @param {String} args.email - Email address\\n     * @param {String} args.investPassword - [Optional] The investor password of the account. For validation (Accepts any printable ASCII character. Must be within 8-25 characters, and include numbers, lowercase and uppercase letters. Must not be the same as the user's email address).\\n     * @param {Number} args.leverage - Client leverage (from 1 to 1000).\\n     * @param {String} args.mainPassword - The master password of the account. For validation (Accepts any printable ASCII character. Must be within 8-25 characters, and include numbers, lowercase and uppercase letters. Must not be the same as the user's email address). This field is required.\\n     * @param {String} args.mt5_account_category - [Optional] To choose whether account is conventional or swap_free. Unavailable for financial_stp MT5_account_type\\n     * @param {String} args.mt5_account_type - [Optional] Financial: Variable spreads, High leverage. Financial STP: Variable spreads, Medium Leverage, more products. If 'account_type' set to 'financial', setting 'mt5_account_type' is also required.\\n     * @param {Number} args.mt5_new_account - Must be `1`\\n     * @param {String} args.name - Client's name. The maximum length here is 101 characters.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.phone - [Optional] User's phone number.\\n     * @param {String} args.phonePassword - [Optional] The user's phone password.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Any} args.server - [Optional] Trade server.\\n     * @param {String} args.state - [Optional] User's state (region) of residence.\\n     * @param {String} args.zipCode - [Optional] User's zip code.\\n     */\\n\\n  }, {\\n    key: \\\"mt5NewAccount\\\",\\n    value: function mt5NewAccount() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        account_type: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        address: {\\n          type: 'string'\\n        },\\n        city: {\\n          type: 'string'\\n        },\\n        company: {\\n          type: 'string'\\n        },\\n        country: {\\n          type: 'string'\\n        },\\n        currency: {\\n          type: 'string'\\n        },\\n        dry_run: {\\n          type: 'numeric'\\n        },\\n        email: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        investPassword: {\\n          type: 'string'\\n        },\\n        leverage: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        mainPassword: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        mt5_account_category: {\\n          type: 'string'\\n        },\\n        mt5_account_type: {\\n          type: 'string'\\n        },\\n        mt5_new_account: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        name: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        phone: {\\n          type: 'string'\\n        },\\n        phonePassword: {\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        server: {},\\n        state: {\\n          type: 'string'\\n        },\\n        zipCode: {\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'mt5_new_account',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.login - MT5 user login\\n     * @param {Number} args.mt5_password_change - Must be `1`\\n     * @param {String} args.new_password - New password of the account. For validation (Accepts any printable ASCII character. Must be within 8-25 characters, and include numbers, lowercase and uppercase letters. Must not be the same as the user's email address).\\n     * @param {String} args.old_password - Old password for validation (non-empty string, accepts any printable ASCII character)\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.password_type - [Optional] Type of the password to change.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"mt5PasswordChange\\\",\\n    value: function mt5PasswordChange() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        login: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        mt5_password_change: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        new_password: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        old_password: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        password_type: {\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'mt5_password_change',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.login - MT5 user login\\n     * @param {Number} args.mt5_password_check - Must be `1`\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.password - The password of the account.\\n     * @param {String} args.password_type - [Optional] Type of the password to check.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"mt5PasswordCheck\\\",\\n    value: function mt5PasswordCheck() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        login: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        mt5_password_check: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        password: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        password_type: {\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'mt5_password_check',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.login - MT5 user login\\n     * @param {Number} args.mt5_password_reset - Must be `1`\\n     * @param {String} args.new_password - New password of the account. For validation (Accepts any printable ASCII character. Must be within 8-25 characters, and include numbers, lowercase and uppercase letters. Must not be the same as the user's email address).\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.password_type - [Optional] Type of the password to reset.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {String} args.verification_code - Email verification code (received from a `verify_email` call, which must be done first)\\n     */\\n\\n  }, {\\n    key: \\\"mt5PasswordReset\\\",\\n    value: function mt5PasswordReset() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        login: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        mt5_password_reset: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        new_password: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        password_type: {\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        verification_code: {\\n          required: 1,\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'mt5_password_reset',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.amount - Amount to withdraw (in the currency of the MT5 account); min = $1 or an equivalent amount, max = $20000 or an equivalent amount.\\n     * @param {String} args.from_mt5 - MT5 account login to withdraw money from\\n     * @param {Number} args.mt5_withdrawal - Must be `1`\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {String} args.to_binary - Binary account loginid to transfer money to\\n     */\\n\\n  }, {\\n    key: \\\"mt5Withdrawal\\\",\\n    value: function mt5Withdrawal() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        amount: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        from_mt5: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        mt5_withdrawal: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        to_binary: {\\n          required: 1,\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'mt5_withdrawal',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.accept_risk - Show whether client has accepted risk disclaimer.\\n     * @param {String} args.account_opening_reason - [Optional] Purpose and reason for requesting the account opening.\\n     * @param {String} args.account_turnover - [Optional] The anticipated account turnover.\\n     * @param {String} args.address_city - Within 100 characters\\n     * @param {String} args.address_line_1 - Within 70 characters, with no leading whitespaces and may contain letters/numbers and/or any of following characters '.,:;()@#/-\\n     * @param {String} args.address_line_2 - [Optional] Within 70 characters.\\n     * @param {String} args.address_postcode - [Optional] Within 20 characters and may not contain '+'.\\n     * @param {String} args.address_state - [Optional] Possible value receive from `states_list` call.\\n     * @param {String} args.affiliate_token - [Optional] Affiliate token, within 32 characters.\\n     * @param {String} args.binary_options_trading_experience - [Optional] Binary options trading experience.\\n     * @param {String} args.binary_options_trading_frequency - [Optional] Binary options trading frequency.\\n     * @param {String} args.cfd_trading_experience - [Optional] CFDs trading experience.\\n     * @param {String} args.cfd_trading_frequency - [Optional] CFDs trading frequency.\\n     * @param {String} args.citizen - [Optional] Country of legal citizenship, 2-letter country code. Possible value receive from `residence_list` call.\\n     * @param {String} args.client_type - [Optional] Indicates whether this is for a client requesting an account with professional status.\\n     * @param {String} args.date_of_birth - Date of birth format: yyyy-mm-dd.\\n     * @param {String} args.education_level - Level of Education\\n     * @param {String} args.employment_industry - Industry of Employment.\\n     * @param {String} args.employment_status - [Optional] Employment Status.\\n     * @param {String} args.estimated_worth - Estimated Net Worth.\\n     * @param {String} args.first_name - Within 2-50 characters, use only letters, spaces, hyphens, full-stops or apostrophes.\\n     * @param {String} args.forex_trading_experience - [Optional] Forex trading experience.\\n     * @param {String} args.forex_trading_frequency - [Optional] Forex trading frequency.\\n     * @param {String} args.income_source - Income Source.\\n     * @param {String} args.last_name - Within 2-50 characters, use only letters, spaces, hyphens, full-stops or apostrophes.\\n     * @param {String} args.net_income - Net Annual Income.\\n     * @param {Number} args.new_account_maltainvest - Must be `1`\\n     * @param {Number} args.non_pep_declaration - [Optional] Indicates client's self-declaration of not being a PEP/RCA.\\n     * @param {String} args.occupation - Occupation.\\n     * @param {String} args.other_instruments_trading_experience - [Optional] Trading experience in other financial instruments.\\n     * @param {String} args.other_instruments_trading_frequency - [Optional] Trading frequency in other financial instruments.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Any} args.phone - [Optional] Starting with `+` followed by 9-35 digits, hyphens or space.\\n     * @param {String} args.place_of_birth - [Optional] Place of birth, 2-letter country code.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {String} args.residence - 2-letter country code, possible value receive from `residence_list` call.\\n     * @param {String} args.salutation - Accept any value in enum list.\\n     * @param {String} args.secret_answer - [Optional] Answer to secret question, within 4-50 characters.\\n     * @param {String} args.secret_question - [Optional] Accept any value in enum list.\\n     * @param {String} args.source_of_wealth - [Optional] Source of wealth.\\n     * @param {String} args.tax_identification_number - Tax identification number. Only applicable for real money account. Required for `maltainvest` landing company.\\n     * @param {String} args.tax_residence - Residence for tax purpose. Comma separated iso country code if multiple jurisdictions. Only applicable for real money account. Required for `maltainvest` landing company.\\n     */\\n\\n  }, {\\n    key: \\\"newAccountMaltainvest\\\",\\n    value: function newAccountMaltainvest() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        accept_risk: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        account_opening_reason: {\\n          type: 'string'\\n        },\\n        account_turnover: {\\n          type: 'string'\\n        },\\n        address_city: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        address_line_1: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        address_line_2: {\\n          type: 'string'\\n        },\\n        address_postcode: {\\n          type: 'string'\\n        },\\n        address_state: {\\n          type: 'string'\\n        },\\n        affiliate_token: {\\n          type: 'string'\\n        },\\n        binary_options_trading_experience: {\\n          type: 'string'\\n        },\\n        binary_options_trading_frequency: {\\n          type: 'string'\\n        },\\n        cfd_trading_experience: {\\n          type: 'string'\\n        },\\n        cfd_trading_frequency: {\\n          type: 'string'\\n        },\\n        citizen: {\\n          type: 'string'\\n        },\\n        client_type: {\\n          type: 'string'\\n        },\\n        date_of_birth: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        education_level: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        employment_industry: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        employment_status: {\\n          type: 'string'\\n        },\\n        estimated_worth: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        first_name: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        forex_trading_experience: {\\n          type: 'string'\\n        },\\n        forex_trading_frequency: {\\n          type: 'string'\\n        },\\n        income_source: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        last_name: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        net_income: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        new_account_maltainvest: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        non_pep_declaration: {\\n          type: 'numeric'\\n        },\\n        occupation: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        other_instruments_trading_experience: {\\n          type: 'string'\\n        },\\n        other_instruments_trading_frequency: {\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        phone: {},\\n        place_of_birth: {\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        residence: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        salutation: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        secret_answer: {\\n          type: 'string'\\n        },\\n        secret_question: {\\n          type: 'string'\\n        },\\n        source_of_wealth: {\\n          type: 'string'\\n        },\\n        tax_identification_number: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        tax_residence: {\\n          required: 1,\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'new_account_maltainvest',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.account_opening_reason - [Optional] Purpose and reason for requesting the account opening.\\n     * @param {String} args.account_turnover - [Optional] The anticipated account turnover.\\n     * @param {String} args.address_city - [Optional] Within 100 characters.\\n     * @param {String} args.address_line_1 - Within 70 characters, with no leading whitespaces and may contain letters/numbers and/or any of following characters '.,:;()@#/-\\n     * @param {String} args.address_line_2 - [Optional] Within 70 characters.\\n     * @param {String} args.address_postcode - [Optional] Within 20 characters and may not contain '+'.\\n     * @param {String} args.address_state - [Optional] Possible value receive from `states_list` call.\\n     * @param {String} args.affiliate_token - [Optional] Affiliate token, within 32 characters.\\n     * @param {Any} args.citizen - [Optional] Country of legal citizenship, 2-letter country code.\\n     * @param {String} args.client_type - [Optional] Indicates whether this is for a client requesting an account with professional status.\\n     * @param {String} args.currency - [Optional] To set currency of the account. List of supported currencies can be acquired with `payout_currencies` call.\\n     * @param {String} args.date_of_birth - Date of birth format: `yyyy-mm-dd`.\\n     * @param {String} args.first_name - Within 2-50 characters, use only letters, spaces, hyphens, full-stops or apostrophes.\\n     * @param {String} args.last_name - Within 2-50 characters, use only letters, spaces, hyphens, full-stops or apostrophes.\\n     * @param {Number} args.new_account_real - Must be `1`\\n     * @param {Number} args.non_pep_declaration - [Optional] Indicates client's self-declaration of not being a PEP/RCA (Politically Exposed Person/Relatives and Close Associates).\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Any} args.phone - [Optional] Starting with `+` followed by 9-35 digits, hyphens or space.\\n     * @param {String} args.place_of_birth - [Optional] Place of birth, 2-letter country code.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {String} args.residence - 2-letter country code, possible value receive from `residence_list` call.\\n     * @param {String} args.salutation - [Optional] Accept any value in enum list.\\n     * @param {String} args.secret_answer - [Optional] Answer to secret question, within 4-50 characters. Required for new account and existing client details will be used if client open another account.\\n     * @param {String} args.secret_question - [Optional] Accept any value in enum list. Required for new account and existing client details will be used if client open another account.\\n     * @param {String} args.tax_identification_number - [Optional] Tax identification number. Only applicable for real money account. Required for `maltainvest` landing company.\\n     * @param {String} args.tax_residence - [Optional] Residence for tax purpose. Comma separated iso country code if multiple jurisdictions. Only applicable for real money account. Required for `maltainvest` landing company.\\n     */\\n\\n  }, {\\n    key: \\\"newAccountReal\\\",\\n    value: function newAccountReal() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        account_opening_reason: {\\n          type: 'string'\\n        },\\n        account_turnover: {\\n          type: 'string'\\n        },\\n        address_city: {\\n          type: 'string'\\n        },\\n        address_line_1: {\\n          type: 'string'\\n        },\\n        address_line_2: {\\n          type: 'string'\\n        },\\n        address_postcode: {\\n          type: 'string'\\n        },\\n        address_state: {\\n          type: 'string'\\n        },\\n        affiliate_token: {\\n          type: 'string'\\n        },\\n        citizen: {},\\n        client_type: {\\n          type: 'string'\\n        },\\n        currency: {\\n          type: 'string'\\n        },\\n        date_of_birth: {\\n          type: 'string'\\n        },\\n        first_name: {\\n          type: 'string'\\n        },\\n        last_name: {\\n          type: 'string'\\n        },\\n        new_account_real: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        non_pep_declaration: {\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        phone: {},\\n        place_of_birth: {\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        residence: {\\n          type: 'string'\\n        },\\n        salutation: {\\n          type: 'string'\\n        },\\n        secret_answer: {\\n          type: 'string'\\n        },\\n        secret_question: {\\n          type: 'string'\\n        },\\n        tax_identification_number: {\\n          type: 'string'\\n        },\\n        tax_residence: {\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'new_account_real',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.affiliate_token - [Optional] Affiliate token, within 32 characters.\\n     * @param {String} args.client_password - Password (Accepts any printable ASCII character. Must be within 8-25 characters, and include numbers, lowercase and uppercase letters. Must not be the same as the user's email address).\\n     * @param {String} args.date_first_contact - [Optional] Date of first contact, format: `yyyy-mm-dd` in GMT timezone.\\n     * @param {Number} args.email_consent - [Optional] Boolean value: 1 or 0, indicating whether the client has given consent for marketing emails.\\n     * @param {String} args.gclid_url - [Optional] Google Click Identifier to track source.\\n     * @param {Number} args.new_account_virtual - Must be `1`\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {String} args.residence - 2-letter country code (obtained from `residence_list` call).\\n     * @param {String} args.signup_device - [Optional] Show whether user has used mobile or desktop.\\n     * @param {String} args.type - Account type\\n     * @param {Any} args.utm_ad_id - [Optional] Identifier of particular ad. Value must match Regex pattern to be recorded\\n     * @param {Any} args.utm_adgroup_id - [Optional] Identifier of ad group in the campaign. Value must match Regex pattern to be recorded\\n     * @param {Any} args.utm_adrollclk_id - [Optional] Unique identifier of click on AdRoll ads platform. Value must match Regex pattern to be recorded\\n     * @param {Any} args.utm_campaign - [Optional] Identifies a specific product promotion or strategic campaign such as a spring sale or other promotions. Value must match Regex pattern to be recorded\\n     * @param {Any} args.utm_campaign_id - [Optional] Identifier of paid ad campaign. Value must match Regex pattern to be recorded\\n     * @param {Any} args.utm_content - [Optional] Used to differentiate similar content, or links within the same ad. Value must match Regex pattern to be recorded\\n     * @param {Any} args.utm_fbcl_id - [Optional] Unique identifier of click on Facebook ads platform. Value must match Regex pattern to be recorded\\n     * @param {Any} args.utm_gl_client_id - [Optional] Unique visitor identifier on Google Ads platform. Value must match Regex pattern to be recorded\\n     * @param {Any} args.utm_medium - [Optional] Identifies the medium the link was used upon such as: email, CPC, or other methods of sharing. Value must match Regex pattern to be recorded\\n     * @param {Any} args.utm_msclk_id - [Optional] Unique click identifier on Microsoft Bing ads platform. Value must match Regex pattern to be recorded\\n     * @param {Any} args.utm_source - [Optional] Identifies the source of traffic such as: search engine, newsletter, or other referral. Value must match Regex pattern to be recorded\\n     * @param {Any} args.utm_term - [Optional] Used to send information related to the campaign term like paid search keywords. Value must match Regex pattern to be recorded\\n     * @param {String} args.verification_code - Email verification code (received from a `verify_email` call, which must be done first).\\n     */\\n\\n  }, {\\n    key: \\\"newAccountVirtual\\\",\\n    value: function newAccountVirtual() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        affiliate_token: {\\n          type: 'string'\\n        },\\n        client_password: {\\n          type: 'string'\\n        },\\n        date_first_contact: {\\n          type: 'string'\\n        },\\n        email_consent: {\\n          type: 'numeric'\\n        },\\n        gclid_url: {\\n          type: 'string'\\n        },\\n        new_account_virtual: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        residence: {\\n          type: 'string'\\n        },\\n        signup_device: {\\n          type: 'string'\\n        },\\n        type: {\\n          type: 'string'\\n        },\\n        utm_ad_id: {},\\n        utm_adgroup_id: {},\\n        utm_adrollclk_id: {},\\n        utm_campaign: {},\\n        utm_campaign_id: {},\\n        utm_content: {},\\n        utm_fbcl_id: {},\\n        utm_gl_client_id: {},\\n        utm_medium: {},\\n        utm_msclk_id: {},\\n        utm_source: {},\\n        utm_term: {},\\n        verification_code: {\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'new_account_virtual',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.address_city - [Optional] Within 35 characters.\\n     * @param {String} args.address_line_1 - [Optional] Mailing address.\\n     * @param {String} args.address_line_2 - [Optional] Within 70 characters.\\n     * @param {String} args.address_postcode - [Optional] Within 20 characters and may not contain '+'.\\n     * @param {String} args.address_state - [Optional] Possible value receive from `states_list` call.\\n     * @param {String} args.currency - [Optional] To set currency of the account. List of supported currencies can be acquired with `payout_currencies` call.\\n     * @param {String} args.date_of_birth - [Optional] Date of birth format: `yyyy-mm-dd`.\\n     * @param {String} args.first_name - [Optional] Within 2-50 characters, use only letters, spaces, hyphens, full-stops or apostrophes.\\n     * @param {String} args.last_name - [Optional] Within 2-50 characters, use only letters, spaces, hyphens, full-stops or apostrophes.\\n     * @param {Number} args.new_account_wallet - Must be `1`\\n     * @param {Number} args.non_pep_declaration - [Optional] Indicates client's self-declaration of not being a PEP/RCA (Politically Exposed Person/Relatives and Close Associates).\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.payment_method - To set method which is used to transfer to/from wallet.\\n     * @param {String} args.phone - [Optional] Starting with `+` followed by 8-35 digits, allowing hyphens or space.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"newAccountWallet\\\",\\n    value: function newAccountWallet() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        address_city: {\\n          type: 'string'\\n        },\\n        address_line_1: {\\n          type: 'string'\\n        },\\n        address_line_2: {\\n          type: 'string'\\n        },\\n        address_postcode: {\\n          type: 'string'\\n        },\\n        address_state: {\\n          type: 'string'\\n        },\\n        currency: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        date_of_birth: {\\n          type: 'string'\\n        },\\n        first_name: {\\n          type: 'string'\\n        },\\n        last_name: {\\n          type: 'string'\\n        },\\n        new_account_wallet: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        non_pep_declaration: {\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        payment_method: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        phone: {\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'new_account_wallet',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.args -\\n     * @param {String} args.category - The category or nature of the event.\\n     * @param {String} args.event - The name of the event.\\n     * @param {Number} args.notification_event - Must be `1`\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"notificationEvent\\\",\\n    value: function notificationEvent() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        args: {\\n          documents: {}\\n        },\\n        category: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        event: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        notification_event: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'notification_event',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.oauth_apps - Must be `1`\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"oauthApps\\\",\\n    value: function oauthApps() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        oauth_apps: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'oauth_apps',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.amount - The total amount of the advert, in advertiser's account currency.\\n     * @param {String} args.contact_info - [Optional] Advertiser contact information. Only applicable for 'sell adverts'.\\n     * @param {String} args.description - [Optional] General information about the advert.\\n     * @param {String} args.local_currency - [Optional] Local currency for this advert. If not provided, will use the currency of client's residence by default.\\n     * @param {Number} args.max_order_amount - Maximum allowed amount for the orders of this advert, in advertiser's `account_currency`. Should be less than or equal to total `amount` of the advert.\\n     * @param {Number} args.min_order_amount - Minimum allowed amount for the orders of this advert, in advertiser's `account_currency`. Should be less than `max_order_amount`.\\n     * @param {Number} args.p2p_advert_create - Must be 1\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.payment_info - [Optional] Payment instructions. Only applicable for 'sell adverts'.\\n     * @param {String} args.payment_method - Supported payment methods. Separate multiple values with a comma, maximum 3.\\n     * @param {Any} args.payment_method_ids - IDs of payment methods, only applicable for sell ads.\\n     * @param {Number} args.rate - Conversion rate from advertiser's account currency to `local_currency`.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {String} args.type - Whether this is a buy or a sell.\\n     */\\n\\n  }, {\\n    key: \\\"p2pAdvertCreate\\\",\\n    value: function p2pAdvertCreate() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        amount: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        contact_info: {\\n          type: 'string'\\n        },\\n        description: {\\n          type: 'string'\\n        },\\n        local_currency: {\\n          type: 'string'\\n        },\\n        max_order_amount: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        min_order_amount: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        p2p_advert_create: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        payment_info: {\\n          type: 'string'\\n        },\\n        payment_method: {\\n          type: 'string'\\n        },\\n        payment_method_ids: {},\\n        rate: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        type: {\\n          required: 1,\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'p2p_advert_create',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.id - [Optional] The unique identifier for this advert. Optional when subscribe is 1. If not provided, all advertiser adverts will be subscribed.\\n     * @param {Number} args.p2p_advert_info - Must be 1\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.subscribe - [Optional] If set to 1, will send updates when changes occur. Optional when id is provided.\\n     * @param {Number} args.use_client_limits - [Optional] If set to 1, the maximum order amount will be adjusted to the current balance and turnover limits of the account.\\n     */\\n\\n  }, {\\n    key: \\\"p2pAdvertInfo\\\",\\n    value: function p2pAdvertInfo() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        id: {\\n          type: 'string'\\n        },\\n        p2p_advert_info: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        subscribe: {\\n          type: 'numeric'\\n        },\\n        use_client_limits: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'p2p_advert_info',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.advertiser_id - [Optional] ID of the advertiser to list adverts for.\\n     * @param {String} args.advertiser_name - [Optional] Search for advertiser by name. Partial matches will be returned.\\n     * @param {Number} args.amount - [Optional] How much to buy or sell, used to calculate prices.\\n     * @param {String} args.counterparty_type - [Optional] Filter the adverts by `counterparty_type`.\\n     * @param {Number} args.favourites_only - [Optional] Only show adverts from favourite advertisers. Default is 0.\\n     * @param {Number} args.limit - [Optional] Used for paging.\\n     * @param {String} args.local_currency - [Optional] Currency to conduct payment transaction in, defaults to the main currency for the client's country.\\n     * @param {Number} args.offset - [Optional] Used for paging.\\n     * @param {Number} args.p2p_advert_list - Must be 1\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Any} args.payment_method - [Optional] Search by supported payment methods.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {String} args.sort_by - [Optional] How the results are sorted: best rate, or advertiser completion rate.\\n     * @param {Number} args.use_client_limits - [Optional] If set to 1, ads that exceed this account's balance or turnover limits will not be shown.\\n     */\\n\\n  }, {\\n    key: \\\"p2pAdvertList\\\",\\n    value: function p2pAdvertList() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        advertiser_id: {\\n          type: 'string'\\n        },\\n        advertiser_name: {\\n          type: 'string'\\n        },\\n        amount: {\\n          type: 'numeric'\\n        },\\n        counterparty_type: {\\n          type: 'string'\\n        },\\n        favourites_only: {\\n          type: 'numeric'\\n        },\\n        limit: {\\n          type: 'numeric'\\n        },\\n        local_currency: {\\n          type: 'string'\\n        },\\n        offset: {\\n          type: 'numeric'\\n        },\\n        p2p_advert_list: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        payment_method: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        sort_by: {\\n          type: 'string'\\n        },\\n        use_client_limits: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'p2p_advert_list',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.delete - [Optional] If set to 1, permanently deletes the advert.\\n     * @param {String} args.id - The unique identifier for this advert.\\n     * @param {Number} args.is_active - [Optional] Activate or deactivate the advert.\\n     * @param {Number} args.p2p_advert_update - Must be 1\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.payment_method - [Optional] Supported payment methods. Separate multiple values with a comma, maximum 3.\\n     * @param {Any} args.payment_method_ids - [Optional] IDs of payment methods, only applicable for sell ads. Will replace exisiting methods.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"p2pAdvertUpdate\\\",\\n    value: function p2pAdvertUpdate() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        \\\"delete\\\": {\\n          type: 'numeric'\\n        },\\n        id: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        is_active: {\\n          type: 'numeric'\\n        },\\n        p2p_advert_update: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        payment_method: {\\n          type: 'string'\\n        },\\n        payment_method_ids: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'p2p_advert_update',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.limit - [Optional] Used for paging. This value will also apply to subsription responses.\\n     * @param {Number} args.offset - [Optional] Used for paging. This value will also apply to subsription responses.\\n     * @param {Number} args.p2p_advertiser_adverts - Must be 1\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"p2pAdvertiserAdverts\\\",\\n    value: function p2pAdvertiserAdverts() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        limit: {\\n          type: 'numeric'\\n        },\\n        offset: {\\n          type: 'numeric'\\n        },\\n        p2p_advertiser_adverts: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'p2p_advertiser_adverts',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.contact_info - [Optional] Advertiser's contact information, to be used as a default for new sell adverts.\\n     * @param {String} args.default_advert_description - [Optional] Default description that can be used every time an advert is created.\\n     * @param {String} args.name - The advertiser's displayed name.\\n     * @param {Number} args.p2p_advertiser_create - Must be 1\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.payment_info - [Optional] Advertiser's payment information, to be used as a default for new sell adverts.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.subscribe - [Optional] If set to 1, will send updates whenever there is an update to advertiser\\n     */\\n\\n  }, {\\n    key: \\\"p2pAdvertiserCreate\\\",\\n    value: function p2pAdvertiserCreate() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        contact_info: {\\n          type: 'string'\\n        },\\n        default_advert_description: {\\n          type: 'string'\\n        },\\n        name: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        p2p_advertiser_create: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        payment_info: {\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        subscribe: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'p2p_advertiser_create',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.id - [Optional] The unique identifier for this advertiser. If not provided, returns advertiser information about the current account.\\n     * @param {Number} args.p2p_advertiser_info - Must be 1\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.subscribe - [Optional] If set to 1, will send updates whenever there is an update to advertiser\\n     */\\n\\n  }, {\\n    key: \\\"p2pAdvertiserInfo\\\",\\n    value: function p2pAdvertiserInfo() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        id: {\\n          type: 'string'\\n        },\\n        p2p_advertiser_info: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        subscribe: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'p2p_advertiser_info',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.create - Contains new payment method entries.\\n     * @param {Any} args.delete - Contains payment methods to delete.\\n     * @param {Number} args.p2p_advertiser_payment_methods - Must be 1\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Any} args.update - Contains payment methods to update.\\n     */\\n\\n  }, {\\n    key: \\\"p2pAdvertiserPaymentMethods\\\",\\n    value: function p2pAdvertiserPaymentMethods() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        create: {},\\n        \\\"delete\\\": {},\\n        p2p_advertiser_payment_methods: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        update: {}\\n      };\\n      var allArgs = {\\n        method: 'p2p_advertiser_payment_methods',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.add_blocked - IDs of advertisers to block.\\n     * @param {Any} args.add_favourites - IDs of advertisers to add as favourites.\\n     * @param {Number} args.p2p_advertiser_relations - Must be 1\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Any} args.remove_blocked - IDs of advertisers to remove from blocked.\\n     * @param {Any} args.remove_favourites - IDs of advertisers to remove from favourites.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"p2pAdvertiserRelations\\\",\\n    value: function p2pAdvertiserRelations() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        add_blocked: {},\\n        add_favourites: {},\\n        p2p_advertiser_relations: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        remove_blocked: {},\\n        remove_favourites: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'p2p_advertiser_relations',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.contact_info - [Optional] Advertiser's contact information, to be used as a default for new sell adverts.\\n     * @param {String} args.default_advert_description - [Optional] Default description that can be used every time an advert is created.\\n     * @param {Number} args.is_listed - [Optional] Used to set if the advertiser's adverts could be listed. When `0`, adverts won't be listed regardless of they are active or not. This doesn't change the `is_active` of each individual advert.\\n     * @param {Number} args.p2p_advertiser_update - Must be 1\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.payment_info - [Optional] Advertiser's payment information, to be used as a default for new sell adverts.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.show_name - [Optional] When `1`, the advertiser's real name will be displayed on to other users on adverts and orders.\\n     */\\n\\n  }, {\\n    key: \\\"p2pAdvertiserUpdate\\\",\\n    value: function p2pAdvertiserUpdate() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        contact_info: {\\n          type: 'string'\\n        },\\n        default_advert_description: {\\n          type: 'string'\\n        },\\n        is_listed: {\\n          type: 'numeric'\\n        },\\n        p2p_advertiser_update: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        payment_info: {\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        show_name: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'p2p_advertiser_update',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.order_id - The unique identifier for the order to create the chat for.\\n     * @param {Number} args.p2p_chat_create - Must be 1\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"p2pChatCreate\\\",\\n    value: function p2pChatCreate() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        order_id: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        p2p_chat_create: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'p2p_chat_create',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.id - The unique identifier for this order.\\n     * @param {Number} args.p2p_order_cancel - Must be 1\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"p2pOrderCancel\\\",\\n    value: function p2pOrderCancel() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        id: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        p2p_order_cancel: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'p2p_order_cancel',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.id - The unique identifier for this order.\\n     * @param {Number} args.p2p_order_confirm - Must be 1\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"p2pOrderConfirm\\\",\\n    value: function p2pOrderConfirm() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        id: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        p2p_order_confirm: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'p2p_order_confirm',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.advert_id - The unique identifier for the advert to create an order against.\\n     * @param {Number} args.amount - The amount of currency to be bought or sold.\\n     * @param {String} args.contact_info - [Optional] Seller contact information. Only applicable for 'sell orders'.\\n     * @param {Number} args.p2p_order_create - Must be 1\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.payment_info - [Optional] Payment instructions, only applicable for sell orders.\\n     * @param {Any} args.payment_method_ids - IDs of payment methods, only applicable for sell orders.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.subscribe - [Optional] If set to 1, will send updates whenever there is an update to the order.\\n     */\\n\\n  }, {\\n    key: \\\"p2pOrderCreate\\\",\\n    value: function p2pOrderCreate() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        advert_id: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        amount: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        contact_info: {\\n          type: 'string'\\n        },\\n        p2p_order_create: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        payment_info: {\\n          type: 'string'\\n        },\\n        payment_method_ids: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        subscribe: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'p2p_order_create',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.dispute_reason - The predefined dispute reason\\n     * @param {String} args.id - The unique identifier for this order.\\n     * @param {Number} args.p2p_order_dispute - Must be 1\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"p2pOrderDispute\\\",\\n    value: function p2pOrderDispute() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        dispute_reason: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        id: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        p2p_order_dispute: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'p2p_order_dispute',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.id - The unique identifier for the order.\\n     * @param {Number} args.p2p_order_info - Must be 1\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.subscribe - [Optional] If set to 1, will send updates whenever there is an update to order\\n     */\\n\\n  }, {\\n    key: \\\"p2pOrderInfo\\\",\\n    value: function p2pOrderInfo() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        id: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        p2p_order_info: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        subscribe: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'p2p_order_info',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.active - [Optional] Should be 1 to list active, 0 to list inactive (historical).\\n     * @param {String} args.advert_id - [Optional] If present, lists orders applying to a specific advert.\\n     * @param {Number} args.limit - [Optional] Used for paging.\\n     * @param {Number} args.offset - [Optional] Used for paging.\\n     * @param {Number} args.p2p_order_list - Must be 1\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.subscribe - [Optional] If set to 1, will send updates whenever there is a change to any order belonging to you.\\n     */\\n\\n  }, {\\n    key: \\\"p2pOrderList\\\",\\n    value: function p2pOrderList() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        active: {\\n          type: 'numeric'\\n        },\\n        advert_id: {\\n          type: 'string'\\n        },\\n        limit: {\\n          type: 'numeric'\\n        },\\n        offset: {\\n          type: 'numeric'\\n        },\\n        p2p_order_list: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        subscribe: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'p2p_order_list',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.p2p_payment_methods - Must be 1\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"p2pPaymentMethods\\\",\\n    value: function p2pPaymentMethods() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        p2p_payment_methods: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'p2p_payment_methods',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.country - [Optional] 2-letter country code (ISO standard).\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.payment_methods - Must be `1`\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"paymentMethods\\\",\\n    value: function paymentMethods() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        country: {\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        payment_methods: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'payment_methods',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.affiliate_id - [Optional] Client's My Affiliate id, if exists.\\n     * @param {Number} args.code_of_conduct_approval - Indicates client's agreement with the Code of Conduct.\\n     * @param {Number} args.commission_deposit - Commission  (%) the agent wants to take on deposits\\n     * @param {Number} args.commission_withdrawal - Commission  (%) the agent wants to take on withdrawals\\n     * @param {String} args.email - Payment agent's email address.\\n     * @param {String} args.information - [Optional] Information about payment agent and their proposed service.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.payment_agent_name - The name with which the payment agent is going to be identified.\\n     * @param {Number} args.paymentagent_create - Must be 1\\n     * @param {String} args.phone - Payment agent's phone number with coutry code.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Any} args.supported_payment_methods - A list of supported payment methods.\\n     * @param {String} args.url - The URL of payment agent's website.\\n     */\\n\\n  }, {\\n    key: \\\"paymentagentCreate\\\",\\n    value: function paymentagentCreate() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        affiliate_id: {\\n          type: 'string'\\n        },\\n        code_of_conduct_approval: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        commission_deposit: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        commission_withdrawal: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        email: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        information: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        payment_agent_name: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        paymentagent_create: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        phone: {\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        supported_payment_methods: {\\n          required: 1\\n        },\\n        url: {\\n          required: 1,\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'paymentagent_create',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.paymentagent_details - Must be 1\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"paymentagentDetails\\\",\\n    value: function paymentagentDetails() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        passthrough: {},\\n        paymentagent_details: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'paymentagent_details',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.currency - [Optional] If specified, only payment agents that supports that currency will be returned (obtained from `payout_currencies` call).\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.paymentagent_list - Client's 2-letter country code (obtained from `residence_list` call).\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"paymentagentList\\\",\\n    value: function paymentagentList() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        currency: {\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        paymentagent_list: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'paymentagent_list',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.amount - The amount to transfer.\\n     * @param {String} args.currency - Currency code.\\n     * @param {String} args.description - [Optional] Remarks about the transfer.\\n     * @param {Number} args.dry_run - [Optional] If set to `1`, just do validation.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.paymentagent_transfer - Must be `1`\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {String} args.transfer_to - The loginid of the recipient account.\\n     */\\n\\n  }, {\\n    key: \\\"paymentagentTransfer\\\",\\n    value: function paymentagentTransfer() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        amount: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        currency: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        description: {\\n          type: 'string'\\n        },\\n        dry_run: {\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        paymentagent_transfer: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        transfer_to: {\\n          required: 1,\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'paymentagent_transfer',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.amount - The amount to withdraw to the payment agent.\\n     * @param {String} args.currency - The currency code.\\n     * @param {String} args.description - [Optional] Remarks about the withdraw. Only letters, numbers, space, period, comma, - ' are allowed.\\n     * @param {Number} args.dry_run - [Optional] If set to 1, just do validation.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.paymentagent_loginid - The payment agent loginid received from the `paymentagent_list` call.\\n     * @param {Number} args.paymentagent_withdraw - Must be `1`\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {String} args.verification_code - Email verification code (received from a `verify_email` call, which must be done first)\\n     */\\n\\n  }, {\\n    key: \\\"paymentagentWithdraw\\\",\\n    value: function paymentagentWithdraw() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        amount: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        currency: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        description: {\\n          type: 'string'\\n        },\\n        dry_run: {\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        paymentagent_loginid: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        paymentagent_withdraw: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        verification_code: {\\n          required: 1,\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'paymentagent_withdraw',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.payout_currencies - Must be `1`\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"payoutCurrencies\\\",\\n    value: function payoutCurrencies() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        passthrough: {},\\n        payout_currencies: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'payout_currencies',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.ping - Must be `1`\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"ping\\\",\\n    value: function ping() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        passthrough: {},\\n        ping: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'ping',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.contract_type - Return only contracts of the specified types\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.portfolio - Must be `1`\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"portfolio\\\",\\n    value: function portfolio() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        contract_type: {},\\n        passthrough: {},\\n        portfolio: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'portfolio',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.contract_type - Return only contracts of the specified types\\n     * @param {String} args.date_from - [Optional] Start date (epoch or YYYY-MM-DD)\\n     * @param {String} args.date_to - [Optional] End date (epoch or YYYY-MM-DD)\\n     * @param {Number} args.description - [Optional] If set to 1, will return full contracts description.\\n     * @param {Number} args.limit - [Optional] Apply upper limit to count of transactions received.\\n     * @param {Number} args.offset - [Optional] Number of transactions to skip.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.profit_table - Must be `1`\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {String} args.sort - [Optional] Sort direction.\\n     */\\n\\n  }, {\\n    key: \\\"profitTable\\\",\\n    value: function profitTable() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        contract_type: {},\\n        date_from: {\\n          type: 'string'\\n        },\\n        date_to: {\\n          type: 'string'\\n        },\\n        description: {\\n          type: 'numeric'\\n        },\\n        limit: {\\n          type: 'numeric'\\n        },\\n        offset: {\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        profit_table: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        sort: {\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'profit_table',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.amount - [Optional] Proposed contract payout or stake, or multiplier (for lookbacks).\\n     * @param {String} args.barrier - [Optional] Barrier for the contract (or last digit prediction for digit contracts). Contracts less than 24 hours in duration would need a relative barrier (barriers which need +/-), where entry spot would be adjusted accordingly with that amount to define a barrier, except for Synthetic Indices as they support both relative and absolute barriers. Not needed for lookbacks.\\n     * @param {String} args.barrier2 - [Optional] Low barrier for the contract (for contracts with two barriers). Contracts less than 24 hours in duration would need a relative barrier (barriers which need +/-), where entry spot would be adjusted accordingly with that amount to define a barrier, except for Synthetic Indices as they support both relative and absolute barriers. Not needed for lookbacks.\\n     * @param {String} args.basis - [Optional] Indicates type of the `amount`.\\n     * @param {String} args.cancellation - Cancellation duration option (only for `MULTUP` and `MULTDOWN` contracts).\\n     * @param {String} args.contract_type - The proposed contract type\\n     * @param {String} args.currency - This can only be the account-holder's currency (obtained from `payout_currencies` call).\\n     * @param {Number} args.date_expiry - [Optional] Epoch value of the expiry time of the contract. Either date_expiry or duration is required.\\n     * @param {Number} args.date_start - [Optional] Indicates epoch value of the starting time of the contract. If left empty, the start time of the contract is now.\\n     * @param {Number} args.duration - [Optional] Duration quantity. Either date_expiry or duration is required.\\n     * @param {String} args.duration_unit - [Optional] Duration unit - `s`: seconds, `m`: minutes, `h`: hours, `d`: days, `t`: ticks.\\n     * @param {Any} args.limit_order -\\n     * @param {Number} args.multiplier - [Optional] The multiplier for non-binary options. E.g. lookbacks.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.product_type - [Optional] The product type.\\n     * @param {Number} args.proposal - Must be `1`\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.selected_tick - [Optional] The tick that is predicted to have the highest/lowest value - for `TICKHIGH` and `TICKLOW` contracts.\\n     * @param {Number} args.subscribe - [Optional] 1 - to initiate a realtime stream of prices. Note that tick trades (without a user-defined barrier), digit trades and less than 24 hours at-the-money contracts for the following underlying symbols are not streamed: `R_10`, `R_25`, `R_50`, `R_75`, `R_100`, `RDBULL`, `RDBEAR` (this is because their price is constant).\\n     * @param {String} args.symbol - The short symbol name (obtained from `active_symbols` call).\\n     * @param {Number} args.trading_period_start - [Optional] Required only for multi-barrier trading. Defines the epoch value of the trading period start time.\\n     */\\n\\n  }, {\\n    key: \\\"proposal\\\",\\n    value: function proposal() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        amount: {\\n          type: 'numeric'\\n        },\\n        barrier: {\\n          type: 'string'\\n        },\\n        barrier2: {\\n          type: 'string'\\n        },\\n        basis: {\\n          type: 'string'\\n        },\\n        cancellation: {\\n          type: 'string'\\n        },\\n        contract_type: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        currency: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        date_expiry: {\\n          type: 'numeric'\\n        },\\n        date_start: {\\n          type: 'numeric'\\n        },\\n        duration: {\\n          type: 'numeric'\\n        },\\n        duration_unit: {\\n          type: 'string'\\n        },\\n        limit_order: {\\n          stop_loss: {\\n            type: 'numeric'\\n          },\\n          take_profit: {\\n            type: 'numeric'\\n          }\\n        },\\n        multiplier: {\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        product_type: {\\n          type: 'string'\\n        },\\n        proposal: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        selected_tick: {\\n          type: 'numeric'\\n        },\\n        subscribe: {\\n          type: 'numeric'\\n        },\\n        symbol: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        trading_period_start: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'proposal',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.contract_id - [Optional] Contract ID received from a `portfolio` request. If not set, you will receive stream of all open contracts.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.proposal_open_contract - Must be `1`\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.subscribe - [Optional] `1` to stream.\\n     */\\n\\n  }, {\\n    key: \\\"proposalOpenContract\\\",\\n    value: function proposalOpenContract() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        contract_id: {\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        proposal_open_contract: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        subscribe: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'proposal_open_contract',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.reality_check - Must be `1`\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     */\\n\\n  }, {\\n    key: \\\"realityCheck\\\",\\n    value: function realityCheck() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        passthrough: {},\\n        reality_check: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'reality_check',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.date_from - Start date of the report\\n     * @param {Number} args.date_to - End date of the report\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.report_type - Type of report to be sent to client's registered e-mail address\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.request_report - Must be `1`\\n     */\\n\\n  }, {\\n    key: \\\"requestReport\\\",\\n    value: function requestReport() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        date_from: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        date_to: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        report_type: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        request_report: {\\n          required: 1,\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'request_report',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.date_of_birth - [Optional] Date of birth format: `yyyy-mm-dd`. Only required for clients with real-money accounts.\\n     * @param {String} args.new_password - New password. For validation (Accepts any printable ASCII character. Must be within 8-25 characters, and include numbers, lowercase and uppercase letters. Must not be the same as the user's email address).\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.reset_password - Must be `1`\\n     * @param {String} args.verification_code - Email verification code (received from a `verify_email` call, which must be done first)\\n     */\\n\\n  }, {\\n    key: \\\"resetPassword\\\",\\n    value: function resetPassword() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        date_of_birth: {\\n          type: 'string'\\n        },\\n        new_password: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        reset_password: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        verification_code: {\\n          required: 1,\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'reset_password',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.residence_list - Must be `1`\\n     */\\n\\n  }, {\\n    key: \\\"residenceList\\\",\\n    value: function residenceList() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        residence_list: {\\n          required: 1,\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'residence_list',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.revoke_oauth_app - The application ID to revoke.\\n     */\\n\\n  }, {\\n    key: \\\"revokeOauthApp\\\",\\n    value: function revokeOauthApp() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        revoke_oauth_app: {\\n          required: 1,\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'revoke_oauth_app',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.price - Minimum price at which to sell the contract, or `0` for 'sell at market'.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.sell - Pass contract_id received from the `portfolio` call.\\n     */\\n\\n  }, {\\n    key: \\\"sell\\\",\\n    value: function sell() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        passthrough: {},\\n        price: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        sell: {\\n          required: 1,\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'sell',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.price - Minimum price at which to sell the contract, or `0` for 'sell at market'.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.sell_contract_for_multiple_accounts - Must be `1`\\n     * @param {String} args.shortcode - An internal ID used to identify the contract which was originally bought. This is returned from the `buy` and `buy_contract_for_multiple_accounts` calls.\\n     * @param {Any} args.tokens - Authorisation tokens which select the accounts to sell use for the affected accounts.\\n     */\\n\\n  }, {\\n    key: \\\"sellContractForMultipleAccounts\\\",\\n    value: function sellContractForMultipleAccounts() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        passthrough: {},\\n        price: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        sell_contract_for_multiple_accounts: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        shortcode: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        tokens: {\\n          required: 1\\n        }\\n      };\\n      var allArgs = {\\n        method: 'sell_contract_for_multiple_accounts',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.sell_expired - Must be `1`\\n     */\\n\\n  }, {\\n    key: \\\"sellExpired\\\",\\n    value: function sellExpired() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        sell_expired: {\\n          required: 1,\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'sell_expired',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.country - [Optional] The 2-letter country code.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.referrer - [Optional] The URL of the web page where the Web SDK will be used.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {String} args.server - Server (dxtrade only).\\n     * @param {Any} args.service - The service(s) to retrieve token(s) for.\\n     * @param {Number} args.service_token - Must be `1`\\n     */\\n\\n  }, {\\n    key: \\\"serviceToken\\\",\\n    value: function serviceToken() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        country: {\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        referrer: {\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        server: {\\n          type: 'string'\\n        },\\n        service: {\\n          required: 1\\n        },\\n        service_token: {\\n          required: 1,\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'service_token',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {String} args.set_account_currency - Currency of the account. List of supported currencies can be acquired with `payout_currencies` call.\\n     */\\n\\n  }, {\\n    key: \\\"setAccountCurrency\\\",\\n    value: function setAccountCurrency() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        set_account_currency: {\\n          required: 1,\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'set_account_currency',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.account_turnover - [Optional] The anticipated account turnover.\\n     * @param {String} args.binary_options_trading_experience - [Optional] Binary options trading experience.\\n     * @param {String} args.binary_options_trading_frequency - [Optional] Binary options trading frequency.\\n     * @param {String} args.cfd_trading_experience - [Optional] CFDs trading experience.\\n     * @param {String} args.cfd_trading_frequency - [Optional] CFDs trading frequency.\\n     * @param {String} args.education_level - Level of Education.\\n     * @param {String} args.employment_industry - Industry of Employment.\\n     * @param {String} args.employment_status - [Optional] Employment Status.\\n     * @param {String} args.estimated_worth - Estimated Net Worth.\\n     * @param {String} args.forex_trading_experience - [Optional] Forex trading experience.\\n     * @param {String} args.forex_trading_frequency - [Optional] Forex trading frequency.\\n     * @param {String} args.income_source - Income Source.\\n     * @param {String} args.net_income - Net Annual Income.\\n     * @param {String} args.occupation - Occupation.\\n     * @param {String} args.other_instruments_trading_experience - [Optional] Trading experience in other financial instruments.\\n     * @param {String} args.other_instruments_trading_frequency - [Optional] Trading frequency in other financial instruments.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.set_financial_assessment - Must be `1`\\n     * @param {String} args.source_of_wealth - [Optional] Source of wealth.\\n     */\\n\\n  }, {\\n    key: \\\"setFinancialAssessment\\\",\\n    value: function setFinancialAssessment() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        account_turnover: {\\n          type: 'string'\\n        },\\n        binary_options_trading_experience: {\\n          type: 'string'\\n        },\\n        binary_options_trading_frequency: {\\n          type: 'string'\\n        },\\n        cfd_trading_experience: {\\n          type: 'string'\\n        },\\n        cfd_trading_frequency: {\\n          type: 'string'\\n        },\\n        education_level: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        employment_industry: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        employment_status: {\\n          type: 'string'\\n        },\\n        estimated_worth: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        forex_trading_experience: {\\n          type: 'string'\\n        },\\n        forex_trading_frequency: {\\n          type: 'string'\\n        },\\n        income_source: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        net_income: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        occupation: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        other_instruments_trading_experience: {\\n          type: 'string'\\n        },\\n        other_instruments_trading_frequency: {\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        set_financial_assessment: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        source_of_wealth: {\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'set_financial_assessment',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.exclude_until - [Optional] Exclude me from the website (for a minimum of 6 months, up to a maximum of 5 years). Note: uplifting this self-exclusion may require contacting the company.\\n     * @param {Any} args.max_30day_deposit - [Optional] 7-day limit on deposits.\\n     * @param {Any} args.max_30day_losses - [Optional] 30-day limit on losses.\\n     * @param {Any} args.max_30day_turnover - [Optional] 30-day turnover limit.\\n     * @param {Any} args.max_7day_deposit - [Optional] 7-day limit on deposits.\\n     * @param {Any} args.max_7day_losses - [Optional] 7-day limit on losses.\\n     * @param {Any} args.max_7day_turnover - [Optional] 7-day turnover limit.\\n     * @param {Any} args.max_balance - [Optional] Maximum account cash balance.\\n     * @param {Any} args.max_deposit - [Optional] Daily deposit limit.\\n     * @param {Any} args.max_losses - [Optional] Daily limit on losses.\\n     * @param {Any} args.max_open_bets - [Optional] Maximum number of open positions.\\n     * @param {Any} args.max_turnover - [Optional] Daily turnover limit.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Any} args.session_duration_limit - [Optional] Session duration limit, in minutes.\\n     * @param {Number} args.set_self_exclusion - Must be `1`\\n     * @param {Any} args.timeout_until - [Optional] Exclude me from the website (for up to 6 weeks). Requires time in epoch format. Note: unlike `exclude_until`, this self-exclusion will be lifted automatically at the expiry of the timeout period.\\n     */\\n\\n  }, {\\n    key: \\\"setSelfExclusion\\\",\\n    value: function setSelfExclusion() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        exclude_until: {},\\n        max_30day_deposit: {},\\n        max_30day_losses: {},\\n        max_30day_turnover: {},\\n        max_7day_deposit: {},\\n        max_7day_losses: {},\\n        max_7day_turnover: {},\\n        max_balance: {},\\n        max_deposit: {},\\n        max_losses: {},\\n        max_open_bets: {},\\n        max_turnover: {},\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        session_duration_limit: {},\\n        set_self_exclusion: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        timeout_until: {}\\n      };\\n      var allArgs = {\\n        method: 'set_self_exclusion',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.account_opening_reason - [Optional] Purpose and reason for requesting the account opening. Only applicable for real money account. Required for clients that have not set it yet. Can only be set once.\\n     * @param {String} args.address_city - [Optional] Note: not applicable for virtual account. Required field for real money account.\\n     * @param {String} args.address_line_1 - [Optional] Note: not applicable for virtual account. Required field for real money account.\\n     * @param {Any} args.address_line_2 - [Optional] Note: not applicable for virtual account. Optional field for real money account.\\n     * @param {String} args.address_postcode - [Optional] Note: not applicable for virtual account. Optional field for real money account.\\n     * @param {String} args.address_state - [Optional] Note: not applicable for virtual account. Optional field for real money account.\\n     * @param {Number} args.allow_copiers - [Optional] Boolean value 1 or 0, indicating permission to allow others to follow your trades. Note: not applicable for Virtual account. Only allow for real money account.\\n     * @param {Any} args.citizen - [Optional] Country of legal citizenship, 2-letter country code.\\n     * @param {String} args.date_of_birth - [Optional] Date of birth format: yyyy-mm-dd (can only be changed on unauthenticated svg accounts).\\n     * @param {Number} args.email_consent - [Optional] Boolean value 1 or 0, indicating permission to use email address for any contact which may include marketing\\n     * @param {Any} args.feature_flag -\\n     * @param {String} args.first_name - [Optional] Within 2-50 characters, use only letters, spaces, hyphens, full-stops or apostrophes (can only be changed on unauthenticated svg accounts).\\n     * @param {String} args.last_name - [Optional] Within 2-50 characters, use only letters, spaces, hyphens, full-stops or apostrophes (can only be changed on unauthenticated svg accounts).\\n     * @param {Number} args.non_pep_declaration - [Optional] Indicates client's self-declaration of not being a PEP/RCA (Politically Exposed Person/Relatives and Close Associates). Effective for real accounts only.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Any} args.phone - [Optional] Note: not applicable for virtual account. Starting with `+` followed by 9-35 digits, hyphens or space.\\n     * @param {String} args.place_of_birth - [Optional] Place of birth, 2-letter country code.\\n     * @param {Any} args.preferred_language - [Optional] User's preferred language, ISO standard language code\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.request_professional_status - [Optional] Required when client wants to be treated as professional. Applicable for financial accounts only.\\n     * @param {Any} args.residence - [Optional] 2-letter country code. Note: not applicable for real money account. Only allow for Virtual account without residence set.\\n     * @param {String} args.salutation - [Optional] Accept any value in enum list (can only be changed on unauthenticated svg accounts).\\n     * @param {String} args.secret_answer - [Optional] Answer to secret question, within 4-50 characters. Required for new account and existing client details will be used if client opens another account.\\n     * @param {String} args.secret_question - [Optional] Accept any value in enum list. Required for new account and existing client details will be used if client opens another account.\\n     * @param {Number} args.set_settings - Must be `1`\\n     * @param {String} args.tax_identification_number - [Optional] Tax identification number. Only applicable for real money account. Required for maltainvest landing company.\\n     * @param {String} args.tax_residence - [Optional] Residence for tax purpose. Comma separated iso country code if multiple jurisdictions. Only applicable for real money account. Required for maltainvest landing company.\\n     */\\n\\n  }, {\\n    key: \\\"setSettings\\\",\\n    value: function setSettings() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        account_opening_reason: {\\n          type: 'string'\\n        },\\n        address_city: {\\n          type: 'string'\\n        },\\n        address_line_1: {\\n          type: 'string'\\n        },\\n        address_line_2: {},\\n        address_postcode: {\\n          type: 'string'\\n        },\\n        address_state: {\\n          type: 'string'\\n        },\\n        allow_copiers: {\\n          type: 'numeric'\\n        },\\n        citizen: {},\\n        date_of_birth: {\\n          type: 'string'\\n        },\\n        email_consent: {\\n          type: 'numeric'\\n        },\\n        feature_flag: {\\n          wallet: {\\n            type: 'numeric'\\n          }\\n        },\\n        first_name: {\\n          type: 'string'\\n        },\\n        last_name: {\\n          type: 'string'\\n        },\\n        non_pep_declaration: {\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        phone: {},\\n        place_of_birth: {\\n          type: 'string'\\n        },\\n        preferred_language: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        request_professional_status: {\\n          type: 'numeric'\\n        },\\n        residence: {},\\n        salutation: {\\n          type: 'string'\\n        },\\n        secret_answer: {\\n          type: 'string'\\n        },\\n        secret_question: {\\n          type: 'string'\\n        },\\n        set_settings: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        tax_identification_number: {\\n          type: 'string'\\n        },\\n        tax_residence: {\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'set_settings',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.action_type - [Optional] To filter the statement according to the type of transaction.\\n     * @param {Number} args.date_from - [Optional] Start date (epoch)\\n     * @param {Number} args.date_to - [Optional] End date (epoch)\\n     * @param {Number} args.description - [Optional] If set to 1, will return full contracts description.\\n     * @param {Number} args.limit - [Optional] Maximum number of transactions to receive.\\n     * @param {Number} args.offset - [Optional] Number of transactions to skip.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.statement - Must be `1`\\n     */\\n\\n  }, {\\n    key: \\\"statement\\\",\\n    value: function statement() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        action_type: {\\n          type: 'string'\\n        },\\n        date_from: {\\n          type: 'numeric'\\n        },\\n        date_to: {\\n          type: 'numeric'\\n        },\\n        description: {\\n          type: 'numeric'\\n        },\\n        limit: {\\n          type: 'numeric'\\n        },\\n        offset: {\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        statement: {\\n          required: 1,\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'statement',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {String} args.states_list - Client's 2-letter country code (obtained from `residence_list` call)\\n     */\\n\\n  }, {\\n    key: \\\"statesList\\\",\\n    value: function statesList() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        states_list: {\\n          required: 1,\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'states_list',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.subscribe - [Optional] If set to 1, will send updates whenever a new tick is received.\\n     * @param {Any} args.ticks - The short symbol name or array of symbols (obtained from `active_symbols` call).\\n     */\\n\\n  }, {\\n    key: \\\"ticks\\\",\\n    value: function ticks() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        subscribe: {\\n          type: 'numeric'\\n        },\\n        ticks: {\\n          required: 1\\n        }\\n      };\\n      var allArgs = {\\n        method: 'ticks',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.adjust_start_time - [Optional] 1 - if the market is closed at the end time, or license limit is before end time, adjust interval backwards to compensate.\\n     * @param {Number} args.count - [Optional] An upper limit on ticks to receive.\\n     * @param {String} args.end - Epoch value representing the latest boundary of the returned ticks. If `latest` is specified, this will be the latest available timestamp.\\n     * @param {Number} args.granularity - [Optional] Only applicable for style: `candles`. Candle time-dimension width setting. (default: `60`).\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.start - [Optional] Epoch value representing the earliest boundary of the returned ticks.\\n    - For `\\\"style\\\": \\\"ticks\\\"`: this will default to 1 day ago.\\n    - For `\\\"style\\\": \\\"candles\\\"`: it will default to 1 day ago if count or granularity is undefined.\\n     * @param {String} args.style - [Optional] The tick-output style.\\n     * @param {Number} args.subscribe - [Optional] 1 - to send updates whenever a new tick is received.\\n     * @param {String} args.ticks_history - Short symbol name (obtained from the `active_symbols` call).\\n     */\\n\\n  }, {\\n    key: \\\"ticksHistory\\\",\\n    value: function ticksHistory() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        adjust_start_time: {\\n          type: 'numeric'\\n        },\\n        count: {\\n          type: 'numeric'\\n        },\\n        end: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        granularity: {\\n          type: 'numeric'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        start: {\\n          type: 'numeric'\\n        },\\n        style: {\\n          type: 'string'\\n        },\\n        subscribe: {\\n          type: 'numeric'\\n        },\\n        ticks_history: {\\n          required: 1,\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'ticks_history',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.time - Must be `1`\\n     */\\n\\n  }, {\\n    key: \\\"time\\\",\\n    value: function time() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        time: {\\n          required: 1,\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'time',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.tnc_approval - Must be `1`\\n     * @param {Number} args.ukgc_funds_protection - [Optional] For `ASK_UK_FUNDS_PROTECTION` in `cashier`.\\n     */\\n\\n  }, {\\n    key: \\\"tncApproval\\\",\\n    value: function tncApproval() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        tnc_approval: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        ukgc_funds_protection: {\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'tnc_approval',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.topup_virtual - Must be `1`\\n     */\\n\\n  }, {\\n    key: \\\"topupVirtual\\\",\\n    value: function topupVirtual() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        topup_virtual: {\\n          required: 1,\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'topup_virtual',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.landing_company - [Optional] If specified, will return only the underlyings for the specified landing company.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.trading_durations - Must be `1`\\n     */\\n\\n  }, {\\n    key: \\\"tradingDurations\\\",\\n    value: function tradingDurations() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        landing_company: {\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        trading_durations: {\\n          required: 1,\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'trading_durations',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.platform - Trading platform name\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.trading_platform_accounts - Must be `1`\\n     */\\n\\n  }, {\\n    key: \\\"tradingPlatformAccounts\\\",\\n    value: function tradingPlatformAccounts() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        passthrough: {},\\n        platform: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        trading_platform_accounts: {\\n          required: 1,\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'trading_platform_accounts',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.amount - Amount to deposit (in the currency of from_wallet).\\n     * @param {String} args.from_account - Wallet account to transfer money from.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.platform - Name of trading platform.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {String} args.to_account - Trading account login to deposit money to.\\n     * @param {Number} args.trading_platform_deposit - Must be `1`\\n     */\\n\\n  }, {\\n    key: \\\"tradingPlatformDeposit\\\",\\n    value: function tradingPlatformDeposit() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        amount: {\\n          type: 'numeric'\\n        },\\n        from_account: {\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        platform: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        to_account: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        trading_platform_deposit: {\\n          required: 1,\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'trading_platform_deposit',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.account_id - Trading account ID.\\n     * @param {String} args.new_password - New investor password. Accepts any printable ASCII character. Must be within 8-25 characters, and include numbers, lowercase and uppercase letters. Must not be the same as the user's email address.\\n     * @param {String} args.old_password - Old investor password for validation (non-empty string, accepts any printable ASCII character)\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.platform - Name of trading platform.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.trading_platform_investor_password_change - Must be `1`\\n     */\\n\\n  }, {\\n    key: \\\"tradingPlatformInvestorPasswordChange\\\",\\n    value: function tradingPlatformInvestorPasswordChange() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        account_id: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        new_password: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        old_password: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        platform: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        trading_platform_investor_password_change: {\\n          required: 1,\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'trading_platform_investor_password_change',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.account_id - Trading account ID.\\n     * @param {String} args.new_password - New password of the account. For validation (Accepts any printable ASCII character. Must be within 8-25 characters, and include numbers, lowercase and uppercase letters. Must not be the same as the user's email address).\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.platform - Name of trading platform.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.trading_platform_investor_password_reset - Must be `1`\\n     * @param {String} args.verification_code - Email verification code (received from a `verify_email` call, which must be done first)\\n     */\\n\\n  }, {\\n    key: \\\"tradingPlatformInvestorPasswordReset\\\",\\n    value: function tradingPlatformInvestorPasswordReset() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        account_id: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        new_password: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        platform: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        trading_platform_investor_password_reset: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        verification_code: {\\n          required: 1,\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'trading_platform_investor_password_reset',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.account_type - Account type.\\n     * @param {String} args.currency - [Optional] Trading account currency, the default value will be the qualified account currency.\\n     * @param {Number} args.dry_run - [Optional] If set to 1, only validation is performed.\\n     * @param {String} args.market_type - Market type\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.password - The master password of the account. For validation (Accepts any printable ASCII character. Must be within 8-25 characters, and include numbers, lowercase and uppercase letters. Must not be the same as the user's email address). This field is required.\\n     * @param {String} args.platform - Name of trading platform.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {String} args.sub_account_type - [Optional] Sub account type.\\n     * @param {Number} args.trading_platform_new_account - Must be `1`\\n     */\\n\\n  }, {\\n    key: \\\"tradingPlatformNewAccount\\\",\\n    value: function tradingPlatformNewAccount() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        account_type: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        currency: {\\n          type: 'string'\\n        },\\n        dry_run: {\\n          type: 'numeric'\\n        },\\n        market_type: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        password: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        platform: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        sub_account_type: {\\n          type: 'string'\\n        },\\n        trading_platform_new_account: {\\n          required: 1,\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'trading_platform_new_account',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.new_password - New trading password. Accepts any printable ASCII character. Must be within 8-25 characters, and include numbers, lowercase and uppercase letters. Must not be the same as the user's email address.\\n     * @param {String} args.old_password - Old password for validation. Must be empty if a password has not been set yet.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.platform - Name of trading platform.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.trading_platform_password_change - Must be `1`\\n     */\\n\\n  }, {\\n    key: \\\"tradingPlatformPasswordChange\\\",\\n    value: function tradingPlatformPasswordChange() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        new_password: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        old_password: {\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        platform: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        trading_platform_password_change: {\\n          required: 1,\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'trading_platform_password_change',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.new_password - New password of the account. For validation (Accepts any printable ASCII character. Must be within 8-25 characters, and include numbers, lowercase and uppercase letters. Must not be the same as the user's email address).\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.platform - Name of trading platform.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.trading_platform_password_reset - Must be `1`\\n     * @param {String} args.verification_code - Email verification code (received from a `verify_email` call, which must be done first)\\n     */\\n\\n  }, {\\n    key: \\\"tradingPlatformPasswordReset\\\",\\n    value: function tradingPlatformPasswordReset() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        new_password: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        platform: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        trading_platform_password_reset: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        verification_code: {\\n          required: 1,\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'trading_platform_password_reset',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Number} args.amount - Amount to withdraw (in the currency of the Trading account).\\n     * @param {String} args.from_account - Trading account login to withdraw money from.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.platform - Name of trading platform.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {String} args.to_account - Wallet account loginid to transfer money to.\\n     * @param {Number} args.trading_platform_withdrawal - Must be `1`\\n     */\\n\\n  }, {\\n    key: \\\"tradingPlatformWithdrawal\\\",\\n    value: function tradingPlatformWithdrawal() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        amount: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        from_account: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        platform: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        to_account: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        trading_platform_withdrawal: {\\n          required: 1,\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'trading_platform_withdrawal',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.account_type - [Optional] Trading account type.\\n     * @param {String} args.environment - [Optional] Pass the environment (installation) instance. Currently, there are one demo and two real environments. Defaults to 'all'.\\n     * @param {String} args.market_type - [Optional] Market type.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {String} args.platform - [Optional] Pass the trading platform name, default to mt5\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.trading_servers - Must be `1`\\n     */\\n\\n  }, {\\n    key: \\\"tradingServers\\\",\\n    value: function tradingServers() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        account_type: {\\n          type: 'string'\\n        },\\n        environment: {\\n          type: 'string'\\n        },\\n        market_type: {\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        platform: {\\n          type: 'string'\\n        },\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        trading_servers: {\\n          required: 1,\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'trading_servers',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {String} args.trading_times - Date to receive market opening times for. (`yyyy-mm-dd` format. `today` can also be specified).\\n     */\\n\\n  }, {\\n    key: \\\"tradingTimes\\\",\\n    value: function tradingTimes() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        trading_times: {\\n          required: 1,\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'trading_times',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.subscribe - If set to 1, will send updates whenever there is an update to transactions. If not to 1 then it will not return any records.\\n     * @param {Number} args.transaction - Must be `1`\\n     */\\n\\n  }, {\\n    key: \\\"transaction\\\",\\n    value: function transaction() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        subscribe: {\\n          required: 1,\\n          type: 'numeric'\\n        },\\n        transaction: {\\n          required: 1,\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'transaction',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {String} args.account_from - [Optional] The loginid of the account to transfer funds from.\\n     * @param {String} args.account_to - [Optional] The loginid of the account to transfer funds to.\\n     * @param {String} args.accounts - [Optional] To control the list of accounts returned when `account_from` or `account_to` is not provided. `brief` (default value) means that accounts with `mt5` account_type will be excluded; it will run faster. `all` means that all accounts with any account_type (including `mt5`) will be returned.\\n     * @param {Number} args.amount - [Optional] The amount to transfer.\\n     * @param {String} args.currency - [Optional] Currency code.\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.transfer_between_accounts - If `account_from` or `account_to` is not provided, it just returns the available accounts.\\n     */\\n\\n  }, {\\n    key: \\\"transferBetweenAccounts\\\",\\n    value: function transferBetweenAccounts() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        account_from: {\\n          type: 'string'\\n        },\\n        account_to: {\\n          type: 'string'\\n        },\\n        accounts: {\\n          type: 'string'\\n        },\\n        amount: {\\n          type: 'numeric'\\n        },\\n        currency: {\\n          type: 'string'\\n        },\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        transfer_between_accounts: {\\n          required: 1,\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'transfer_between_accounts',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {String} args.type - Purpose of the email verification call.\\n     * @param {Any} args.url_parameters -\\n     * @param {String} args.verify_email - Email address to be verified.\\n     */\\n\\n  }, {\\n    key: \\\"verifyEmail\\\",\\n    value: function verifyEmail() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        type: {\\n          required: 1,\\n          type: 'string'\\n        },\\n        url_parameters: {\\n          affiliate_token: {\\n            type: 'string'\\n          },\\n          date_first_contact: {\\n            type: 'string'\\n          },\\n          gclid_url: {\\n            type: 'string'\\n          },\\n          pa_amount: {\\n            type: 'numeric'\\n          },\\n          pa_currency: {\\n            type: 'string'\\n          },\\n          pa_loginid: {\\n            type: 'string'\\n          },\\n          pa_remarks: {\\n            type: 'string'\\n          },\\n          redirect_to: {\\n            type: 'numeric'\\n          },\\n          signup_device: {\\n            type: 'string'\\n          },\\n          utm_ad_id: {},\\n          utm_adgroup_id: {},\\n          utm_adrollclk_id: {},\\n          utm_campaign: {},\\n          utm_campaign_id: {},\\n          utm_content: {},\\n          utm_fbcl_id: {},\\n          utm_gl_client_id: {},\\n          utm_medium: {},\\n          utm_msclk_id: {},\\n          utm_source: {},\\n          utm_term: {}\\n        },\\n        verify_email: {\\n          required: 1,\\n          type: 'string'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'verify_email',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n    /**\\n     * @param {Object} args\\n     * @param {Any} args.passthrough - [Optional] Used to pass data through the websocket, which may be retrieved via the `echo_req` output field.\\n     * @param {Number} args.req_id - [Optional] Used to map request to response.\\n     * @param {Number} args.subscribe - [Optional] `1` to stream the server/website status updates.\\n     * @param {Number} args.website_status - Must be `1`\\n     */\\n\\n  }, {\\n    key: \\\"websiteStatus\\\",\\n    value: function websiteStatus() {\\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var config = {\\n        passthrough: {},\\n        req_id: {\\n          type: 'numeric'\\n        },\\n        subscribe: {\\n          type: 'numeric'\\n        },\\n        website_status: {\\n          required: 1,\\n          type: 'numeric'\\n        }\\n      };\\n      var allArgs = {\\n        method: 'website_status',\\n        needsMethodArg: '1',\\n        args: args,\\n        config: config\\n      };\\n      return this.processRequest(allArgs);\\n    }\\n  }, {\\n    key: \\\"processRequest\\\",\\n    value: function processRequest(allArgs) {\\n      var config = allArgs.config;\\n      var parsedArgs = parseArgs(allArgs);\\n      var error = validateArgs({\\n        config: config,\\n        args: parsedArgs\\n      });\\n\\n      if (error) {\\n        return Promise.reject(error);\\n      }\\n\\n      return this.send(parsedArgs);\\n    }\\n  }]);\\n\\n  return DerivAPICalls;\\n}(); // ==========================\\n// ----- Helper Methods -----\\n// ==========================\\n\\n\\n\\n\\nvar isObject = function isObject(value) {\\n  return value instanceof Object;\\n};\\n\\nvar typeCheckers = {\\n  object: isObject,\\n  numeric: function numeric(value) {\\n    return !Number.isNaN(value * 1);\\n  },\\n  string: function string(value) {\\n    return typeof value === 'string';\\n  },\\n  \\\"boolean\\\": function boolean(value) {\\n    return [true, false, 0, 1].includes(value);\\n  }\\n};\\n\\nfunction parseArgs(_ref) {\\n  var config = _ref.config,\\n      args = _ref.args,\\n      method = _ref.method,\\n      needsMethodArg = _ref.needsMethodArg;\\n  var parsedArgs = args;\\n\\n  if (needsMethodArg && !isObject(parsedArgs)) {\\n    parsedArgs = (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__.default)({}, method, parsedArgs);\\n  }\\n\\n  parsedArgs[method] = parsedArgs[method] || 1;\\n  Object.keys(parsedArgs).forEach(function (param) {\\n    var value = parsedArgs[param];\\n    if (!(param in config)) return;\\n\\n    if (config[param].type === 'string') {\\n      parsedArgs[param] = \\\"\\\".concat(value);\\n    } else if (config[param].type === 'numeric') {\\n      parsedArgs[param] = parseInt(value, 10);\\n    } else if (config[param].type === 'boolean') {\\n      parsedArgs[param] = +value;\\n    }\\n  });\\n  return parsedArgs;\\n}\\n\\nfunction validateArgs(_ref2) {\\n  var config = _ref2.config,\\n      args = _ref2.args;\\n\\n  if (!isObject(args)) {\\n    return \\\"Requires an object but a \\\".concat((0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__.default)(args), \\\" is passed.\\\");\\n  }\\n\\n  var errorMessages = [];\\n  var missing = Object.keys(config).filter(function (key) {\\n    return (config[key] || {}).required && !(key in args);\\n  });\\n\\n  if (missing.length) {\\n    errorMessages.push(\\\"Required parameters missing: \\\".concat(missing.join(', ')));\\n  }\\n\\n  Object.keys(args).forEach(function (param) {\\n    var value = args[param];\\n    if (!(param in config)) return;\\n    var expectedType = config[param].type;\\n    if (!expectedType) return;\\n\\n    if (!typeCheckers[expectedType](value)) {\\n      errorMessages.push(\\\"\\\".concat(expectedType, \\\" value expected but found \\\").concat((0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__.default)(value), \\\": \\\").concat(param));\\n    }\\n  });\\n  return errorMessages.length ? errorMessages.join(' - ') : '';\\n}\\n\\n//# sourceURL=webpack://DerivAPIBasic/./src/deriv_api/DerivAPICalls.js?\");\n\n/***/ }),\n\n/***/ \"./src/deriv_api/InMemory.js\":\n/*!***********************************!*\\\n  !*** ./src/deriv_api/InMemory.js ***!\n  \\***********************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ InMemory)\\n/* harmony export */ });\\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \\\"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \\\"./node_modules/@babel/runtime/helpers/esm/createClass.js\\\");\\n\\n\\n\\n/**\\n * An in memory storage which can be used for caching\\n */\\nvar InMemory = /*#__PURE__*/function () {\\n  function InMemory() {\\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, InMemory);\\n\\n    this.store = {\\n      by_msg_type: {}\\n    };\\n  }\\n\\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(InMemory, [{\\n    key: \\\"has\\\",\\n    value: function has(key) {\\n      return key in this.store;\\n    }\\n  }, {\\n    key: \\\"get\\\",\\n    value: function get(key) {\\n      return this.store[key];\\n    }\\n  }, {\\n    key: \\\"getByMsgType\\\",\\n    value: function getByMsgType(type) {\\n      return this.store.by_msg_type[type];\\n    }\\n  }, {\\n    key: \\\"set\\\",\\n    value: function set(key, value) {\\n      this.store.by_msg_type[value.msg_type] = value;\\n      this.store[key] = value;\\n    }\\n  }]);\\n\\n  return InMemory;\\n}();\\n\\n\\n\\n//# sourceURL=webpack://DerivAPIBasic/./src/deriv_api/InMemory.js?\");\n\n/***/ }),\n\n/***/ \"./src/deriv_api/SubscriptionManager.js\":\n/*!**********************************************!*\\\n  !*** ./src/deriv_api/SubscriptionManager.js ***!\n  \\**********************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ SubscriptionManager)\\n/* harmony export */ });\\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \\\"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \\\"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \\\"./node_modules/@babel/runtime/helpers/esm/createClass.js\\\");\\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs/operators */ \\\"./node_modules/rxjs/dist/esm5/internal/operators/finalize.js\\\");\\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs/operators */ \\\"./node_modules/rxjs/dist/esm5/internal/operators/share.js\\\");\\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs/operators */ \\\"./node_modules/rxjs/dist/esm5/internal/operators/first.js\\\");\\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors */ \\\"./src/deriv_api/errors.js\\\");\\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ \\\"./src/deriv_api/utils.js\\\");\\n\\n\\n\\n\\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\\n\\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\\n\\n\\n\\n\\n/**\\n * Subscription Manager - manage subscription channels\\n *\\n * Makes sure there is always only one subscription channel for all requests of\\n * subscriptions, keeps a history of received values for the subscription of ticks\\n * and forgets channels that do not have subscribers. It also ensures that\\n * subscriptions are revived after connection drop/account changed.\\n *\\n *\\n * @example\\n * // This one creates a new subscription assuming it is the first one for R_100\\n * const subscriber1 = api.subscribe({ ticks: 'R_100' }, console.log);\\n *\\n * // This one uses the existing subscription to R_100\\n * const subscriber2 = api.subscribe({ ticks: 'R_100' }, console.log);\\n *\\n * subscriber1.unsubscribe(); // no API forget yet\\n * subscriber2.unsubscribe(); // Issues API forget\\n *\\n */\\n\\nvar SubscriptionManager = /*#__PURE__*/function () {\\n  function SubscriptionManager(api) {\\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.default)(this, SubscriptionManager);\\n\\n    this.api = api;\\n    this.sources = {};\\n    this.subs_id_to_key = {};\\n    this.key_to_subs_id = {};\\n    this.buy_key_to_contract_id = {};\\n    this.subs_per_msg_type = []; // streams_list is the list of subscriptions msg_types available.\\n    // Please add/remove based on current available streams in api.\\n    // Refer https://developers.binary.com/\\n\\n    this.streams_list = ['balance', 'candles', 'p2p_advertiser', 'p2p_order', 'proposal', 'proposal_array', 'proposal_open_contract', 'ticks', 'ticks_history', 'transaction', 'website_status'];\\n  }\\n  /**\\n   * Subscribe to a given request, returns a stream of new responses,\\n   * Errors should be handled by the user of the stream\\n   *\\n   * @example\\n   * const ticks = api.subscribe({ ticks: 'R_100' });\\n   * ticks.subscribe(console.log) // Print every new tick\\n   *\\n   * @param {Object} request - A request object acceptable by the API\\n   *\\n   * @returns {Observable} - An RxJS Observable\\n   */\\n\\n\\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.default)(SubscriptionManager, [{\\n    key: \\\"subscribe\\\",\\n    value: function subscribe(request) {\\n      if (this.sourceExists(request)) {\\n        return this.getSource(request);\\n      }\\n\\n      return this.createNewSource(_objectSpread(_objectSpread({}, request), {}, {\\n        subscribe: 1\\n      }));\\n    }\\n  }, {\\n    key: \\\"getSource\\\",\\n    value: function getSource(request) {\\n      var key = toKey(request);\\n      if (key in this.sources) return this.sources[key]; // If we have a buy subscription reuse that for poc\\n\\n      if (request.proposal_open_contract && request.contract_id) {\\n        var poc_source = Object.values(this.buy_key_to_contract_id).find(function (c) {\\n          return c.contract_id === request.contract_id;\\n        });\\n\\n        if (poc_source) {\\n          return this.sources[poc_source.buy_key];\\n        }\\n      }\\n\\n      return undefined;\\n    } // Just an alias to getSource\\n\\n  }, {\\n    key: \\\"sourceExists\\\",\\n    value: function sourceExists(request) {\\n      return this.getSource(request);\\n    }\\n  }, {\\n    key: \\\"createNewSource\\\",\\n    value: function createNewSource(request) {\\n      var _this = this;\\n\\n      var key = toKey(request);\\n      var source = this.api.sendAndGetSource(request).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.finalize)(function () {\\n        if (!(key in _this.key_to_subs_id)) return; // Forget subscriptions, but don't complain if failed\\n\\n        _this.forget(_this.key_to_subs_id[key]).then(function () {}, function () {});\\n      }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.share)());\\n      this.sources[key] = source;\\n      this.saveSubsPerMsgType(request, key);\\n      source.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.first)()).toPromise().then(function (response) {\\n        if (request.buy) {\\n          _this.buy_key_to_contract_id[key] = {\\n            contract_id: response.buy.contract_id,\\n            buy_key: key\\n          };\\n        }\\n\\n        _this.saveSubsId(key, response);\\n      }, this.removeKeyOnError(key));\\n      return source;\\n    }\\n  }, {\\n    key: \\\"forget\\\",\\n    value: function forget(id) {\\n      this.completeSubsByIds(id);\\n      return this.api.send({\\n        forget: id\\n      });\\n    }\\n  }, {\\n    key: \\\"forgetAll\\\",\\n    value: function forgetAll() {\\n      var _this2 = this;\\n\\n      for (var _len = arguments.length, types = new Array(_len), _key = 0; _key < _len; _key++) {\\n        types[_key] = arguments[_key];\\n      }\\n\\n      // To include subscriptions that were automatically unsubscribed\\n      // for example a proposal subscription is auto-unsubscribed after buy\\n      types.forEach(function (type) {\\n        (_this2.subs_per_msg_type[type] || []).forEach(function (key) {\\n          return _this2.completeSubsByKey(key);\\n        });\\n        _this2.subs_per_msg_type[type] = [];\\n      });\\n      return this.api.send({\\n        forget_all: types\\n      });\\n    }\\n  }, {\\n    key: \\\"completeSubsByIds\\\",\\n    value: function completeSubsByIds() {\\n      var _this3 = this;\\n\\n      for (var _len2 = arguments.length, subs_ids = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\\n        subs_ids[_key2] = arguments[_key2];\\n      }\\n\\n      subs_ids.forEach(function (id) {\\n        var key = _this3.subs_id_to_key[id];\\n        delete _this3.subs_id_to_key[id];\\n\\n        _this3.completeSubsByKey(key);\\n      });\\n    }\\n  }, {\\n    key: \\\"saveSubsId\\\",\\n    value: function saveSubsId(key, _ref) {\\n      var subscription = _ref.subscription;\\n      // If the response doesn't have a subs id, it's not a subscription, so complete source\\n      // Useful for poc for sold contract which never returns subscription\\n      if (!subscription) return this.completeSubsByKey(key);\\n      var id = subscription.id;\\n\\n      if (!(id in this.subs_id_to_key)) {\\n        this.subs_id_to_key[id] = key;\\n        this.key_to_subs_id[key] = id;\\n      }\\n\\n      return undefined;\\n    }\\n  }, {\\n    key: \\\"saveSubsPerMsgType\\\",\\n    value: function saveSubsPerMsgType(request, key) {\\n      var msg_type = this.getMsgType(request);\\n\\n      if (msg_type) {\\n        this.subs_per_msg_type[msg_type] = this.subs_per_msg_type[msg_type] || [];\\n        this.subs_per_msg_type[msg_type].push(key);\\n      } else {\\n        this.api.sanityErrors.next(new _errors__WEBPACK_IMPORTED_MODULE_3__.APIError('Subscription type is not found in deriv-api'));\\n      }\\n    }\\n  }, {\\n    key: \\\"removeKeyOnError\\\",\\n    value: function removeKeyOnError(key) {\\n      var _this4 = this;\\n\\n      return function () {\\n        return _this4.completeSubsByKey(key);\\n      };\\n    }\\n  }, {\\n    key: \\\"completeSubsByKey\\\",\\n    value: function completeSubsByKey(key) {\\n      if (!key || !this.sources[key]) return; // Delete the source\\n\\n      var source = this.sources[key];\\n      delete this.sources[key]; // Delete the subs id if exists\\n\\n      var subs_id = this.key_to_subs_id[key];\\n      delete this.subs_id_to_key[subs_id]; // Delete the key\\n\\n      delete this.key_to_subs_id[key]; // Delete the buy key to contract_id mapping\\n\\n      delete this.buy_key_to_contract_id[key]; // Mark the source completed\\n\\n      source.complete();\\n    }\\n  }, {\\n    key: \\\"getMsgType\\\",\\n    value: function getMsgType(request) {\\n      return this.streams_list.find(function (stream_key) {\\n        return stream_key in request;\\n      });\\n    }\\n  }]);\\n\\n  return SubscriptionManager;\\n}();\\n\\n\\n\\nfunction toKey(request) {\\n  return (0,_utils__WEBPACK_IMPORTED_MODULE_4__.objectToCacheKey)(request);\\n}\\n\\n//# sourceURL=webpack://DerivAPIBasic/./src/deriv_api/SubscriptionManager.js?\");\n\n/***/ }),\n\n/***/ \"./src/deriv_api/errors.js\":\n/*!*********************************!*\\\n  !*** ./src/deriv_api/errors.js ***!\n  \\*********************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"errorFactory\\\": () => (/* binding */ errorFactory),\\n/* harmony export */   \\\"APIError\\\": () => (/* binding */ APIError),\\n/* harmony export */   \\\"ConstructionError\\\": () => (/* binding */ ConstructionError)\\n/* harmony export */ });\\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \\\"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \\\"./node_modules/@babel/runtime/helpers/esm/createClass.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ \\\"./node_modules/@babel/runtime/helpers/esm/inherits.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \\\"./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \\\"./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\\\");\\n/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/wrapNativeSuper */ \\\"./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\\\");\\n\\n\\n\\n\\n\\n\\n\\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__.default)(this, result); }; }\\n\\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \\\"undefined\\\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \\\"function\\\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\\n\\nfunction errorFactory(type) {\\n  return /*#__PURE__*/function (_Error) {\\n    (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__.default)(GenericError, _Error);\\n\\n    var _super = _createSuper(GenericError);\\n\\n    function GenericError(message) {\\n      var _this;\\n\\n      (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, GenericError);\\n\\n      _this = _super.call(this);\\n      _this.type = type;\\n      _this.message = message;\\n      return _this;\\n    }\\n\\n    (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(GenericError, [{\\n      key: \\\"toString\\\",\\n      value: function toString() {\\n        return \\\"\\\".concat(this.type, \\\": \\\").concat(this.message);\\n      }\\n    }]);\\n\\n    return GenericError;\\n  }( /*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_5__.default)(Error));\\n}\\nvar APIError = /*#__PURE__*/function (_errorFactory) {\\n  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__.default)(APIError, _errorFactory);\\n\\n  var _super2 = _createSuper(APIError);\\n\\n  function APIError() {\\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, APIError);\\n\\n    return _super2.apply(this, arguments);\\n  }\\n\\n  return APIError;\\n}(errorFactory('APIError'));\\nvar ConstructionError = /*#__PURE__*/function (_errorFactory2) {\\n  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__.default)(ConstructionError, _errorFactory2);\\n\\n  var _super3 = _createSuper(ConstructionError);\\n\\n  function ConstructionError() {\\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, ConstructionError);\\n\\n    return _super3.apply(this, arguments);\\n  }\\n\\n  return ConstructionError;\\n}(errorFactory('ConstructionError'));\\n\\n//# sourceURL=webpack://DerivAPIBasic/./src/deriv_api/errors.js?\");\n\n/***/ }),\n\n/***/ \"./src/deriv_api/utils.js\":\n/*!********************************!*\\\n  !*** ./src/deriv_api/utils.js ***!\n  \\********************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"objectToCacheKey\\\": () => (/* binding */ objectToCacheKey)\\n/* harmony export */ });\\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \\\"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\\\");\\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! json-stable-stringify */ \\\"./node_modules/json-stable-stringify/index.js\\\");\\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(json_stable_stringify__WEBPACK_IMPORTED_MODULE_1__);\\n\\n\\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\\n\\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\\n\\n // eslint-disable-next-line import/prefer-default-export\\n\\nfunction objectToCacheKey(obj) {\\n  var cloned_object = _objectSpread({}, obj);\\n\\n  delete cloned_object.req_id;\\n  delete cloned_object.passthrough;\\n  delete cloned_object.subscribe;\\n  return json_stable_stringify__WEBPACK_IMPORTED_MODULE_1___default()(cloned_object);\\n}\\n\\n//# sourceURL=webpack://DerivAPIBasic/./src/deriv_api/utils.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/json-stable-stringify/index.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/json-stable-stringify/index.js ***!\n  \\*****************************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\neval(\"var json = typeof JSON !== 'undefined' ? JSON : __webpack_require__(/*! jsonify */ \\\"./node_modules/jsonify/index.js\\\");\\n\\nmodule.exports = function (obj, opts) {\\n    if (!opts) opts = {};\\n    if (typeof opts === 'function') opts = { cmp: opts };\\n    var space = opts.space || '';\\n    if (typeof space === 'number') space = Array(space+1).join(' ');\\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\\n    var replacer = opts.replacer || function(key, value) { return value; };\\n\\n    var cmp = opts.cmp && (function (f) {\\n        return function (node) {\\n            return function (a, b) {\\n                var aobj = { key: a, value: node[a] };\\n                var bobj = { key: b, value: node[b] };\\n                return f(aobj, bobj);\\n            };\\n        };\\n    })(opts.cmp);\\n\\n    var seen = [];\\n    return (function stringify (parent, key, node, level) {\\n        var indent = space ? ('\\\\n' + new Array(level + 1).join(space)) : '';\\n        var colonSeparator = space ? ': ' : ':';\\n\\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\\n            node = node.toJSON();\\n        }\\n\\n        node = replacer.call(parent, key, node);\\n\\n        if (node === undefined) {\\n            return;\\n        }\\n        if (typeof node !== 'object' || node === null) {\\n            return json.stringify(node);\\n        }\\n        if (isArray(node)) {\\n            var out = [];\\n            for (var i = 0; i < node.length; i++) {\\n                var item = stringify(node, i, node[i], level+1) || json.stringify(null);\\n                out.push(indent + space + item);\\n            }\\n            return '[' + out.join(',') + indent + ']';\\n        }\\n        else {\\n            if (seen.indexOf(node) !== -1) {\\n                if (cycles) return json.stringify('__cycle__');\\n                throw new TypeError('Converting circular structure to JSON');\\n            }\\n            else seen.push(node);\\n\\n            var keys = objectKeys(node).sort(cmp && cmp(node));\\n            var out = [];\\n            for (var i = 0; i < keys.length; i++) {\\n                var key = keys[i];\\n                var value = stringify(node, key, node[key], level+1);\\n\\n                if(!value) continue;\\n\\n                var keyValue = json.stringify(key)\\n                    + colonSeparator\\n                    + value;\\n                ;\\n                out.push(indent + space + keyValue);\\n            }\\n            seen.splice(seen.indexOf(node), 1);\\n            return '{' + out.join(',') + indent + '}';\\n        }\\n    })({ '': obj }, '', obj, 0);\\n};\\n\\nvar isArray = Array.isArray || function (x) {\\n    return {}.toString.call(x) === '[object Array]';\\n};\\n\\nvar objectKeys = Object.keys || function (obj) {\\n    var has = Object.prototype.hasOwnProperty || function () { return true };\\n    var keys = [];\\n    for (var key in obj) {\\n        if (has.call(obj, key)) keys.push(key);\\n    }\\n    return keys;\\n};\\n\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/json-stable-stringify/index.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/jsonify/index.js\":\n/*!***************************************!*\\\n  !*** ./node_modules/jsonify/index.js ***!\n  \\***************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"exports.parse = __webpack_require__(/*! ./lib/parse */ \\\"./node_modules/jsonify/lib/parse.js\\\");\\nexports.stringify = __webpack_require__(/*! ./lib/stringify */ \\\"./node_modules/jsonify/lib/stringify.js\\\");\\n\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/jsonify/index.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/jsonify/lib/parse.js\":\n/*!*******************************************!*\\\n  !*** ./node_modules/jsonify/lib/parse.js ***!\n  \\*******************************************/\n/***/ ((module) => {\n\neval(\"var at, // The index of the current character\\n    ch, // The current character\\n    escapee = {\\n        '\\\"':  '\\\"',\\n        '\\\\\\\\': '\\\\\\\\',\\n        '/':  '/',\\n        b:    '\\\\b',\\n        f:    '\\\\f',\\n        n:    '\\\\n',\\n        r:    '\\\\r',\\n        t:    '\\\\t'\\n    },\\n    text,\\n\\n    error = function (m) {\\n        // Call error when something is wrong.\\n        throw {\\n            name:    'SyntaxError',\\n            message: m,\\n            at:      at,\\n            text:    text\\n        };\\n    },\\n    \\n    next = function (c) {\\n        // If a c parameter is provided, verify that it matches the current character.\\n        if (c && c !== ch) {\\n            error(\\\"Expected '\\\" + c + \\\"' instead of '\\\" + ch + \\\"'\\\");\\n        }\\n        \\n        // Get the next character. When there are no more characters,\\n        // return the empty string.\\n        \\n        ch = text.charAt(at);\\n        at += 1;\\n        return ch;\\n    },\\n    \\n    number = function () {\\n        // Parse a number value.\\n        var number,\\n            string = '';\\n        \\n        if (ch === '-') {\\n            string = '-';\\n            next('-');\\n        }\\n        while (ch >= '0' && ch <= '9') {\\n            string += ch;\\n            next();\\n        }\\n        if (ch === '.') {\\n            string += '.';\\n            while (next() && ch >= '0' && ch <= '9') {\\n                string += ch;\\n            }\\n        }\\n        if (ch === 'e' || ch === 'E') {\\n            string += ch;\\n            next();\\n            if (ch === '-' || ch === '+') {\\n                string += ch;\\n                next();\\n            }\\n            while (ch >= '0' && ch <= '9') {\\n                string += ch;\\n                next();\\n            }\\n        }\\n        number = +string;\\n        if (!isFinite(number)) {\\n            error(\\\"Bad number\\\");\\n        } else {\\n            return number;\\n        }\\n    },\\n    \\n    string = function () {\\n        // Parse a string value.\\n        var hex,\\n            i,\\n            string = '',\\n            uffff;\\n        \\n        // When parsing for string values, we must look for \\\" and \\\\ characters.\\n        if (ch === '\\\"') {\\n            while (next()) {\\n                if (ch === '\\\"') {\\n                    next();\\n                    return string;\\n                } else if (ch === '\\\\\\\\') {\\n                    next();\\n                    if (ch === 'u') {\\n                        uffff = 0;\\n                        for (i = 0; i < 4; i += 1) {\\n                            hex = parseInt(next(), 16);\\n                            if (!isFinite(hex)) {\\n                                break;\\n                            }\\n                            uffff = uffff * 16 + hex;\\n                        }\\n                        string += String.fromCharCode(uffff);\\n                    } else if (typeof escapee[ch] === 'string') {\\n                        string += escapee[ch];\\n                    } else {\\n                        break;\\n                    }\\n                } else {\\n                    string += ch;\\n                }\\n            }\\n        }\\n        error(\\\"Bad string\\\");\\n    },\\n\\n    white = function () {\\n\\n// Skip whitespace.\\n\\n        while (ch && ch <= ' ') {\\n            next();\\n        }\\n    },\\n\\n    word = function () {\\n\\n// true, false, or null.\\n\\n        switch (ch) {\\n        case 't':\\n            next('t');\\n            next('r');\\n            next('u');\\n            next('e');\\n            return true;\\n        case 'f':\\n            next('f');\\n            next('a');\\n            next('l');\\n            next('s');\\n            next('e');\\n            return false;\\n        case 'n':\\n            next('n');\\n            next('u');\\n            next('l');\\n            next('l');\\n            return null;\\n        }\\n        error(\\\"Unexpected '\\\" + ch + \\\"'\\\");\\n    },\\n\\n    value,  // Place holder for the value function.\\n\\n    array = function () {\\n\\n// Parse an array value.\\n\\n        var array = [];\\n\\n        if (ch === '[') {\\n            next('[');\\n            white();\\n            if (ch === ']') {\\n                next(']');\\n                return array;   // empty array\\n            }\\n            while (ch) {\\n                array.push(value());\\n                white();\\n                if (ch === ']') {\\n                    next(']');\\n                    return array;\\n                }\\n                next(',');\\n                white();\\n            }\\n        }\\n        error(\\\"Bad array\\\");\\n    },\\n\\n    object = function () {\\n\\n// Parse an object value.\\n\\n        var key,\\n            object = {};\\n\\n        if (ch === '{') {\\n            next('{');\\n            white();\\n            if (ch === '}') {\\n                next('}');\\n                return object;   // empty object\\n            }\\n            while (ch) {\\n                key = string();\\n                white();\\n                next(':');\\n                if (Object.hasOwnProperty.call(object, key)) {\\n                    error('Duplicate key \\\"' + key + '\\\"');\\n                }\\n                object[key] = value();\\n                white();\\n                if (ch === '}') {\\n                    next('}');\\n                    return object;\\n                }\\n                next(',');\\n                white();\\n            }\\n        }\\n        error(\\\"Bad object\\\");\\n    };\\n\\nvalue = function () {\\n\\n// Parse a JSON value. It could be an object, an array, a string, a number,\\n// or a word.\\n\\n    white();\\n    switch (ch) {\\n    case '{':\\n        return object();\\n    case '[':\\n        return array();\\n    case '\\\"':\\n        return string();\\n    case '-':\\n        return number();\\n    default:\\n        return ch >= '0' && ch <= '9' ? number() : word();\\n    }\\n};\\n\\n// Return the json_parse function. It will have access to all of the above\\n// functions and variables.\\n\\nmodule.exports = function (source, reviver) {\\n    var result;\\n    \\n    text = source;\\n    at = 0;\\n    ch = ' ';\\n    result = value();\\n    white();\\n    if (ch) {\\n        error(\\\"Syntax error\\\");\\n    }\\n\\n    // If there is a reviver function, we recursively walk the new structure,\\n    // passing each name/value pair to the reviver function for possible\\n    // transformation, starting with a temporary root object that holds the result\\n    // in an empty key. If there is not a reviver function, we simply return the\\n    // result.\\n\\n    return typeof reviver === 'function' ? (function walk(holder, key) {\\n        var k, v, value = holder[key];\\n        if (value && typeof value === 'object') {\\n            for (k in value) {\\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\\n                    v = walk(value, k);\\n                    if (v !== undefined) {\\n                        value[k] = v;\\n                    } else {\\n                        delete value[k];\\n                    }\\n                }\\n            }\\n        }\\n        return reviver.call(holder, key, value);\\n    }({'': result}, '')) : result;\\n};\\n\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/jsonify/lib/parse.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/jsonify/lib/stringify.js\":\n/*!***********************************************!*\\\n  !*** ./node_modules/jsonify/lib/stringify.js ***!\n  \\***********************************************/\n/***/ ((module) => {\n\neval(\"var cx = /[\\\\u0000\\\\u00ad\\\\u0600-\\\\u0604\\\\u070f\\\\u17b4\\\\u17b5\\\\u200c-\\\\u200f\\\\u2028-\\\\u202f\\\\u2060-\\\\u206f\\\\ufeff\\\\ufff0-\\\\uffff]/g,\\n    escapable = /[\\\\\\\\\\\\\\\"\\\\x00-\\\\x1f\\\\x7f-\\\\x9f\\\\u00ad\\\\u0600-\\\\u0604\\\\u070f\\\\u17b4\\\\u17b5\\\\u200c-\\\\u200f\\\\u2028-\\\\u202f\\\\u2060-\\\\u206f\\\\ufeff\\\\ufff0-\\\\uffff]/g,\\n    gap,\\n    indent,\\n    meta = {    // table of character substitutions\\n        '\\\\b': '\\\\\\\\b',\\n        '\\\\t': '\\\\\\\\t',\\n        '\\\\n': '\\\\\\\\n',\\n        '\\\\f': '\\\\\\\\f',\\n        '\\\\r': '\\\\\\\\r',\\n        '\\\"' : '\\\\\\\\\\\"',\\n        '\\\\\\\\': '\\\\\\\\\\\\\\\\'\\n    },\\n    rep;\\n\\nfunction quote(string) {\\n    // If the string contains no control characters, no quote characters, and no\\n    // backslash characters, then we can safely slap some quotes around it.\\n    // Otherwise we must also replace the offending characters with safe escape\\n    // sequences.\\n    \\n    escapable.lastIndex = 0;\\n    return escapable.test(string) ? '\\\"' + string.replace(escapable, function (a) {\\n        var c = meta[a];\\n        return typeof c === 'string' ? c :\\n            '\\\\\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\\n    }) + '\\\"' : '\\\"' + string + '\\\"';\\n}\\n\\nfunction str(key, holder) {\\n    // Produce a string from holder[key].\\n    var i,          // The loop counter.\\n        k,          // The member key.\\n        v,          // The member value.\\n        length,\\n        mind = gap,\\n        partial,\\n        value = holder[key];\\n    \\n    // If the value has a toJSON method, call it to obtain a replacement value.\\n    if (value && typeof value === 'object' &&\\n            typeof value.toJSON === 'function') {\\n        value = value.toJSON(key);\\n    }\\n    \\n    // If we were called with a replacer function, then call the replacer to\\n    // obtain a replacement value.\\n    if (typeof rep === 'function') {\\n        value = rep.call(holder, key, value);\\n    }\\n    \\n    // What happens next depends on the value's type.\\n    switch (typeof value) {\\n        case 'string':\\n            return quote(value);\\n        \\n        case 'number':\\n            // JSON numbers must be finite. Encode non-finite numbers as null.\\n            return isFinite(value) ? String(value) : 'null';\\n        \\n        case 'boolean':\\n        case 'null':\\n            // If the value is a boolean or null, convert it to a string. Note:\\n            // typeof null does not produce 'null'. The case is included here in\\n            // the remote chance that this gets fixed someday.\\n            return String(value);\\n            \\n        case 'object':\\n            if (!value) return 'null';\\n            gap += indent;\\n            partial = [];\\n            \\n            // Array.isArray\\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\\n                length = value.length;\\n                for (i = 0; i < length; i += 1) {\\n                    partial[i] = str(i, value) || 'null';\\n                }\\n                \\n                // Join all of the elements together, separated with commas, and\\n                // wrap them in brackets.\\n                v = partial.length === 0 ? '[]' : gap ?\\n                    '[\\\\n' + gap + partial.join(',\\\\n' + gap) + '\\\\n' + mind + ']' :\\n                    '[' + partial.join(',') + ']';\\n                gap = mind;\\n                return v;\\n            }\\n            \\n            // If the replacer is an array, use it to select the members to be\\n            // stringified.\\n            if (rep && typeof rep === 'object') {\\n                length = rep.length;\\n                for (i = 0; i < length; i += 1) {\\n                    k = rep[i];\\n                    if (typeof k === 'string') {\\n                        v = str(k, value);\\n                        if (v) {\\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\\n                        }\\n                    }\\n                }\\n            }\\n            else {\\n                // Otherwise, iterate through all of the keys in the object.\\n                for (k in value) {\\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\\n                        v = str(k, value);\\n                        if (v) {\\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\\n                        }\\n                    }\\n                }\\n            }\\n            \\n        // Join all of the member texts together, separated with commas,\\n        // and wrap them in braces.\\n\\n        v = partial.length === 0 ? '{}' : gap ?\\n            '{\\\\n' + gap + partial.join(',\\\\n' + gap) + '\\\\n' + mind + '}' :\\n            '{' + partial.join(',') + '}';\\n        gap = mind;\\n        return v;\\n    }\\n}\\n\\nmodule.exports = function (value, replacer, space) {\\n    var i;\\n    gap = '';\\n    indent = '';\\n    \\n    // If the space parameter is a number, make an indent string containing that\\n    // many spaces.\\n    if (typeof space === 'number') {\\n        for (i = 0; i < space; i += 1) {\\n            indent += ' ';\\n        }\\n    }\\n    // If the space parameter is a string, it will be used as the indent string.\\n    else if (typeof space === 'string') {\\n        indent = space;\\n    }\\n\\n    // If there is a replacer, it must be a function or an array.\\n    // Otherwise, throw an error.\\n    rep = replacer;\\n    if (replacer && typeof replacer !== 'function'\\n    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\\n        throw new Error('JSON.stringify');\\n    }\\n    \\n    // Make a fake root object containing our value under the key of ''.\\n    // Return the result of stringifying the value.\\n    return str('', {'': value});\\n};\\n\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/jsonify/lib/stringify.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/regenerator-runtime/runtime.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/regenerator-runtime/runtime.js ***!\n  \\*****************************************************/\n/***/ ((module) => {\n\neval(\"/**\\n * Copyright (c) 2014-present, Facebook, Inc.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\nvar runtime = (function (exports) {\\n  \\\"use strict\\\";\\n\\n  var Op = Object.prototype;\\n  var hasOwn = Op.hasOwnProperty;\\n  var undefined; // More compressible than void 0.\\n  var $Symbol = typeof Symbol === \\\"function\\\" ? Symbol : {};\\n  var iteratorSymbol = $Symbol.iterator || \\\"@@iterator\\\";\\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \\\"@@asyncIterator\\\";\\n  var toStringTagSymbol = $Symbol.toStringTag || \\\"@@toStringTag\\\";\\n\\n  function define(obj, key, value) {\\n    Object.defineProperty(obj, key, {\\n      value: value,\\n      enumerable: true,\\n      configurable: true,\\n      writable: true\\n    });\\n    return obj[key];\\n  }\\n  try {\\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\\n    define({}, \\\"\\\");\\n  } catch (err) {\\n    define = function(obj, key, value) {\\n      return obj[key] = value;\\n    };\\n  }\\n\\n  function wrap(innerFn, outerFn, self, tryLocsList) {\\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\\n    var generator = Object.create(protoGenerator.prototype);\\n    var context = new Context(tryLocsList || []);\\n\\n    // The ._invoke method unifies the implementations of the .next,\\n    // .throw, and .return methods.\\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\\n\\n    return generator;\\n  }\\n  exports.wrap = wrap;\\n\\n  // Try/catch helper to minimize deoptimizations. Returns a completion\\n  // record like context.tryEntries[i].completion. This interface could\\n  // have been (and was previously) designed to take a closure to be\\n  // invoked without arguments, but in all the cases we care about we\\n  // already have an existing method we want to call, so there's no need\\n  // to create a new function object. We can even get away with assuming\\n  // the method takes exactly one argument, since that happens to be true\\n  // in every case, so we don't have to touch the arguments object. The\\n  // only additional allocation required is the completion record, which\\n  // has a stable shape and so hopefully should be cheap to allocate.\\n  function tryCatch(fn, obj, arg) {\\n    try {\\n      return { type: \\\"normal\\\", arg: fn.call(obj, arg) };\\n    } catch (err) {\\n      return { type: \\\"throw\\\", arg: err };\\n    }\\n  }\\n\\n  var GenStateSuspendedStart = \\\"suspendedStart\\\";\\n  var GenStateSuspendedYield = \\\"suspendedYield\\\";\\n  var GenStateExecuting = \\\"executing\\\";\\n  var GenStateCompleted = \\\"completed\\\";\\n\\n  // Returning this object from the innerFn has the same effect as\\n  // breaking out of the dispatch switch statement.\\n  var ContinueSentinel = {};\\n\\n  // Dummy constructor functions that we use as the .constructor and\\n  // .constructor.prototype properties for functions that return Generator\\n  // objects. For full spec compliance, you may wish to configure your\\n  // minifier not to mangle the names of these two functions.\\n  function Generator() {}\\n  function GeneratorFunction() {}\\n  function GeneratorFunctionPrototype() {}\\n\\n  // This is a polyfill for %IteratorPrototype% for environments that\\n  // don't natively support it.\\n  var IteratorPrototype = {};\\n  define(IteratorPrototype, iteratorSymbol, function () {\\n    return this;\\n  });\\n\\n  var getProto = Object.getPrototypeOf;\\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\\n  if (NativeIteratorPrototype &&\\n      NativeIteratorPrototype !== Op &&\\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\\n    // This environment has a native %IteratorPrototype%; use it instead\\n    // of the polyfill.\\n    IteratorPrototype = NativeIteratorPrototype;\\n  }\\n\\n  var Gp = GeneratorFunctionPrototype.prototype =\\n    Generator.prototype = Object.create(IteratorPrototype);\\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\\n  define(Gp, \\\"constructor\\\", GeneratorFunctionPrototype);\\n  define(GeneratorFunctionPrototype, \\\"constructor\\\", GeneratorFunction);\\n  GeneratorFunction.displayName = define(\\n    GeneratorFunctionPrototype,\\n    toStringTagSymbol,\\n    \\\"GeneratorFunction\\\"\\n  );\\n\\n  // Helper for defining the .next, .throw, and .return methods of the\\n  // Iterator interface in terms of a single ._invoke method.\\n  function defineIteratorMethods(prototype) {\\n    [\\\"next\\\", \\\"throw\\\", \\\"return\\\"].forEach(function(method) {\\n      define(prototype, method, function(arg) {\\n        return this._invoke(method, arg);\\n      });\\n    });\\n  }\\n\\n  exports.isGeneratorFunction = function(genFun) {\\n    var ctor = typeof genFun === \\\"function\\\" && genFun.constructor;\\n    return ctor\\n      ? ctor === GeneratorFunction ||\\n        // For the native GeneratorFunction constructor, the best we can\\n        // do is to check its .name property.\\n        (ctor.displayName || ctor.name) === \\\"GeneratorFunction\\\"\\n      : false;\\n  };\\n\\n  exports.mark = function(genFun) {\\n    if (Object.setPrototypeOf) {\\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\\n    } else {\\n      genFun.__proto__ = GeneratorFunctionPrototype;\\n      define(genFun, toStringTagSymbol, \\\"GeneratorFunction\\\");\\n    }\\n    genFun.prototype = Object.create(Gp);\\n    return genFun;\\n  };\\n\\n  // Within the body of any async function, `await x` is transformed to\\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\\n  // `hasOwn.call(value, \\\"__await\\\")` to determine if the yielded value is\\n  // meant to be awaited.\\n  exports.awrap = function(arg) {\\n    return { __await: arg };\\n  };\\n\\n  function AsyncIterator(generator, PromiseImpl) {\\n    function invoke(method, arg, resolve, reject) {\\n      var record = tryCatch(generator[method], generator, arg);\\n      if (record.type === \\\"throw\\\") {\\n        reject(record.arg);\\n      } else {\\n        var result = record.arg;\\n        var value = result.value;\\n        if (value &&\\n            typeof value === \\\"object\\\" &&\\n            hasOwn.call(value, \\\"__await\\\")) {\\n          return PromiseImpl.resolve(value.__await).then(function(value) {\\n            invoke(\\\"next\\\", value, resolve, reject);\\n          }, function(err) {\\n            invoke(\\\"throw\\\", err, resolve, reject);\\n          });\\n        }\\n\\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\\n          // When a yielded Promise is resolved, its final value becomes\\n          // the .value of the Promise<{value,done}> result for the\\n          // current iteration.\\n          result.value = unwrapped;\\n          resolve(result);\\n        }, function(error) {\\n          // If a rejected Promise was yielded, throw the rejection back\\n          // into the async generator function so it can be handled there.\\n          return invoke(\\\"throw\\\", error, resolve, reject);\\n        });\\n      }\\n    }\\n\\n    var previousPromise;\\n\\n    function enqueue(method, arg) {\\n      function callInvokeWithMethodAndArg() {\\n        return new PromiseImpl(function(resolve, reject) {\\n          invoke(method, arg, resolve, reject);\\n        });\\n      }\\n\\n      return previousPromise =\\n        // If enqueue has been called before, then we want to wait until\\n        // all previous Promises have been resolved before calling invoke,\\n        // so that results are always delivered in the correct order. If\\n        // enqueue has not been called before, then it is important to\\n        // call invoke immediately, without waiting on a callback to fire,\\n        // so that the async generator function has the opportunity to do\\n        // any necessary setup in a predictable way. This predictability\\n        // is why the Promise constructor synchronously invokes its\\n        // executor callback, and why async functions synchronously\\n        // execute code before the first await. Since we implement simple\\n        // async functions in terms of async generators, it is especially\\n        // important to get this right, even though it requires care.\\n        previousPromise ? previousPromise.then(\\n          callInvokeWithMethodAndArg,\\n          // Avoid propagating failures to Promises returned by later\\n          // invocations of the iterator.\\n          callInvokeWithMethodAndArg\\n        ) : callInvokeWithMethodAndArg();\\n    }\\n\\n    // Define the unified helper method that is used to implement .next,\\n    // .throw, and .return (see defineIteratorMethods).\\n    this._invoke = enqueue;\\n  }\\n\\n  defineIteratorMethods(AsyncIterator.prototype);\\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\\n    return this;\\n  });\\n  exports.AsyncIterator = AsyncIterator;\\n\\n  // Note that simple async functions are implemented on top of\\n  // AsyncIterator objects; they just return a Promise for the value of\\n  // the final result produced by the iterator.\\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\\n\\n    var iter = new AsyncIterator(\\n      wrap(innerFn, outerFn, self, tryLocsList),\\n      PromiseImpl\\n    );\\n\\n    return exports.isGeneratorFunction(outerFn)\\n      ? iter // If outerFn is a generator, return the full iterator.\\n      : iter.next().then(function(result) {\\n          return result.done ? result.value : iter.next();\\n        });\\n  };\\n\\n  function makeInvokeMethod(innerFn, self, context) {\\n    var state = GenStateSuspendedStart;\\n\\n    return function invoke(method, arg) {\\n      if (state === GenStateExecuting) {\\n        throw new Error(\\\"Generator is already running\\\");\\n      }\\n\\n      if (state === GenStateCompleted) {\\n        if (method === \\\"throw\\\") {\\n          throw arg;\\n        }\\n\\n        // Be forgiving, per 25.3.3.3.3 of the spec:\\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\\n        return doneResult();\\n      }\\n\\n      context.method = method;\\n      context.arg = arg;\\n\\n      while (true) {\\n        var delegate = context.delegate;\\n        if (delegate) {\\n          var delegateResult = maybeInvokeDelegate(delegate, context);\\n          if (delegateResult) {\\n            if (delegateResult === ContinueSentinel) continue;\\n            return delegateResult;\\n          }\\n        }\\n\\n        if (context.method === \\\"next\\\") {\\n          // Setting context._sent for legacy support of Babel's\\n          // function.sent implementation.\\n          context.sent = context._sent = context.arg;\\n\\n        } else if (context.method === \\\"throw\\\") {\\n          if (state === GenStateSuspendedStart) {\\n            state = GenStateCompleted;\\n            throw context.arg;\\n          }\\n\\n          context.dispatchException(context.arg);\\n\\n        } else if (context.method === \\\"return\\\") {\\n          context.abrupt(\\\"return\\\", context.arg);\\n        }\\n\\n        state = GenStateExecuting;\\n\\n        var record = tryCatch(innerFn, self, context);\\n        if (record.type === \\\"normal\\\") {\\n          // If an exception is thrown from innerFn, we leave state ===\\n          // GenStateExecuting and loop back for another invocation.\\n          state = context.done\\n            ? GenStateCompleted\\n            : GenStateSuspendedYield;\\n\\n          if (record.arg === ContinueSentinel) {\\n            continue;\\n          }\\n\\n          return {\\n            value: record.arg,\\n            done: context.done\\n          };\\n\\n        } else if (record.type === \\\"throw\\\") {\\n          state = GenStateCompleted;\\n          // Dispatch the exception by looping back around to the\\n          // context.dispatchException(context.arg) call above.\\n          context.method = \\\"throw\\\";\\n          context.arg = record.arg;\\n        }\\n      }\\n    };\\n  }\\n\\n  // Call delegate.iterator[context.method](context.arg) and handle the\\n  // result, either by returning a { value, done } result from the\\n  // delegate iterator, or by modifying context.method and context.arg,\\n  // setting context.delegate to null, and returning the ContinueSentinel.\\n  function maybeInvokeDelegate(delegate, context) {\\n    var method = delegate.iterator[context.method];\\n    if (method === undefined) {\\n      // A .throw or .return when the delegate iterator has no .throw\\n      // method always terminates the yield* loop.\\n      context.delegate = null;\\n\\n      if (context.method === \\\"throw\\\") {\\n        // Note: [\\\"return\\\"] must be used for ES3 parsing compatibility.\\n        if (delegate.iterator[\\\"return\\\"]) {\\n          // If the delegate iterator has a return method, give it a\\n          // chance to clean up.\\n          context.method = \\\"return\\\";\\n          context.arg = undefined;\\n          maybeInvokeDelegate(delegate, context);\\n\\n          if (context.method === \\\"throw\\\") {\\n            // If maybeInvokeDelegate(context) changed context.method from\\n            // \\\"return\\\" to \\\"throw\\\", let that override the TypeError below.\\n            return ContinueSentinel;\\n          }\\n        }\\n\\n        context.method = \\\"throw\\\";\\n        context.arg = new TypeError(\\n          \\\"The iterator does not provide a 'throw' method\\\");\\n      }\\n\\n      return ContinueSentinel;\\n    }\\n\\n    var record = tryCatch(method, delegate.iterator, context.arg);\\n\\n    if (record.type === \\\"throw\\\") {\\n      context.method = \\\"throw\\\";\\n      context.arg = record.arg;\\n      context.delegate = null;\\n      return ContinueSentinel;\\n    }\\n\\n    var info = record.arg;\\n\\n    if (! info) {\\n      context.method = \\\"throw\\\";\\n      context.arg = new TypeError(\\\"iterator result is not an object\\\");\\n      context.delegate = null;\\n      return ContinueSentinel;\\n    }\\n\\n    if (info.done) {\\n      // Assign the result of the finished delegate to the temporary\\n      // variable specified by delegate.resultName (see delegateYield).\\n      context[delegate.resultName] = info.value;\\n\\n      // Resume execution at the desired location (see delegateYield).\\n      context.next = delegate.nextLoc;\\n\\n      // If context.method was \\\"throw\\\" but the delegate handled the\\n      // exception, let the outer generator proceed normally. If\\n      // context.method was \\\"next\\\", forget context.arg since it has been\\n      // \\\"consumed\\\" by the delegate iterator. If context.method was\\n      // \\\"return\\\", allow the original .return call to continue in the\\n      // outer generator.\\n      if (context.method !== \\\"return\\\") {\\n        context.method = \\\"next\\\";\\n        context.arg = undefined;\\n      }\\n\\n    } else {\\n      // Re-yield the result returned by the delegate method.\\n      return info;\\n    }\\n\\n    // The delegate iterator is finished, so forget it and continue with\\n    // the outer generator.\\n    context.delegate = null;\\n    return ContinueSentinel;\\n  }\\n\\n  // Define Generator.prototype.{next,throw,return} in terms of the\\n  // unified ._invoke helper method.\\n  defineIteratorMethods(Gp);\\n\\n  define(Gp, toStringTagSymbol, \\\"Generator\\\");\\n\\n  // A Generator should always return itself as the iterator object when the\\n  // @@iterator function is called on it. Some browsers' implementations of the\\n  // iterator prototype chain incorrectly implement this, causing the Generator\\n  // object to not be returned from this call. This ensures that doesn't happen.\\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\\n  define(Gp, iteratorSymbol, function() {\\n    return this;\\n  });\\n\\n  define(Gp, \\\"toString\\\", function() {\\n    return \\\"[object Generator]\\\";\\n  });\\n\\n  function pushTryEntry(locs) {\\n    var entry = { tryLoc: locs[0] };\\n\\n    if (1 in locs) {\\n      entry.catchLoc = locs[1];\\n    }\\n\\n    if (2 in locs) {\\n      entry.finallyLoc = locs[2];\\n      entry.afterLoc = locs[3];\\n    }\\n\\n    this.tryEntries.push(entry);\\n  }\\n\\n  function resetTryEntry(entry) {\\n    var record = entry.completion || {};\\n    record.type = \\\"normal\\\";\\n    delete record.arg;\\n    entry.completion = record;\\n  }\\n\\n  function Context(tryLocsList) {\\n    // The root entry object (effectively a try statement without a catch\\n    // or a finally block) gives us a place to store values thrown from\\n    // locations where there is no enclosing try statement.\\n    this.tryEntries = [{ tryLoc: \\\"root\\\" }];\\n    tryLocsList.forEach(pushTryEntry, this);\\n    this.reset(true);\\n  }\\n\\n  exports.keys = function(object) {\\n    var keys = [];\\n    for (var key in object) {\\n      keys.push(key);\\n    }\\n    keys.reverse();\\n\\n    // Rather than returning an object with a next method, we keep\\n    // things simple and return the next function itself.\\n    return function next() {\\n      while (keys.length) {\\n        var key = keys.pop();\\n        if (key in object) {\\n          next.value = key;\\n          next.done = false;\\n          return next;\\n        }\\n      }\\n\\n      // To avoid creating an additional object, we just hang the .value\\n      // and .done properties off the next function object itself. This\\n      // also ensures that the minifier will not anonymize the function.\\n      next.done = true;\\n      return next;\\n    };\\n  };\\n\\n  function values(iterable) {\\n    if (iterable) {\\n      var iteratorMethod = iterable[iteratorSymbol];\\n      if (iteratorMethod) {\\n        return iteratorMethod.call(iterable);\\n      }\\n\\n      if (typeof iterable.next === \\\"function\\\") {\\n        return iterable;\\n      }\\n\\n      if (!isNaN(iterable.length)) {\\n        var i = -1, next = function next() {\\n          while (++i < iterable.length) {\\n            if (hasOwn.call(iterable, i)) {\\n              next.value = iterable[i];\\n              next.done = false;\\n              return next;\\n            }\\n          }\\n\\n          next.value = undefined;\\n          next.done = true;\\n\\n          return next;\\n        };\\n\\n        return next.next = next;\\n      }\\n    }\\n\\n    // Return an iterator with no values.\\n    return { next: doneResult };\\n  }\\n  exports.values = values;\\n\\n  function doneResult() {\\n    return { value: undefined, done: true };\\n  }\\n\\n  Context.prototype = {\\n    constructor: Context,\\n\\n    reset: function(skipTempReset) {\\n      this.prev = 0;\\n      this.next = 0;\\n      // Resetting context._sent for legacy support of Babel's\\n      // function.sent implementation.\\n      this.sent = this._sent = undefined;\\n      this.done = false;\\n      this.delegate = null;\\n\\n      this.method = \\\"next\\\";\\n      this.arg = undefined;\\n\\n      this.tryEntries.forEach(resetTryEntry);\\n\\n      if (!skipTempReset) {\\n        for (var name in this) {\\n          // Not sure about the optimal order of these conditions:\\n          if (name.charAt(0) === \\\"t\\\" &&\\n              hasOwn.call(this, name) &&\\n              !isNaN(+name.slice(1))) {\\n            this[name] = undefined;\\n          }\\n        }\\n      }\\n    },\\n\\n    stop: function() {\\n      this.done = true;\\n\\n      var rootEntry = this.tryEntries[0];\\n      var rootRecord = rootEntry.completion;\\n      if (rootRecord.type === \\\"throw\\\") {\\n        throw rootRecord.arg;\\n      }\\n\\n      return this.rval;\\n    },\\n\\n    dispatchException: function(exception) {\\n      if (this.done) {\\n        throw exception;\\n      }\\n\\n      var context = this;\\n      function handle(loc, caught) {\\n        record.type = \\\"throw\\\";\\n        record.arg = exception;\\n        context.next = loc;\\n\\n        if (caught) {\\n          // If the dispatched exception was caught by a catch block,\\n          // then let that catch block handle the exception normally.\\n          context.method = \\\"next\\\";\\n          context.arg = undefined;\\n        }\\n\\n        return !! caught;\\n      }\\n\\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\\n        var entry = this.tryEntries[i];\\n        var record = entry.completion;\\n\\n        if (entry.tryLoc === \\\"root\\\") {\\n          // Exception thrown outside of any try block that could handle\\n          // it, so set the completion value of the entire function to\\n          // throw the exception.\\n          return handle(\\\"end\\\");\\n        }\\n\\n        if (entry.tryLoc <= this.prev) {\\n          var hasCatch = hasOwn.call(entry, \\\"catchLoc\\\");\\n          var hasFinally = hasOwn.call(entry, \\\"finallyLoc\\\");\\n\\n          if (hasCatch && hasFinally) {\\n            if (this.prev < entry.catchLoc) {\\n              return handle(entry.catchLoc, true);\\n            } else if (this.prev < entry.finallyLoc) {\\n              return handle(entry.finallyLoc);\\n            }\\n\\n          } else if (hasCatch) {\\n            if (this.prev < entry.catchLoc) {\\n              return handle(entry.catchLoc, true);\\n            }\\n\\n          } else if (hasFinally) {\\n            if (this.prev < entry.finallyLoc) {\\n              return handle(entry.finallyLoc);\\n            }\\n\\n          } else {\\n            throw new Error(\\\"try statement without catch or finally\\\");\\n          }\\n        }\\n      }\\n    },\\n\\n    abrupt: function(type, arg) {\\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\\n        var entry = this.tryEntries[i];\\n        if (entry.tryLoc <= this.prev &&\\n            hasOwn.call(entry, \\\"finallyLoc\\\") &&\\n            this.prev < entry.finallyLoc) {\\n          var finallyEntry = entry;\\n          break;\\n        }\\n      }\\n\\n      if (finallyEntry &&\\n          (type === \\\"break\\\" ||\\n           type === \\\"continue\\\") &&\\n          finallyEntry.tryLoc <= arg &&\\n          arg <= finallyEntry.finallyLoc) {\\n        // Ignore the finally entry if control is not jumping to a\\n        // location outside the try/catch block.\\n        finallyEntry = null;\\n      }\\n\\n      var record = finallyEntry ? finallyEntry.completion : {};\\n      record.type = type;\\n      record.arg = arg;\\n\\n      if (finallyEntry) {\\n        this.method = \\\"next\\\";\\n        this.next = finallyEntry.finallyLoc;\\n        return ContinueSentinel;\\n      }\\n\\n      return this.complete(record);\\n    },\\n\\n    complete: function(record, afterLoc) {\\n      if (record.type === \\\"throw\\\") {\\n        throw record.arg;\\n      }\\n\\n      if (record.type === \\\"break\\\" ||\\n          record.type === \\\"continue\\\") {\\n        this.next = record.arg;\\n      } else if (record.type === \\\"return\\\") {\\n        this.rval = this.arg = record.arg;\\n        this.method = \\\"return\\\";\\n        this.next = \\\"end\\\";\\n      } else if (record.type === \\\"normal\\\" && afterLoc) {\\n        this.next = afterLoc;\\n      }\\n\\n      return ContinueSentinel;\\n    },\\n\\n    finish: function(finallyLoc) {\\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\\n        var entry = this.tryEntries[i];\\n        if (entry.finallyLoc === finallyLoc) {\\n          this.complete(entry.completion, entry.afterLoc);\\n          resetTryEntry(entry);\\n          return ContinueSentinel;\\n        }\\n      }\\n    },\\n\\n    \\\"catch\\\": function(tryLoc) {\\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\\n        var entry = this.tryEntries[i];\\n        if (entry.tryLoc === tryLoc) {\\n          var record = entry.completion;\\n          if (record.type === \\\"throw\\\") {\\n            var thrown = record.arg;\\n            resetTryEntry(entry);\\n          }\\n          return thrown;\\n        }\\n      }\\n\\n      // The context.catch method must only be called with a location\\n      // argument that corresponds to a known catch block.\\n      throw new Error(\\\"illegal catch attempt\\\");\\n    },\\n\\n    delegateYield: function(iterable, resultName, nextLoc) {\\n      this.delegate = {\\n        iterator: values(iterable),\\n        resultName: resultName,\\n        nextLoc: nextLoc\\n      };\\n\\n      if (this.method === \\\"next\\\") {\\n        // Deliberately forget the last sent value so that we don't\\n        // accidentally pass it on to the delegate.\\n        this.arg = undefined;\\n      }\\n\\n      return ContinueSentinel;\\n    }\\n  };\\n\\n  // Regardless of whether this script is executing as a CommonJS module\\n  // or not, return the runtime object so that we can declare the variable\\n  // regeneratorRuntime in the outer scope, which allows this module to be\\n  // injected easily by `bin/regenerator --include-runtime script.js`.\\n  return exports;\\n\\n}(\\n  // If this script is executing as a CommonJS module, use module.exports\\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\\n  // object. Either way, the resulting object will be used to initialize\\n  // the regeneratorRuntime variable at the top of this file.\\n   true ? module.exports : 0\\n));\\n\\ntry {\\n  regeneratorRuntime = runtime;\\n} catch (accidentalStrictMode) {\\n  // This module should not be running in strict mode, so the above\\n  // assignment should always work unless something is misconfigured. Just\\n  // in case runtime.js accidentally runs in strict mode, in modern engines\\n  // we can explicitly access globalThis. In older engines we can escape\\n  // strict mode using a global Function call. This could conceivably fail\\n  // if a Content Security Policy forbids using Function, but in that case\\n  // the proper solution is to fix the accidental strict mode problem. If\\n  // you've misconfigured your bundler to force strict mode and applied a\\n  // CSP to forbid Function, and you're not willing to fix either of those\\n  // problems, please detail your unique predicament in a GitHub issue.\\n  if (typeof globalThis === \\\"object\\\") {\\n    globalThis.regeneratorRuntime = runtime;\\n  } else {\\n    Function(\\\"r\\\", \\\"regeneratorRuntime = r\\\")(runtime);\\n  }\\n}\\n\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/regenerator-runtime/runtime.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/NotificationFactories.js\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/NotificationFactories.js ***!\n  \\***********************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"COMPLETE_NOTIFICATION\\\": () => (/* binding */ COMPLETE_NOTIFICATION),\\n/* harmony export */   \\\"errorNotification\\\": () => (/* binding */ errorNotification),\\n/* harmony export */   \\\"nextNotification\\\": () => (/* binding */ nextNotification),\\n/* harmony export */   \\\"createNotification\\\": () => (/* binding */ createNotification)\\n/* harmony export */ });\\nvar COMPLETE_NOTIFICATION = (function () { return createNotification('C', undefined, undefined); })();\\nfunction errorNotification(error) {\\n    return createNotification('E', undefined, error);\\n}\\nfunction nextNotification(value) {\\n    return createNotification('N', value, undefined);\\n}\\nfunction createNotification(kind, value, error) {\\n    return {\\n        kind: kind,\\n        value: value,\\n        error: error,\\n    };\\n}\\n//# sourceMappingURL=NotificationFactories.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/NotificationFactories.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/Observable.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/Observable.js ***!\n  \\************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"Observable\\\": () => (/* binding */ Observable)\\n/* harmony export */ });\\n/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Subscriber */ \\\"./node_modules/rxjs/dist/esm5/internal/Subscriber.js\\\");\\n/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Subscription */ \\\"./node_modules/rxjs/dist/esm5/internal/Subscription.js\\\");\\n/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./symbol/observable */ \\\"./node_modules/rxjs/dist/esm5/internal/symbol/observable.js\\\");\\n/* harmony import */ var _util_pipe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/pipe */ \\\"./node_modules/rxjs/dist/esm5/internal/util/pipe.js\\\");\\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./config */ \\\"./node_modules/rxjs/dist/esm5/internal/config.js\\\");\\n/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util/isFunction */ \\\"./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\\\");\\n/* harmony import */ var _util_errorContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/errorContext */ \\\"./node_modules/rxjs/dist/esm5/internal/util/errorContext.js\\\");\\n\\n\\n\\n\\n\\n\\n\\nvar Observable = (function () {\\n    function Observable(subscribe) {\\n        if (subscribe) {\\n            this._subscribe = subscribe;\\n        }\\n    }\\n    Observable.prototype.lift = function (operator) {\\n        var observable = new Observable();\\n        observable.source = this;\\n        observable.operator = operator;\\n        return observable;\\n    };\\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\\n        var _this = this;\\n        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new _Subscriber__WEBPACK_IMPORTED_MODULE_0__.SafeSubscriber(observerOrNext, error, complete);\\n        (0,_util_errorContext__WEBPACK_IMPORTED_MODULE_1__.errorContext)(function () {\\n            var _a = _this, operator = _a.operator, source = _a.source;\\n            subscriber.add(operator\\n                ?\\n                    operator.call(subscriber, source)\\n                : source\\n                    ?\\n                        _this._subscribe(subscriber)\\n                    :\\n                        _this._trySubscribe(subscriber));\\n        });\\n        return subscriber;\\n    };\\n    Observable.prototype._trySubscribe = function (sink) {\\n        try {\\n            return this._subscribe(sink);\\n        }\\n        catch (err) {\\n            sink.error(err);\\n        }\\n    };\\n    Observable.prototype.forEach = function (next, promiseCtor) {\\n        var _this = this;\\n        promiseCtor = getPromiseCtor(promiseCtor);\\n        return new promiseCtor(function (resolve, reject) {\\n            var subscription;\\n            subscription = _this.subscribe(function (value) {\\n                try {\\n                    next(value);\\n                }\\n                catch (err) {\\n                    reject(err);\\n                    subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();\\n                }\\n            }, reject, resolve);\\n        });\\n    };\\n    Observable.prototype._subscribe = function (subscriber) {\\n        var _a;\\n        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);\\n    };\\n    Observable.prototype[_symbol_observable__WEBPACK_IMPORTED_MODULE_2__.observable] = function () {\\n        return this;\\n    };\\n    Observable.prototype.pipe = function () {\\n        var operations = [];\\n        for (var _i = 0; _i < arguments.length; _i++) {\\n            operations[_i] = arguments[_i];\\n        }\\n        return (0,_util_pipe__WEBPACK_IMPORTED_MODULE_3__.pipeFromArray)(operations)(this);\\n    };\\n    Observable.prototype.toPromise = function (promiseCtor) {\\n        var _this = this;\\n        promiseCtor = getPromiseCtor(promiseCtor);\\n        return new promiseCtor(function (resolve, reject) {\\n            var value;\\n            _this.subscribe(function (x) { return (value = x); }, function (err) { return reject(err); }, function () { return resolve(value); });\\n        });\\n    };\\n    Observable.create = function (subscribe) {\\n        return new Observable(subscribe);\\n    };\\n    return Observable;\\n}());\\n\\nfunction getPromiseCtor(promiseCtor) {\\n    var _a;\\n    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : _config__WEBPACK_IMPORTED_MODULE_4__.config.Promise) !== null && _a !== void 0 ? _a : Promise;\\n}\\nfunction isObserver(value) {\\n    return value && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_5__.isFunction)(value.next) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_5__.isFunction)(value.error) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_5__.isFunction)(value.complete);\\n}\\nfunction isSubscriber(value) {\\n    return (value && value instanceof _Subscriber__WEBPACK_IMPORTED_MODULE_0__.Subscriber) || (isObserver(value) && (0,_Subscription__WEBPACK_IMPORTED_MODULE_6__.isSubscription)(value));\\n}\\n//# sourceMappingURL=Observable.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/Observable.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/Subject.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/Subject.js ***!\n  \\*********************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"Subject\\\": () => (/* binding */ Subject),\\n/* harmony export */   \\\"AnonymousSubject\\\": () => (/* binding */ AnonymousSubject)\\n/* harmony export */ });\\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \\\"./node_modules/rxjs/node_modules/tslib/tslib.es6.js\\\");\\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Observable */ \\\"./node_modules/rxjs/dist/esm5/internal/Observable.js\\\");\\n/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Subscription */ \\\"./node_modules/rxjs/dist/esm5/internal/Subscription.js\\\");\\n/* harmony import */ var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/ObjectUnsubscribedError */ \\\"./node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js\\\");\\n/* harmony import */ var _util_arrRemove__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util/arrRemove */ \\\"./node_modules/rxjs/dist/esm5/internal/util/arrRemove.js\\\");\\n/* harmony import */ var _util_errorContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/errorContext */ \\\"./node_modules/rxjs/dist/esm5/internal/util/errorContext.js\\\");\\n\\n\\n\\n\\n\\n\\nvar Subject = (function (_super) {\\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(Subject, _super);\\n    function Subject() {\\n        var _this = _super.call(this) || this;\\n        _this.closed = false;\\n        _this.observers = [];\\n        _this.isStopped = false;\\n        _this.hasError = false;\\n        _this.thrownError = null;\\n        return _this;\\n    }\\n    Subject.prototype.lift = function (operator) {\\n        var subject = new AnonymousSubject(this, this);\\n        subject.operator = operator;\\n        return subject;\\n    };\\n    Subject.prototype._throwIfClosed = function () {\\n        if (this.closed) {\\n            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_1__.ObjectUnsubscribedError();\\n        }\\n    };\\n    Subject.prototype.next = function (value) {\\n        var _this = this;\\n        (0,_util_errorContext__WEBPACK_IMPORTED_MODULE_2__.errorContext)(function () {\\n            var e_1, _a;\\n            _this._throwIfClosed();\\n            if (!_this.isStopped) {\\n                var copy = _this.observers.slice();\\n                try {\\n                    for (var copy_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__values)(copy), copy_1_1 = copy_1.next(); !copy_1_1.done; copy_1_1 = copy_1.next()) {\\n                        var observer = copy_1_1.value;\\n                        observer.next(value);\\n                    }\\n                }\\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\\n                finally {\\n                    try {\\n                        if (copy_1_1 && !copy_1_1.done && (_a = copy_1.return)) _a.call(copy_1);\\n                    }\\n                    finally { if (e_1) throw e_1.error; }\\n                }\\n            }\\n        });\\n    };\\n    Subject.prototype.error = function (err) {\\n        var _this = this;\\n        (0,_util_errorContext__WEBPACK_IMPORTED_MODULE_2__.errorContext)(function () {\\n            _this._throwIfClosed();\\n            if (!_this.isStopped) {\\n                _this.hasError = _this.isStopped = true;\\n                _this.thrownError = err;\\n                var observers = _this.observers;\\n                while (observers.length) {\\n                    observers.shift().error(err);\\n                }\\n            }\\n        });\\n    };\\n    Subject.prototype.complete = function () {\\n        var _this = this;\\n        (0,_util_errorContext__WEBPACK_IMPORTED_MODULE_2__.errorContext)(function () {\\n            _this._throwIfClosed();\\n            if (!_this.isStopped) {\\n                _this.isStopped = true;\\n                var observers = _this.observers;\\n                while (observers.length) {\\n                    observers.shift().complete();\\n                }\\n            }\\n        });\\n    };\\n    Subject.prototype.unsubscribe = function () {\\n        this.isStopped = this.closed = true;\\n        this.observers = null;\\n    };\\n    Object.defineProperty(Subject.prototype, \\\"observed\\\", {\\n        get: function () {\\n            var _a;\\n            return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;\\n        },\\n        enumerable: false,\\n        configurable: true\\n    });\\n    Subject.prototype._trySubscribe = function (subscriber) {\\n        this._throwIfClosed();\\n        return _super.prototype._trySubscribe.call(this, subscriber);\\n    };\\n    Subject.prototype._subscribe = function (subscriber) {\\n        this._throwIfClosed();\\n        this._checkFinalizedStatuses(subscriber);\\n        return this._innerSubscribe(subscriber);\\n    };\\n    Subject.prototype._innerSubscribe = function (subscriber) {\\n        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;\\n        return hasError || isStopped\\n            ? _Subscription__WEBPACK_IMPORTED_MODULE_3__.EMPTY_SUBSCRIPTION\\n            : (observers.push(subscriber), new _Subscription__WEBPACK_IMPORTED_MODULE_3__.Subscription(function () { return (0,_util_arrRemove__WEBPACK_IMPORTED_MODULE_4__.arrRemove)(observers, subscriber); }));\\n    };\\n    Subject.prototype._checkFinalizedStatuses = function (subscriber) {\\n        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;\\n        if (hasError) {\\n            subscriber.error(thrownError);\\n        }\\n        else if (isStopped) {\\n            subscriber.complete();\\n        }\\n    };\\n    Subject.prototype.asObservable = function () {\\n        var observable = new _Observable__WEBPACK_IMPORTED_MODULE_5__.Observable();\\n        observable.source = this;\\n        return observable;\\n    };\\n    Subject.create = function (destination, source) {\\n        return new AnonymousSubject(destination, source);\\n    };\\n    return Subject;\\n}(_Observable__WEBPACK_IMPORTED_MODULE_5__.Observable));\\n\\nvar AnonymousSubject = (function (_super) {\\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(AnonymousSubject, _super);\\n    function AnonymousSubject(destination, source) {\\n        var _this = _super.call(this) || this;\\n        _this.destination = destination;\\n        _this.source = source;\\n        return _this;\\n    }\\n    AnonymousSubject.prototype.next = function (value) {\\n        var _a, _b;\\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);\\n    };\\n    AnonymousSubject.prototype.error = function (err) {\\n        var _a, _b;\\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);\\n    };\\n    AnonymousSubject.prototype.complete = function () {\\n        var _a, _b;\\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);\\n    };\\n    AnonymousSubject.prototype._subscribe = function (subscriber) {\\n        var _a, _b;\\n        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : _Subscription__WEBPACK_IMPORTED_MODULE_3__.EMPTY_SUBSCRIPTION;\\n    };\\n    return AnonymousSubject;\\n}(Subject));\\n\\n//# sourceMappingURL=Subject.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/Subject.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/Subscriber.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/Subscriber.js ***!\n  \\************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"Subscriber\\\": () => (/* binding */ Subscriber),\\n/* harmony export */   \\\"SafeSubscriber\\\": () => (/* binding */ SafeSubscriber),\\n/* harmony export */   \\\"EMPTY_OBSERVER\\\": () => (/* binding */ EMPTY_OBSERVER)\\n/* harmony export */ });\\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \\\"./node_modules/rxjs/node_modules/tslib/tslib.es6.js\\\");\\n/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/isFunction */ \\\"./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\\\");\\n/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Subscription */ \\\"./node_modules/rxjs/dist/esm5/internal/Subscription.js\\\");\\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./config */ \\\"./node_modules/rxjs/dist/esm5/internal/config.js\\\");\\n/* harmony import */ var _util_reportUnhandledError__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./util/reportUnhandledError */ \\\"./node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js\\\");\\n/* harmony import */ var _util_noop__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util/noop */ \\\"./node_modules/rxjs/dist/esm5/internal/util/noop.js\\\");\\n/* harmony import */ var _NotificationFactories__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./NotificationFactories */ \\\"./node_modules/rxjs/dist/esm5/internal/NotificationFactories.js\\\");\\n/* harmony import */ var _scheduler_timeoutProvider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./scheduler/timeoutProvider */ \\\"./node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js\\\");\\n/* harmony import */ var _util_errorContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util/errorContext */ \\\"./node_modules/rxjs/dist/esm5/internal/util/errorContext.js\\\");\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar Subscriber = (function (_super) {\\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(Subscriber, _super);\\n    function Subscriber(destination) {\\n        var _this = _super.call(this) || this;\\n        _this.isStopped = false;\\n        if (destination) {\\n            _this.destination = destination;\\n            if ((0,_Subscription__WEBPACK_IMPORTED_MODULE_1__.isSubscription)(destination)) {\\n                destination.add(_this);\\n            }\\n        }\\n        else {\\n            _this.destination = EMPTY_OBSERVER;\\n        }\\n        return _this;\\n    }\\n    Subscriber.create = function (next, error, complete) {\\n        return new SafeSubscriber(next, error, complete);\\n    };\\n    Subscriber.prototype.next = function (value) {\\n        if (this.isStopped) {\\n            handleStoppedNotification((0,_NotificationFactories__WEBPACK_IMPORTED_MODULE_2__.nextNotification)(value), this);\\n        }\\n        else {\\n            this._next(value);\\n        }\\n    };\\n    Subscriber.prototype.error = function (err) {\\n        if (this.isStopped) {\\n            handleStoppedNotification((0,_NotificationFactories__WEBPACK_IMPORTED_MODULE_2__.errorNotification)(err), this);\\n        }\\n        else {\\n            this.isStopped = true;\\n            this._error(err);\\n        }\\n    };\\n    Subscriber.prototype.complete = function () {\\n        if (this.isStopped) {\\n            handleStoppedNotification(_NotificationFactories__WEBPACK_IMPORTED_MODULE_2__.COMPLETE_NOTIFICATION, this);\\n        }\\n        else {\\n            this.isStopped = true;\\n            this._complete();\\n        }\\n    };\\n    Subscriber.prototype.unsubscribe = function () {\\n        if (!this.closed) {\\n            this.isStopped = true;\\n            _super.prototype.unsubscribe.call(this);\\n            this.destination = null;\\n        }\\n    };\\n    Subscriber.prototype._next = function (value) {\\n        this.destination.next(value);\\n    };\\n    Subscriber.prototype._error = function (err) {\\n        try {\\n            this.destination.error(err);\\n        }\\n        finally {\\n            this.unsubscribe();\\n        }\\n    };\\n    Subscriber.prototype._complete = function () {\\n        try {\\n            this.destination.complete();\\n        }\\n        finally {\\n            this.unsubscribe();\\n        }\\n    };\\n    return Subscriber;\\n}(_Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription));\\n\\nvar SafeSubscriber = (function (_super) {\\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(SafeSubscriber, _super);\\n    function SafeSubscriber(observerOrNext, error, complete) {\\n        var _this = _super.call(this) || this;\\n        var next;\\n        if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_3__.isFunction)(observerOrNext)) {\\n            next = observerOrNext;\\n        }\\n        else if (observerOrNext) {\\n            (next = observerOrNext.next, error = observerOrNext.error, complete = observerOrNext.complete);\\n            var context_1;\\n            if (_this && _config__WEBPACK_IMPORTED_MODULE_4__.config.useDeprecatedNextContext) {\\n                context_1 = Object.create(observerOrNext);\\n                context_1.unsubscribe = function () { return _this.unsubscribe(); };\\n            }\\n            else {\\n                context_1 = observerOrNext;\\n            }\\n            next = next === null || next === void 0 ? void 0 : next.bind(context_1);\\n            error = error === null || error === void 0 ? void 0 : error.bind(context_1);\\n            complete = complete === null || complete === void 0 ? void 0 : complete.bind(context_1);\\n        }\\n        _this.destination = {\\n            next: next ? wrapForErrorHandling(next, _this) : _util_noop__WEBPACK_IMPORTED_MODULE_5__.noop,\\n            error: wrapForErrorHandling(error !== null && error !== void 0 ? error : defaultErrorHandler, _this),\\n            complete: complete ? wrapForErrorHandling(complete, _this) : _util_noop__WEBPACK_IMPORTED_MODULE_5__.noop,\\n        };\\n        return _this;\\n    }\\n    return SafeSubscriber;\\n}(Subscriber));\\n\\nfunction wrapForErrorHandling(handler, instance) {\\n    return function () {\\n        var args = [];\\n        for (var _i = 0; _i < arguments.length; _i++) {\\n            args[_i] = arguments[_i];\\n        }\\n        try {\\n            handler.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)([], (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(args)));\\n        }\\n        catch (err) {\\n            if (_config__WEBPACK_IMPORTED_MODULE_4__.config.useDeprecatedSynchronousErrorHandling) {\\n                (0,_util_errorContext__WEBPACK_IMPORTED_MODULE_6__.captureError)(err);\\n            }\\n            else {\\n                (0,_util_reportUnhandledError__WEBPACK_IMPORTED_MODULE_7__.reportUnhandledError)(err);\\n            }\\n        }\\n    };\\n}\\nfunction defaultErrorHandler(err) {\\n    throw err;\\n}\\nfunction handleStoppedNotification(notification, subscriber) {\\n    var onStoppedNotification = _config__WEBPACK_IMPORTED_MODULE_4__.config.onStoppedNotification;\\n    onStoppedNotification && _scheduler_timeoutProvider__WEBPACK_IMPORTED_MODULE_8__.timeoutProvider.setTimeout(function () { return onStoppedNotification(notification, subscriber); });\\n}\\nvar EMPTY_OBSERVER = {\\n    closed: true,\\n    next: _util_noop__WEBPACK_IMPORTED_MODULE_5__.noop,\\n    error: defaultErrorHandler,\\n    complete: _util_noop__WEBPACK_IMPORTED_MODULE_5__.noop,\\n};\\n//# sourceMappingURL=Subscriber.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/Subscriber.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/Subscription.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/Subscription.js ***!\n  \\**************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"Subscription\\\": () => (/* binding */ Subscription),\\n/* harmony export */   \\\"EMPTY_SUBSCRIPTION\\\": () => (/* binding */ EMPTY_SUBSCRIPTION),\\n/* harmony export */   \\\"isSubscription\\\": () => (/* binding */ isSubscription)\\n/* harmony export */ });\\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \\\"./node_modules/rxjs/node_modules/tslib/tslib.es6.js\\\");\\n/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/isFunction */ \\\"./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\\\");\\n/* harmony import */ var _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/UnsubscriptionError */ \\\"./node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js\\\");\\n/* harmony import */ var _util_arrRemove__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/arrRemove */ \\\"./node_modules/rxjs/dist/esm5/internal/util/arrRemove.js\\\");\\n\\n\\n\\n\\nvar Subscription = (function () {\\n    function Subscription(initialTeardown) {\\n        this.initialTeardown = initialTeardown;\\n        this.closed = false;\\n        this._parentage = null;\\n        this._teardowns = null;\\n    }\\n    Subscription.prototype.unsubscribe = function () {\\n        var e_1, _a, e_2, _b;\\n        var errors;\\n        if (!this.closed) {\\n            this.closed = true;\\n            var _parentage = this._parentage;\\n            if (_parentage) {\\n                this._parentage = null;\\n                if (Array.isArray(_parentage)) {\\n                    try {\\n                        for (var _parentage_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__values)(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {\\n                            var parent_1 = _parentage_1_1.value;\\n                            parent_1.remove(this);\\n                        }\\n                    }\\n                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\\n                    finally {\\n                        try {\\n                            if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);\\n                        }\\n                        finally { if (e_1) throw e_1.error; }\\n                    }\\n                }\\n                else {\\n                    _parentage.remove(this);\\n                }\\n            }\\n            var initialTeardown = this.initialTeardown;\\n            if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(initialTeardown)) {\\n                try {\\n                    initialTeardown();\\n                }\\n                catch (e) {\\n                    errors = e instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_2__.UnsubscriptionError ? e.errors : [e];\\n                }\\n            }\\n            var _teardowns = this._teardowns;\\n            if (_teardowns) {\\n                this._teardowns = null;\\n                try {\\n                    for (var _teardowns_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__values)(_teardowns), _teardowns_1_1 = _teardowns_1.next(); !_teardowns_1_1.done; _teardowns_1_1 = _teardowns_1.next()) {\\n                        var teardown_1 = _teardowns_1_1.value;\\n                        try {\\n                            execTeardown(teardown_1);\\n                        }\\n                        catch (err) {\\n                            errors = errors !== null && errors !== void 0 ? errors : [];\\n                            if (err instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_2__.UnsubscriptionError) {\\n                                errors = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)([], (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(errors)), (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(err.errors));\\n                            }\\n                            else {\\n                                errors.push(err);\\n                            }\\n                        }\\n                    }\\n                }\\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\\n                finally {\\n                    try {\\n                        if (_teardowns_1_1 && !_teardowns_1_1.done && (_b = _teardowns_1.return)) _b.call(_teardowns_1);\\n                    }\\n                    finally { if (e_2) throw e_2.error; }\\n                }\\n            }\\n            if (errors) {\\n                throw new _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_2__.UnsubscriptionError(errors);\\n            }\\n        }\\n    };\\n    Subscription.prototype.add = function (teardown) {\\n        var _a;\\n        if (teardown && teardown !== this) {\\n            if (this.closed) {\\n                execTeardown(teardown);\\n            }\\n            else {\\n                if (teardown instanceof Subscription) {\\n                    if (teardown.closed || teardown._hasParent(this)) {\\n                        return;\\n                    }\\n                    teardown._addParent(this);\\n                }\\n                (this._teardowns = (_a = this._teardowns) !== null && _a !== void 0 ? _a : []).push(teardown);\\n            }\\n        }\\n    };\\n    Subscription.prototype._hasParent = function (parent) {\\n        var _parentage = this._parentage;\\n        return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));\\n    };\\n    Subscription.prototype._addParent = function (parent) {\\n        var _parentage = this._parentage;\\n        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;\\n    };\\n    Subscription.prototype._removeParent = function (parent) {\\n        var _parentage = this._parentage;\\n        if (_parentage === parent) {\\n            this._parentage = null;\\n        }\\n        else if (Array.isArray(_parentage)) {\\n            (0,_util_arrRemove__WEBPACK_IMPORTED_MODULE_3__.arrRemove)(_parentage, parent);\\n        }\\n    };\\n    Subscription.prototype.remove = function (teardown) {\\n        var _teardowns = this._teardowns;\\n        _teardowns && (0,_util_arrRemove__WEBPACK_IMPORTED_MODULE_3__.arrRemove)(_teardowns, teardown);\\n        if (teardown instanceof Subscription) {\\n            teardown._removeParent(this);\\n        }\\n    };\\n    Subscription.EMPTY = (function () {\\n        var empty = new Subscription();\\n        empty.closed = true;\\n        return empty;\\n    })();\\n    return Subscription;\\n}());\\n\\nvar EMPTY_SUBSCRIPTION = Subscription.EMPTY;\\nfunction isSubscription(value) {\\n    return (value instanceof Subscription ||\\n        (value && 'closed' in value && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value.remove) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value.add) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value.unsubscribe)));\\n}\\nfunction execTeardown(teardown) {\\n    if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(teardown)) {\\n        teardown();\\n    }\\n    else {\\n        teardown.unsubscribe();\\n    }\\n}\\n//# sourceMappingURL=Subscription.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/Subscription.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/config.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/config.js ***!\n  \\********************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"config\\\": () => (/* binding */ config)\\n/* harmony export */ });\\nvar config = {\\n    onUnhandledError: null,\\n    onStoppedNotification: null,\\n    Promise: undefined,\\n    useDeprecatedSynchronousErrorHandling: false,\\n    useDeprecatedNextContext: false,\\n};\\n//# sourceMappingURL=config.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/config.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/observable/empty.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/observable/empty.js ***!\n  \\******************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"EMPTY\\\": () => (/* binding */ EMPTY),\\n/* harmony export */   \\\"empty\\\": () => (/* binding */ empty)\\n/* harmony export */ });\\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ \\\"./node_modules/rxjs/dist/esm5/internal/Observable.js\\\");\\n\\nvar EMPTY = new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) { return subscriber.complete(); });\\nfunction empty(scheduler) {\\n    return scheduler ? emptyScheduled(scheduler) : EMPTY;\\n}\\nfunction emptyScheduled(scheduler) {\\n    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });\\n}\\n//# sourceMappingURL=empty.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/observable/empty.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/observable/from.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/observable/from.js ***!\n  \\*****************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"from\\\": () => (/* binding */ from),\\n/* harmony export */   \\\"innerFrom\\\": () => (/* binding */ innerFrom),\\n/* harmony export */   \\\"fromArrayLike\\\": () => (/* binding */ fromArrayLike)\\n/* harmony export */ });\\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! tslib */ \\\"./node_modules/rxjs/node_modules/tslib/tslib.es6.js\\\");\\n/* harmony import */ var _util_isArrayLike__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/isArrayLike */ \\\"./node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js\\\");\\n/* harmony import */ var _util_isPromise__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/isPromise */ \\\"./node_modules/rxjs/dist/esm5/internal/util/isPromise.js\\\");\\n/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../symbol/observable */ \\\"./node_modules/rxjs/dist/esm5/internal/symbol/observable.js\\\");\\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Observable */ \\\"./node_modules/rxjs/dist/esm5/internal/Observable.js\\\");\\n/* harmony import */ var _scheduled_scheduled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scheduled/scheduled */ \\\"./node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js\\\");\\n/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../util/isFunction */ \\\"./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\\\");\\n/* harmony import */ var _util_reportUnhandledError__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../util/reportUnhandledError */ \\\"./node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js\\\");\\n/* harmony import */ var _util_isInteropObservable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/isInteropObservable */ \\\"./node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js\\\");\\n/* harmony import */ var _util_isAsyncIterable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/isAsyncIterable */ \\\"./node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js\\\");\\n/* harmony import */ var _util_throwUnobservableError__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/throwUnobservableError */ \\\"./node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js\\\");\\n/* harmony import */ var _util_isIterable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/isIterable */ \\\"./node_modules/rxjs/dist/esm5/internal/util/isIterable.js\\\");\\n/* harmony import */ var _util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/isReadableStreamLike */ \\\"./node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js\\\");\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nfunction from(input, scheduler) {\\n    return scheduler ? (0,_scheduled_scheduled__WEBPACK_IMPORTED_MODULE_0__.scheduled)(input, scheduler) : innerFrom(input);\\n}\\nfunction innerFrom(input) {\\n    if (input instanceof _Observable__WEBPACK_IMPORTED_MODULE_1__.Observable) {\\n        return input;\\n    }\\n    if (input != null) {\\n        if ((0,_util_isInteropObservable__WEBPACK_IMPORTED_MODULE_2__.isInteropObservable)(input)) {\\n            return fromInteropObservable(input);\\n        }\\n        if ((0,_util_isArrayLike__WEBPACK_IMPORTED_MODULE_3__.isArrayLike)(input)) {\\n            return fromArrayLike(input);\\n        }\\n        if ((0,_util_isPromise__WEBPACK_IMPORTED_MODULE_4__.isPromise)(input)) {\\n            return fromPromise(input);\\n        }\\n        if ((0,_util_isAsyncIterable__WEBPACK_IMPORTED_MODULE_5__.isAsyncIterable)(input)) {\\n            return fromAsyncIterable(input);\\n        }\\n        if ((0,_util_isIterable__WEBPACK_IMPORTED_MODULE_6__.isIterable)(input)) {\\n            return fromIterable(input);\\n        }\\n        if ((0,_util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_7__.isReadableStreamLike)(input)) {\\n            return fromReadableStreamLike(input);\\n        }\\n    }\\n    throw (0,_util_throwUnobservableError__WEBPACK_IMPORTED_MODULE_8__.createInvalidObservableTypeError)(input);\\n}\\nfunction fromInteropObservable(obj) {\\n    return new _Observable__WEBPACK_IMPORTED_MODULE_1__.Observable(function (subscriber) {\\n        var obs = obj[_symbol_observable__WEBPACK_IMPORTED_MODULE_9__.observable]();\\n        if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_10__.isFunction)(obs.subscribe)) {\\n            return obs.subscribe(subscriber);\\n        }\\n        throw new TypeError('Provided object does not correctly implement Symbol.observable');\\n    });\\n}\\nfunction fromArrayLike(array) {\\n    return new _Observable__WEBPACK_IMPORTED_MODULE_1__.Observable(function (subscriber) {\\n        for (var i = 0; i < array.length && !subscriber.closed; i++) {\\n            subscriber.next(array[i]);\\n        }\\n        subscriber.complete();\\n    });\\n}\\nfunction fromPromise(promise) {\\n    return new _Observable__WEBPACK_IMPORTED_MODULE_1__.Observable(function (subscriber) {\\n        promise\\n            .then(function (value) {\\n            if (!subscriber.closed) {\\n                subscriber.next(value);\\n                subscriber.complete();\\n            }\\n        }, function (err) { return subscriber.error(err); })\\n            .then(null, _util_reportUnhandledError__WEBPACK_IMPORTED_MODULE_11__.reportUnhandledError);\\n    });\\n}\\nfunction fromIterable(iterable) {\\n    return new _Observable__WEBPACK_IMPORTED_MODULE_1__.Observable(function (subscriber) {\\n        var e_1, _a;\\n        try {\\n            for (var iterable_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_12__.__values)(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {\\n                var value = iterable_1_1.value;\\n                subscriber.next(value);\\n                if (subscriber.closed) {\\n                    return;\\n                }\\n            }\\n        }\\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\\n        finally {\\n            try {\\n                if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);\\n            }\\n            finally { if (e_1) throw e_1.error; }\\n        }\\n        subscriber.complete();\\n    });\\n}\\nfunction fromAsyncIterable(asyncIterable) {\\n    return new _Observable__WEBPACK_IMPORTED_MODULE_1__.Observable(function (subscriber) {\\n        process(asyncIterable, subscriber).catch(function (err) { return subscriber.error(err); });\\n    });\\n}\\nfunction fromReadableStreamLike(readableStream) {\\n    return fromAsyncIterable((0,_util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_7__.readableStreamLikeToAsyncGenerator)(readableStream));\\n}\\nfunction process(asyncIterable, subscriber) {\\n    var asyncIterable_1, asyncIterable_1_1;\\n    var e_2, _a;\\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_12__.__awaiter)(this, void 0, void 0, function () {\\n        var value, e_2_1;\\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_12__.__generator)(this, function (_b) {\\n            switch (_b.label) {\\n                case 0:\\n                    _b.trys.push([0, 5, 6, 11]);\\n                    asyncIterable_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_12__.__asyncValues)(asyncIterable);\\n                    _b.label = 1;\\n                case 1: return [4, asyncIterable_1.next()];\\n                case 2:\\n                    if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];\\n                    value = asyncIterable_1_1.value;\\n                    subscriber.next(value);\\n                    if (subscriber.closed) {\\n                        return [2];\\n                    }\\n                    _b.label = 3;\\n                case 3: return [3, 1];\\n                case 4: return [3, 11];\\n                case 5:\\n                    e_2_1 = _b.sent();\\n                    e_2 = { error: e_2_1 };\\n                    return [3, 11];\\n                case 6:\\n                    _b.trys.push([6, , 9, 10]);\\n                    if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];\\n                    return [4, _a.call(asyncIterable_1)];\\n                case 7:\\n                    _b.sent();\\n                    _b.label = 8;\\n                case 8: return [3, 10];\\n                case 9:\\n                    if (e_2) throw e_2.error;\\n                    return [7];\\n                case 10: return [7];\\n                case 11:\\n                    subscriber.complete();\\n                    return [2];\\n            }\\n        });\\n    });\\n}\\n//# sourceMappingURL=from.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/observable/from.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js\":\n/*!******************************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js ***!\n  \\******************************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"OperatorSubscriber\\\": () => (/* binding */ OperatorSubscriber)\\n/* harmony export */ });\\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \\\"./node_modules/rxjs/node_modules/tslib/tslib.es6.js\\\");\\n/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Subscriber */ \\\"./node_modules/rxjs/dist/esm5/internal/Subscriber.js\\\");\\n\\n\\nvar OperatorSubscriber = (function (_super) {\\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(OperatorSubscriber, _super);\\n    function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {\\n        var _this = _super.call(this, destination) || this;\\n        _this.onFinalize = onFinalize;\\n        _this._next = onNext\\n            ? function (value) {\\n                try {\\n                    onNext(value);\\n                }\\n                catch (err) {\\n                    destination.error(err);\\n                }\\n            }\\n            : _super.prototype._next;\\n        _this._error = onError\\n            ? function (err) {\\n                try {\\n                    onError(err);\\n                }\\n                catch (err) {\\n                    destination.error(err);\\n                }\\n                finally {\\n                    this.unsubscribe();\\n                }\\n            }\\n            : _super.prototype._error;\\n        _this._complete = onComplete\\n            ? function () {\\n                try {\\n                    onComplete();\\n                }\\n                catch (err) {\\n                    destination.error(err);\\n                }\\n                finally {\\n                    this.unsubscribe();\\n                }\\n            }\\n            : _super.prototype._complete;\\n        return _this;\\n    }\\n    OperatorSubscriber.prototype.unsubscribe = function () {\\n        var _a;\\n        var closed = this.closed;\\n        _super.prototype.unsubscribe.call(this);\\n        !closed && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));\\n    };\\n    return OperatorSubscriber;\\n}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));\\n\\n//# sourceMappingURL=OperatorSubscriber.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/operators/defaultIfEmpty.js\":\n/*!**************************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/operators/defaultIfEmpty.js ***!\n  \\**************************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"defaultIfEmpty\\\": () => (/* binding */ defaultIfEmpty)\\n/* harmony export */ });\\n/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ \\\"./node_modules/rxjs/dist/esm5/internal/util/lift.js\\\");\\n/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperatorSubscriber */ \\\"./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js\\\");\\n\\n\\nfunction defaultIfEmpty(defaultValue) {\\n    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)(function (source, subscriber) {\\n        var hasValue = false;\\n        source.subscribe(new _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.OperatorSubscriber(subscriber, function (value) {\\n            hasValue = true;\\n            subscriber.next(value);\\n        }, function () {\\n            if (!hasValue) {\\n                subscriber.next(defaultValue);\\n            }\\n            subscriber.complete();\\n        }));\\n    });\\n}\\n//# sourceMappingURL=defaultIfEmpty.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/operators/defaultIfEmpty.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/operators/filter.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/operators/filter.js ***!\n  \\******************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"filter\\\": () => (/* binding */ filter)\\n/* harmony export */ });\\n/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ \\\"./node_modules/rxjs/dist/esm5/internal/util/lift.js\\\");\\n/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperatorSubscriber */ \\\"./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js\\\");\\n\\n\\nfunction filter(predicate, thisArg) {\\n    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)(function (source, subscriber) {\\n        var index = 0;\\n        source.subscribe(new _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.OperatorSubscriber(subscriber, function (value) { return predicate.call(thisArg, value, index++) && subscriber.next(value); }));\\n    });\\n}\\n//# sourceMappingURL=filter.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/operators/filter.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/operators/finalize.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/operators/finalize.js ***!\n  \\********************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"finalize\\\": () => (/* binding */ finalize)\\n/* harmony export */ });\\n/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ \\\"./node_modules/rxjs/dist/esm5/internal/util/lift.js\\\");\\n\\nfunction finalize(callback) {\\n    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)(function (source, subscriber) {\\n        try {\\n            source.subscribe(subscriber);\\n        }\\n        finally {\\n            subscriber.add(callback);\\n        }\\n    });\\n}\\n//# sourceMappingURL=finalize.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/operators/finalize.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/operators/first.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/operators/first.js ***!\n  \\*****************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"first\\\": () => (/* binding */ first)\\n/* harmony export */ });\\n/* harmony import */ var _util_EmptyError__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/EmptyError */ \\\"./node_modules/rxjs/dist/esm5/internal/util/EmptyError.js\\\");\\n/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filter */ \\\"./node_modules/rxjs/dist/esm5/internal/operators/filter.js\\\");\\n/* harmony import */ var _take__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./take */ \\\"./node_modules/rxjs/dist/esm5/internal/operators/take.js\\\");\\n/* harmony import */ var _defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./defaultIfEmpty */ \\\"./node_modules/rxjs/dist/esm5/internal/operators/defaultIfEmpty.js\\\");\\n/* harmony import */ var _throwIfEmpty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./throwIfEmpty */ \\\"./node_modules/rxjs/dist/esm5/internal/operators/throwIfEmpty.js\\\");\\n/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/identity */ \\\"./node_modules/rxjs/dist/esm5/internal/util/identity.js\\\");\\n\\n\\n\\n\\n\\n\\nfunction first(predicate, defaultValue) {\\n    var hasDefaultValue = arguments.length >= 2;\\n    return function (source) {\\n        return source.pipe(predicate ? (0,_filter__WEBPACK_IMPORTED_MODULE_0__.filter)(function (v, i) { return predicate(v, i, source); }) : _util_identity__WEBPACK_IMPORTED_MODULE_1__.identity, (0,_take__WEBPACK_IMPORTED_MODULE_2__.take)(1), hasDefaultValue ? (0,_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__.defaultIfEmpty)(defaultValue) : (0,_throwIfEmpty__WEBPACK_IMPORTED_MODULE_4__.throwIfEmpty)(function () { return new _util_EmptyError__WEBPACK_IMPORTED_MODULE_5__.EmptyError(); }));\\n    };\\n}\\n//# sourceMappingURL=first.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/operators/first.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/operators/share.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/operators/share.js ***!\n  \\*****************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"share\\\": () => (/* binding */ share)\\n/* harmony export */ });\\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ \\\"./node_modules/rxjs/node_modules/tslib/tslib.es6.js\\\");\\n/* harmony import */ var _observable_from__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../observable/from */ \\\"./node_modules/rxjs/dist/esm5/internal/observable/from.js\\\");\\n/* harmony import */ var _operators_take__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../operators/take */ \\\"./node_modules/rxjs/dist/esm5/internal/operators/take.js\\\");\\n/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Subject */ \\\"./node_modules/rxjs/dist/esm5/internal/Subject.js\\\");\\n/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Subscriber */ \\\"./node_modules/rxjs/dist/esm5/internal/Subscriber.js\\\");\\n/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/lift */ \\\"./node_modules/rxjs/dist/esm5/internal/util/lift.js\\\");\\n\\n\\n\\n\\n\\n\\nfunction share(options) {\\n    if (options === void 0) { options = {}; }\\n    var _a = options.connector, connector = _a === void 0 ? function () { return new _Subject__WEBPACK_IMPORTED_MODULE_0__.Subject(); } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;\\n    return function (wrapperSource) {\\n        var connection = null;\\n        var resetConnection = null;\\n        var subject = null;\\n        var refCount = 0;\\n        var hasCompleted = false;\\n        var hasErrored = false;\\n        var cancelReset = function () {\\n            resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();\\n            resetConnection = null;\\n        };\\n        var reset = function () {\\n            cancelReset();\\n            connection = subject = null;\\n            hasCompleted = hasErrored = false;\\n        };\\n        var resetAndUnsubscribe = function () {\\n            var conn = connection;\\n            reset();\\n            conn === null || conn === void 0 ? void 0 : conn.unsubscribe();\\n        };\\n        return (0,_util_lift__WEBPACK_IMPORTED_MODULE_1__.operate)(function (source, subscriber) {\\n            refCount++;\\n            if (!hasErrored && !hasCompleted) {\\n                cancelReset();\\n            }\\n            var dest = (subject = subject !== null && subject !== void 0 ? subject : connector());\\n            subscriber.add(function () {\\n                refCount--;\\n                if (refCount === 0 && !hasErrored && !hasCompleted) {\\n                    resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);\\n                }\\n            });\\n            dest.subscribe(subscriber);\\n            if (!connection) {\\n                connection = new _Subscriber__WEBPACK_IMPORTED_MODULE_2__.SafeSubscriber({\\n                    next: function (value) { return dest.next(value); },\\n                    error: function (err) {\\n                        hasErrored = true;\\n                        cancelReset();\\n                        resetConnection = handleReset(reset, resetOnError, err);\\n                        dest.error(err);\\n                    },\\n                    complete: function () {\\n                        hasCompleted = true;\\n                        cancelReset();\\n                        resetConnection = handleReset(reset, resetOnComplete);\\n                        dest.complete();\\n                    },\\n                });\\n                (0,_observable_from__WEBPACK_IMPORTED_MODULE_3__.from)(source).subscribe(connection);\\n            }\\n        })(wrapperSource);\\n    };\\n}\\nfunction handleReset(reset, on) {\\n    var args = [];\\n    for (var _i = 2; _i < arguments.length; _i++) {\\n        args[_i - 2] = arguments[_i];\\n    }\\n    if (on === true) {\\n        reset();\\n        return null;\\n    }\\n    if (on === false) {\\n        return null;\\n    }\\n    return on.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__spreadArray)([], (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__read)(args))).pipe((0,_operators_take__WEBPACK_IMPORTED_MODULE_5__.take)(1))\\n        .subscribe(function () { return reset(); });\\n}\\n//# sourceMappingURL=share.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/operators/share.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/operators/take.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/operators/take.js ***!\n  \\****************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"take\\\": () => (/* binding */ take)\\n/* harmony export */ });\\n/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observable/empty */ \\\"./node_modules/rxjs/dist/esm5/internal/observable/empty.js\\\");\\n/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/lift */ \\\"./node_modules/rxjs/dist/esm5/internal/util/lift.js\\\");\\n/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OperatorSubscriber */ \\\"./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js\\\");\\n\\n\\n\\nfunction take(count) {\\n    return count <= 0\\n        ?\\n            function () { return _observable_empty__WEBPACK_IMPORTED_MODULE_0__.EMPTY; }\\n        : (0,_util_lift__WEBPACK_IMPORTED_MODULE_1__.operate)(function (source, subscriber) {\\n            var seen = 0;\\n            source.subscribe(new _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__.OperatorSubscriber(subscriber, function (value) {\\n                if (++seen <= count) {\\n                    subscriber.next(value);\\n                    if (count <= seen) {\\n                        subscriber.complete();\\n                    }\\n                }\\n            }));\\n        });\\n}\\n//# sourceMappingURL=take.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/operators/take.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/operators/throwIfEmpty.js\":\n/*!************************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/operators/throwIfEmpty.js ***!\n  \\************************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"throwIfEmpty\\\": () => (/* binding */ throwIfEmpty)\\n/* harmony export */ });\\n/* harmony import */ var _util_EmptyError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/EmptyError */ \\\"./node_modules/rxjs/dist/esm5/internal/util/EmptyError.js\\\");\\n/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ \\\"./node_modules/rxjs/dist/esm5/internal/util/lift.js\\\");\\n/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperatorSubscriber */ \\\"./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js\\\");\\n\\n\\n\\nfunction throwIfEmpty(errorFactory) {\\n    if (errorFactory === void 0) { errorFactory = defaultErrorFactory; }\\n    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)(function (source, subscriber) {\\n        var hasValue = false;\\n        source.subscribe(new _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.OperatorSubscriber(subscriber, function (value) {\\n            hasValue = true;\\n            subscriber.next(value);\\n        }, function () { return (hasValue ? subscriber.complete() : subscriber.error(errorFactory())); }));\\n    });\\n}\\nfunction defaultErrorFactory() {\\n    return new _util_EmptyError__WEBPACK_IMPORTED_MODULE_2__.EmptyError();\\n}\\n//# sourceMappingURL=throwIfEmpty.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/operators/throwIfEmpty.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js\":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js ***!\n  \\*************************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"scheduleArray\\\": () => (/* binding */ scheduleArray)\\n/* harmony export */ });\\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ \\\"./node_modules/rxjs/dist/esm5/internal/Observable.js\\\");\\n\\nfunction scheduleArray(input, scheduler) {\\n    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {\\n        var i = 0;\\n        return scheduler.schedule(function () {\\n            if (i === input.length) {\\n                subscriber.complete();\\n            }\\n            else {\\n                subscriber.next(input[i++]);\\n                if (!subscriber.closed) {\\n                    this.schedule();\\n                }\\n            }\\n        });\\n    });\\n}\\n//# sourceMappingURL=scheduleArray.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js\":\n/*!*********************************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js ***!\n  \\*********************************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"scheduleAsyncIterable\\\": () => (/* binding */ scheduleAsyncIterable)\\n/* harmony export */ });\\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ \\\"./node_modules/rxjs/dist/esm5/internal/Observable.js\\\");\\n/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Subscription */ \\\"./node_modules/rxjs/dist/esm5/internal/Subscription.js\\\");\\n\\n\\nfunction scheduleAsyncIterable(input, scheduler) {\\n    if (!input) {\\n        throw new Error('Iterable cannot be null');\\n    }\\n    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {\\n        var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription();\\n        sub.add(scheduler.schedule(function () {\\n            var iterator = input[Symbol.asyncIterator]();\\n            sub.add(scheduler.schedule(function () {\\n                var _this = this;\\n                iterator.next().then(function (result) {\\n                    if (result.done) {\\n                        subscriber.complete();\\n                    }\\n                    else {\\n                        subscriber.next(result.value);\\n                        _this.schedule();\\n                    }\\n                });\\n            }));\\n        }));\\n        return sub;\\n    });\\n}\\n//# sourceMappingURL=scheduleAsyncIterable.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js\":\n/*!****************************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js ***!\n  \\****************************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"scheduleIterable\\\": () => (/* binding */ scheduleIterable)\\n/* harmony export */ });\\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ \\\"./node_modules/rxjs/dist/esm5/internal/Observable.js\\\");\\n/* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../symbol/iterator */ \\\"./node_modules/rxjs/dist/esm5/internal/symbol/iterator.js\\\");\\n/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/isFunction */ \\\"./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\\\");\\n/* harmony import */ var _util_caughtSchedule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/caughtSchedule */ \\\"./node_modules/rxjs/dist/esm5/internal/util/caughtSchedule.js\\\");\\n\\n\\n\\n\\nfunction scheduleIterable(input, scheduler) {\\n    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {\\n        var iterator;\\n        subscriber.add(scheduler.schedule(function () {\\n            iterator = input[_symbol_iterator__WEBPACK_IMPORTED_MODULE_1__.iterator]();\\n            (0,_util_caughtSchedule__WEBPACK_IMPORTED_MODULE_2__.caughtSchedule)(subscriber, scheduler, function () {\\n                var _a = iterator.next(), value = _a.value, done = _a.done;\\n                if (done) {\\n                    subscriber.complete();\\n                }\\n                else {\\n                    subscriber.next(value);\\n                    this.schedule();\\n                }\\n            });\\n        }));\\n        return function () { return (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_3__.isFunction)(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return(); };\\n    });\\n}\\n//# sourceMappingURL=scheduleIterable.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js\":\n/*!******************************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js ***!\n  \\******************************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"scheduleObservable\\\": () => (/* binding */ scheduleObservable)\\n/* harmony export */ });\\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ \\\"./node_modules/rxjs/dist/esm5/internal/Observable.js\\\");\\n/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Subscription */ \\\"./node_modules/rxjs/dist/esm5/internal/Subscription.js\\\");\\n/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../symbol/observable */ \\\"./node_modules/rxjs/dist/esm5/internal/symbol/observable.js\\\");\\n\\n\\n\\nfunction scheduleObservable(input, scheduler) {\\n    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {\\n        var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription();\\n        sub.add(scheduler.schedule(function () {\\n            var observable = input[_symbol_observable__WEBPACK_IMPORTED_MODULE_2__.observable]();\\n            sub.add(observable.subscribe({\\n                next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },\\n                error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },\\n                complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },\\n            }));\\n        }));\\n        return sub;\\n    });\\n}\\n//# sourceMappingURL=scheduleObservable.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js\":\n/*!***************************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js ***!\n  \\***************************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"schedulePromise\\\": () => (/* binding */ schedulePromise)\\n/* harmony export */ });\\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ \\\"./node_modules/rxjs/dist/esm5/internal/Observable.js\\\");\\n\\nfunction schedulePromise(input, scheduler) {\\n    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {\\n        return scheduler.schedule(function () {\\n            return input.then(function (value) {\\n                subscriber.add(scheduler.schedule(function () {\\n                    subscriber.next(value);\\n                    subscriber.add(scheduler.schedule(function () { return subscriber.complete(); }));\\n                }));\\n            }, function (err) {\\n                subscriber.add(scheduler.schedule(function () { return subscriber.error(err); }));\\n            });\\n        });\\n    });\\n}\\n//# sourceMappingURL=schedulePromise.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js\":\n/*!**************************************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js ***!\n  \\**************************************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"scheduleReadableStreamLike\\\": () => (/* binding */ scheduleReadableStreamLike)\\n/* harmony export */ });\\n/* harmony import */ var _scheduleAsyncIterable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scheduleAsyncIterable */ \\\"./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js\\\");\\n/* harmony import */ var _util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/isReadableStreamLike */ \\\"./node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js\\\");\\n\\n\\nfunction scheduleReadableStreamLike(input, scheduler) {\\n    return (0,_scheduleAsyncIterable__WEBPACK_IMPORTED_MODULE_0__.scheduleAsyncIterable)((0,_util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_1__.readableStreamLikeToAsyncGenerator)(input), scheduler);\\n}\\n//# sourceMappingURL=scheduleReadableStreamLike.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js ***!\n  \\*********************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"scheduled\\\": () => (/* binding */ scheduled)\\n/* harmony export */ });\\n/* harmony import */ var _scheduleObservable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scheduleObservable */ \\\"./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js\\\");\\n/* harmony import */ var _schedulePromise__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./schedulePromise */ \\\"./node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js\\\");\\n/* harmony import */ var _scheduleArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scheduleArray */ \\\"./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js\\\");\\n/* harmony import */ var _scheduleIterable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./scheduleIterable */ \\\"./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js\\\");\\n/* harmony import */ var _scheduleAsyncIterable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./scheduleAsyncIterable */ \\\"./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js\\\");\\n/* harmony import */ var _util_isInteropObservable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/isInteropObservable */ \\\"./node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js\\\");\\n/* harmony import */ var _util_isPromise__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/isPromise */ \\\"./node_modules/rxjs/dist/esm5/internal/util/isPromise.js\\\");\\n/* harmony import */ var _util_isArrayLike__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/isArrayLike */ \\\"./node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js\\\");\\n/* harmony import */ var _util_isIterable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/isIterable */ \\\"./node_modules/rxjs/dist/esm5/internal/util/isIterable.js\\\");\\n/* harmony import */ var _util_isAsyncIterable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/isAsyncIterable */ \\\"./node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js\\\");\\n/* harmony import */ var _util_throwUnobservableError__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../util/throwUnobservableError */ \\\"./node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js\\\");\\n/* harmony import */ var _util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../util/isReadableStreamLike */ \\\"./node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js\\\");\\n/* harmony import */ var _scheduleReadableStreamLike__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./scheduleReadableStreamLike */ \\\"./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js\\\");\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nfunction scheduled(input, scheduler) {\\n    if (input != null) {\\n        if ((0,_util_isInteropObservable__WEBPACK_IMPORTED_MODULE_0__.isInteropObservable)(input)) {\\n            return (0,_scheduleObservable__WEBPACK_IMPORTED_MODULE_1__.scheduleObservable)(input, scheduler);\\n        }\\n        if ((0,_util_isArrayLike__WEBPACK_IMPORTED_MODULE_2__.isArrayLike)(input)) {\\n            return (0,_scheduleArray__WEBPACK_IMPORTED_MODULE_3__.scheduleArray)(input, scheduler);\\n        }\\n        if ((0,_util_isPromise__WEBPACK_IMPORTED_MODULE_4__.isPromise)(input)) {\\n            return (0,_schedulePromise__WEBPACK_IMPORTED_MODULE_5__.schedulePromise)(input, scheduler);\\n        }\\n        if ((0,_util_isAsyncIterable__WEBPACK_IMPORTED_MODULE_6__.isAsyncIterable)(input)) {\\n            return (0,_scheduleAsyncIterable__WEBPACK_IMPORTED_MODULE_7__.scheduleAsyncIterable)(input, scheduler);\\n        }\\n        if ((0,_util_isIterable__WEBPACK_IMPORTED_MODULE_8__.isIterable)(input)) {\\n            return (0,_scheduleIterable__WEBPACK_IMPORTED_MODULE_9__.scheduleIterable)(input, scheduler);\\n        }\\n        if ((0,_util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_10__.isReadableStreamLike)(input)) {\\n            return (0,_scheduleReadableStreamLike__WEBPACK_IMPORTED_MODULE_11__.scheduleReadableStreamLike)(input, scheduler);\\n        }\\n    }\\n    throw (0,_util_throwUnobservableError__WEBPACK_IMPORTED_MODULE_12__.createInvalidObservableTypeError)(input);\\n}\\n//# sourceMappingURL=scheduled.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js\":\n/*!***************************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js ***!\n  \\***************************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"timeoutProvider\\\": () => (/* binding */ timeoutProvider)\\n/* harmony export */ });\\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \\\"./node_modules/rxjs/node_modules/tslib/tslib.es6.js\\\");\\n\\nvar timeoutProvider = {\\n    setTimeout: function () {\\n        var args = [];\\n        for (var _i = 0; _i < arguments.length; _i++) {\\n            args[_i] = arguments[_i];\\n        }\\n        var delegate = timeoutProvider.delegate;\\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) || setTimeout).apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)([], (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(args)));\\n    },\\n    clearTimeout: function (handle) {\\n        var delegate = timeoutProvider.delegate;\\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);\\n    },\\n    delegate: undefined,\\n};\\n//# sourceMappingURL=timeoutProvider.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/symbol/iterator.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/symbol/iterator.js ***!\n  \\*****************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"getSymbolIterator\\\": () => (/* binding */ getSymbolIterator),\\n/* harmony export */   \\\"iterator\\\": () => (/* binding */ iterator)\\n/* harmony export */ });\\nfunction getSymbolIterator() {\\n    if (typeof Symbol !== 'function' || !Symbol.iterator) {\\n        return '@@iterator';\\n    }\\n    return Symbol.iterator;\\n}\\nvar iterator = getSymbolIterator();\\n//# sourceMappingURL=iterator.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/symbol/iterator.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/symbol/observable.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/symbol/observable.js ***!\n  \\*******************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"observable\\\": () => (/* binding */ observable)\\n/* harmony export */ });\\nvar observable = (function () { return (typeof Symbol === 'function' && Symbol.observable) || '@@observable'; })();\\n//# sourceMappingURL=observable.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/symbol/observable.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/util/EmptyError.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/util/EmptyError.js ***!\n  \\*****************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"EmptyError\\\": () => (/* binding */ EmptyError)\\n/* harmony export */ });\\n/* harmony import */ var _createErrorClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createErrorClass */ \\\"./node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js\\\");\\n\\nvar EmptyError = (0,_createErrorClass__WEBPACK_IMPORTED_MODULE_0__.createErrorClass)(function (_super) { return function EmptyErrorImpl() {\\n    _super(this);\\n    this.name = 'EmptyError';\\n    this.message = 'no elements in sequence';\\n}; });\\n//# sourceMappingURL=EmptyError.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/util/EmptyError.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js\":\n/*!******************************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js ***!\n  \\******************************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"ObjectUnsubscribedError\\\": () => (/* binding */ ObjectUnsubscribedError)\\n/* harmony export */ });\\n/* harmony import */ var _createErrorClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createErrorClass */ \\\"./node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js\\\");\\n\\nvar ObjectUnsubscribedError = (0,_createErrorClass__WEBPACK_IMPORTED_MODULE_0__.createErrorClass)(function (_super) {\\n    return function ObjectUnsubscribedErrorImpl() {\\n        _super(this);\\n        this.name = 'ObjectUnsubscribedError';\\n        this.message = 'object unsubscribed';\\n    };\\n});\\n//# sourceMappingURL=ObjectUnsubscribedError.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js\":\n/*!**************************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js ***!\n  \\**************************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"UnsubscriptionError\\\": () => (/* binding */ UnsubscriptionError)\\n/* harmony export */ });\\n/* harmony import */ var _createErrorClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createErrorClass */ \\\"./node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js\\\");\\n\\nvar UnsubscriptionError = (0,_createErrorClass__WEBPACK_IMPORTED_MODULE_0__.createErrorClass)(function (_super) {\\n    return function UnsubscriptionErrorImpl(errors) {\\n        _super(this);\\n        this.message = errors\\n            ? errors.length + \\\" errors occurred during unsubscription:\\\\n\\\" + errors.map(function (err, i) { return i + 1 + \\\") \\\" + err.toString(); }).join('\\\\n  ')\\n            : '';\\n        this.name = 'UnsubscriptionError';\\n        this.errors = errors;\\n    };\\n});\\n//# sourceMappingURL=UnsubscriptionError.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/util/arrRemove.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/util/arrRemove.js ***!\n  \\****************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"arrRemove\\\": () => (/* binding */ arrRemove)\\n/* harmony export */ });\\nfunction arrRemove(arr, item) {\\n    if (arr) {\\n        var index = arr.indexOf(item);\\n        0 <= index && arr.splice(index, 1);\\n    }\\n}\\n//# sourceMappingURL=arrRemove.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/util/arrRemove.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/util/caughtSchedule.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/util/caughtSchedule.js ***!\n  \\*********************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"caughtSchedule\\\": () => (/* binding */ caughtSchedule)\\n/* harmony export */ });\\nfunction caughtSchedule(subscriber, scheduler, execute, delay) {\\n    if (delay === void 0) { delay = 0; }\\n    var subscription = scheduler.schedule(function () {\\n        try {\\n            execute.call(this);\\n        }\\n        catch (err) {\\n            subscriber.error(err);\\n        }\\n    }, delay);\\n    subscriber.add(subscription);\\n    return subscription;\\n}\\n//# sourceMappingURL=caughtSchedule.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/util/caughtSchedule.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js ***!\n  \\***********************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"createErrorClass\\\": () => (/* binding */ createErrorClass)\\n/* harmony export */ });\\nfunction createErrorClass(createImpl) {\\n    var _super = function (instance) {\\n        Error.call(instance);\\n        instance.stack = new Error().stack;\\n    };\\n    var ctorFunc = createImpl(_super);\\n    ctorFunc.prototype = Object.create(Error.prototype);\\n    ctorFunc.prototype.constructor = ctorFunc;\\n    return ctorFunc;\\n}\\n//# sourceMappingURL=createErrorClass.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/util/errorContext.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/util/errorContext.js ***!\n  \\*******************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"errorContext\\\": () => (/* binding */ errorContext),\\n/* harmony export */   \\\"captureError\\\": () => (/* binding */ captureError)\\n/* harmony export */ });\\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ \\\"./node_modules/rxjs/dist/esm5/internal/config.js\\\");\\n\\nvar context = null;\\nfunction errorContext(cb) {\\n    if (_config__WEBPACK_IMPORTED_MODULE_0__.config.useDeprecatedSynchronousErrorHandling) {\\n        var isRoot = !context;\\n        if (isRoot) {\\n            context = { errorThrown: false, error: null };\\n        }\\n        cb();\\n        if (isRoot) {\\n            var _a = context, errorThrown = _a.errorThrown, error = _a.error;\\n            context = null;\\n            if (errorThrown) {\\n                throw error;\\n            }\\n        }\\n    }\\n    else {\\n        cb();\\n    }\\n}\\nfunction captureError(err) {\\n    if (_config__WEBPACK_IMPORTED_MODULE_0__.config.useDeprecatedSynchronousErrorHandling && context) {\\n        context.errorThrown = true;\\n        context.error = err;\\n    }\\n}\\n//# sourceMappingURL=errorContext.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/util/errorContext.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/util/identity.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/util/identity.js ***!\n  \\***************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"identity\\\": () => (/* binding */ identity)\\n/* harmony export */ });\\nfunction identity(x) {\\n    return x;\\n}\\n//# sourceMappingURL=identity.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/util/identity.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js ***!\n  \\******************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"isArrayLike\\\": () => (/* binding */ isArrayLike)\\n/* harmony export */ });\\nvar isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });\\n//# sourceMappingURL=isArrayLike.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js ***!\n  \\**********************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"isAsyncIterable\\\": () => (/* binding */ isAsyncIterable)\\n/* harmony export */ });\\n/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction */ \\\"./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\\\");\\n\\nfunction isAsyncIterable(obj) {\\n    return Symbol.asyncIterator && (0,_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);\\n}\\n//# sourceMappingURL=isAsyncIterable.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/util/isFunction.js ***!\n  \\*****************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"isFunction\\\": () => (/* binding */ isFunction)\\n/* harmony export */ });\\nfunction isFunction(value) {\\n    return typeof value === 'function';\\n}\\n//# sourceMappingURL=isFunction.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/util/isFunction.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js\":\n/*!**************************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js ***!\n  \\**************************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"isInteropObservable\\\": () => (/* binding */ isInteropObservable)\\n/* harmony export */ });\\n/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../symbol/observable */ \\\"./node_modules/rxjs/dist/esm5/internal/symbol/observable.js\\\");\\n/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction */ \\\"./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\\\");\\n\\n\\nfunction isInteropObservable(input) {\\n    return (0,_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(input[_symbol_observable__WEBPACK_IMPORTED_MODULE_1__.observable]);\\n}\\n//# sourceMappingURL=isInteropObservable.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/util/isIterable.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/util/isIterable.js ***!\n  \\*****************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"isIterable\\\": () => (/* binding */ isIterable)\\n/* harmony export */ });\\n/* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../symbol/iterator */ \\\"./node_modules/rxjs/dist/esm5/internal/symbol/iterator.js\\\");\\n/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction */ \\\"./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\\\");\\n\\n\\nfunction isIterable(input) {\\n    return (0,_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(input === null || input === void 0 ? void 0 : input[_symbol_iterator__WEBPACK_IMPORTED_MODULE_1__.iterator]);\\n}\\n//# sourceMappingURL=isIterable.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/util/isIterable.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/util/isPromise.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/util/isPromise.js ***!\n  \\****************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"isPromise\\\": () => (/* binding */ isPromise)\\n/* harmony export */ });\\n/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction */ \\\"./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\\\");\\n\\nfunction isPromise(value) {\\n    return (0,_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value === null || value === void 0 ? void 0 : value.then);\\n}\\n//# sourceMappingURL=isPromise.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/util/isPromise.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js\":\n/*!***************************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js ***!\n  \\***************************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"readableStreamLikeToAsyncGenerator\\\": () => (/* binding */ readableStreamLikeToAsyncGenerator),\\n/* harmony export */   \\\"isReadableStreamLike\\\": () => (/* binding */ isReadableStreamLike)\\n/* harmony export */ });\\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \\\"./node_modules/rxjs/node_modules/tslib/tslib.es6.js\\\");\\n/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction */ \\\"./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\\\");\\n\\n\\nfunction readableStreamLikeToAsyncGenerator(readableStream) {\\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__asyncGenerator)(this, arguments, function readableStreamLikeToAsyncGenerator_1() {\\n        var reader, _a, value, done;\\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__generator)(this, function (_b) {\\n            switch (_b.label) {\\n                case 0:\\n                    reader = readableStream.getReader();\\n                    _b.label = 1;\\n                case 1:\\n                    _b.trys.push([1, , 9, 10]);\\n                    _b.label = 2;\\n                case 2:\\n                    if (false) {}\\n                    return [4, (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__await)(reader.read())];\\n                case 3:\\n                    _a = _b.sent(), value = _a.value, done = _a.done;\\n                    if (!done) return [3, 5];\\n                    return [4, (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__await)(void 0)];\\n                case 4: return [2, _b.sent()];\\n                case 5: return [4, (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__await)(value)];\\n                case 6: return [4, _b.sent()];\\n                case 7:\\n                    _b.sent();\\n                    return [3, 2];\\n                case 8: return [3, 10];\\n                case 9:\\n                    reader.releaseLock();\\n                    return [7];\\n                case 10: return [2];\\n            }\\n        });\\n    });\\n}\\nfunction isReadableStreamLike(obj) {\\n    return (0,_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(obj === null || obj === void 0 ? void 0 : obj.getReader);\\n}\\n//# sourceMappingURL=isReadableStreamLike.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/util/lift.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/util/lift.js ***!\n  \\***********************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"hasLift\\\": () => (/* binding */ hasLift),\\n/* harmony export */   \\\"operate\\\": () => (/* binding */ operate)\\n/* harmony export */ });\\n/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction */ \\\"./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\\\");\\n\\nfunction hasLift(source) {\\n    return (0,_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(source === null || source === void 0 ? void 0 : source.lift);\\n}\\nfunction operate(init) {\\n    return function (source) {\\n        if (hasLift(source)) {\\n            return source.lift(function (liftedSource) {\\n                try {\\n                    return init(liftedSource, this);\\n                }\\n                catch (err) {\\n                    this.error(err);\\n                }\\n            });\\n        }\\n        throw new TypeError('Unable to lift unknown Observable type');\\n    };\\n}\\n//# sourceMappingURL=lift.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/util/lift.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/util/noop.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/util/noop.js ***!\n  \\***********************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"noop\\\": () => (/* binding */ noop)\\n/* harmony export */ });\\nfunction noop() { }\\n//# sourceMappingURL=noop.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/util/noop.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/util/pipe.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/util/pipe.js ***!\n  \\***********************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"pipe\\\": () => (/* binding */ pipe),\\n/* harmony export */   \\\"pipeFromArray\\\": () => (/* binding */ pipeFromArray)\\n/* harmony export */ });\\n/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity */ \\\"./node_modules/rxjs/dist/esm5/internal/util/identity.js\\\");\\n\\nfunction pipe() {\\n    var fns = [];\\n    for (var _i = 0; _i < arguments.length; _i++) {\\n        fns[_i] = arguments[_i];\\n    }\\n    return pipeFromArray(fns);\\n}\\nfunction pipeFromArray(fns) {\\n    if (fns.length === 0) {\\n        return _identity__WEBPACK_IMPORTED_MODULE_0__.identity;\\n    }\\n    if (fns.length === 1) {\\n        return fns[0];\\n    }\\n    return function piped(input) {\\n        return fns.reduce(function (prev, fn) { return fn(prev); }, input);\\n    };\\n}\\n//# sourceMappingURL=pipe.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/util/pipe.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js\":\n/*!***************************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js ***!\n  \\***************************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"reportUnhandledError\\\": () => (/* binding */ reportUnhandledError)\\n/* harmony export */ });\\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config */ \\\"./node_modules/rxjs/dist/esm5/internal/config.js\\\");\\n/* harmony import */ var _scheduler_timeoutProvider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scheduler/timeoutProvider */ \\\"./node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js\\\");\\n\\n\\nfunction reportUnhandledError(err) {\\n    _scheduler_timeoutProvider__WEBPACK_IMPORTED_MODULE_0__.timeoutProvider.setTimeout(function () {\\n        var onUnhandledError = _config__WEBPACK_IMPORTED_MODULE_1__.config.onUnhandledError;\\n        if (onUnhandledError) {\\n            onUnhandledError(err);\\n        }\\n        else {\\n            throw err;\\n        }\\n    });\\n}\\n//# sourceMappingURL=reportUnhandledError.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js\":\n/*!*****************************************************************************!*\\\n  !*** ./node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js ***!\n  \\*****************************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"createInvalidObservableTypeError\\\": () => (/* binding */ createInvalidObservableTypeError)\\n/* harmony export */ });\\nfunction createInvalidObservableTypeError(input) {\\n    return new TypeError(\\\"You provided \\\" + (input !== null && typeof input === 'object' ? 'an invalid object' : \\\"'\\\" + input + \\\"'\\\") + \\\" where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.\\\");\\n}\\n//# sourceMappingURL=throwUnobservableError.js.map\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/rxjs/node_modules/tslib/tslib.es6.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/rxjs/node_modules/tslib/tslib.es6.js ***!\n  \\***********************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"__extends\\\": () => (/* binding */ __extends),\\n/* harmony export */   \\\"__assign\\\": () => (/* binding */ __assign),\\n/* harmony export */   \\\"__rest\\\": () => (/* binding */ __rest),\\n/* harmony export */   \\\"__decorate\\\": () => (/* binding */ __decorate),\\n/* harmony export */   \\\"__param\\\": () => (/* binding */ __param),\\n/* harmony export */   \\\"__metadata\\\": () => (/* binding */ __metadata),\\n/* harmony export */   \\\"__awaiter\\\": () => (/* binding */ __awaiter),\\n/* harmony export */   \\\"__generator\\\": () => (/* binding */ __generator),\\n/* harmony export */   \\\"__createBinding\\\": () => (/* binding */ __createBinding),\\n/* harmony export */   \\\"__exportStar\\\": () => (/* binding */ __exportStar),\\n/* harmony export */   \\\"__values\\\": () => (/* binding */ __values),\\n/* harmony export */   \\\"__read\\\": () => (/* binding */ __read),\\n/* harmony export */   \\\"__spread\\\": () => (/* binding */ __spread),\\n/* harmony export */   \\\"__spreadArrays\\\": () => (/* binding */ __spreadArrays),\\n/* harmony export */   \\\"__spreadArray\\\": () => (/* binding */ __spreadArray),\\n/* harmony export */   \\\"__await\\\": () => (/* binding */ __await),\\n/* harmony export */   \\\"__asyncGenerator\\\": () => (/* binding */ __asyncGenerator),\\n/* harmony export */   \\\"__asyncDelegator\\\": () => (/* binding */ __asyncDelegator),\\n/* harmony export */   \\\"__asyncValues\\\": () => (/* binding */ __asyncValues),\\n/* harmony export */   \\\"__makeTemplateObject\\\": () => (/* binding */ __makeTemplateObject),\\n/* harmony export */   \\\"__importStar\\\": () => (/* binding */ __importStar),\\n/* harmony export */   \\\"__importDefault\\\": () => (/* binding */ __importDefault),\\n/* harmony export */   \\\"__classPrivateFieldGet\\\": () => (/* binding */ __classPrivateFieldGet),\\n/* harmony export */   \\\"__classPrivateFieldSet\\\": () => (/* binding */ __classPrivateFieldSet)\\n/* harmony export */ });\\n/*! *****************************************************************************\\r\\nCopyright (c) Microsoft Corporation.\\r\\n\\r\\nPermission to use, copy, modify, and/or distribute this software for any\\r\\npurpose with or without fee is hereby granted.\\r\\n\\r\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\\r\\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\\r\\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\\r\\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\\r\\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\\r\\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\\r\\nPERFORMANCE OF THIS SOFTWARE.\\r\\n***************************************************************************** */\\r\\n/* global Reflect, Promise */\\r\\n\\r\\nvar extendStatics = function(d, b) {\\r\\n    extendStatics = Object.setPrototypeOf ||\\r\\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\\r\\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\\r\\n    return extendStatics(d, b);\\r\\n};\\r\\n\\r\\nfunction __extends(d, b) {\\r\\n    if (typeof b !== \\\"function\\\" && b !== null)\\r\\n        throw new TypeError(\\\"Class extends value \\\" + String(b) + \\\" is not a constructor or null\\\");\\r\\n    extendStatics(d, b);\\r\\n    function __() { this.constructor = d; }\\r\\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\\r\\n}\\r\\n\\r\\nvar __assign = function() {\\r\\n    __assign = Object.assign || function __assign(t) {\\r\\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\\r\\n            s = arguments[i];\\r\\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\\r\\n        }\\r\\n        return t;\\r\\n    }\\r\\n    return __assign.apply(this, arguments);\\r\\n}\\r\\n\\r\\nfunction __rest(s, e) {\\r\\n    var t = {};\\r\\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\\r\\n        t[p] = s[p];\\r\\n    if (s != null && typeof Object.getOwnPropertySymbols === \\\"function\\\")\\r\\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\\r\\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\\r\\n                t[p[i]] = s[p[i]];\\r\\n        }\\r\\n    return t;\\r\\n}\\r\\n\\r\\nfunction __decorate(decorators, target, key, desc) {\\r\\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\\r\\n    if (typeof Reflect === \\\"object\\\" && typeof Reflect.decorate === \\\"function\\\") r = Reflect.decorate(decorators, target, key, desc);\\r\\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\\r\\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\\r\\n}\\r\\n\\r\\nfunction __param(paramIndex, decorator) {\\r\\n    return function (target, key) { decorator(target, key, paramIndex); }\\r\\n}\\r\\n\\r\\nfunction __metadata(metadataKey, metadataValue) {\\r\\n    if (typeof Reflect === \\\"object\\\" && typeof Reflect.metadata === \\\"function\\\") return Reflect.metadata(metadataKey, metadataValue);\\r\\n}\\r\\n\\r\\nfunction __awaiter(thisArg, _arguments, P, generator) {\\r\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\r\\n    return new (P || (P = Promise))(function (resolve, reject) {\\r\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\r\\n        function rejected(value) { try { step(generator[\\\"throw\\\"](value)); } catch (e) { reject(e); } }\\r\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\r\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\r\\n    });\\r\\n}\\r\\n\\r\\nfunction __generator(thisArg, body) {\\r\\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\\r\\n    return g = { next: verb(0), \\\"throw\\\": verb(1), \\\"return\\\": verb(2) }, typeof Symbol === \\\"function\\\" && (g[Symbol.iterator] = function() { return this; }), g;\\r\\n    function verb(n) { return function (v) { return step([n, v]); }; }\\r\\n    function step(op) {\\r\\n        if (f) throw new TypeError(\\\"Generator is already executing.\\\");\\r\\n        while (_) try {\\r\\n            if (f = 1, y && (t = op[0] & 2 ? y[\\\"return\\\"] : op[0] ? y[\\\"throw\\\"] || ((t = y[\\\"return\\\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\\r\\n            if (y = 0, t) op = [op[0] & 2, t.value];\\r\\n            switch (op[0]) {\\r\\n                case 0: case 1: t = op; break;\\r\\n                case 4: _.label++; return { value: op[1], done: false };\\r\\n                case 5: _.label++; y = op[1]; op = [0]; continue;\\r\\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\\r\\n                default:\\r\\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\\r\\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\\r\\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\\r\\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\\r\\n                    if (t[2]) _.ops.pop();\\r\\n                    _.trys.pop(); continue;\\r\\n            }\\r\\n            op = body.call(thisArg, _);\\r\\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\\r\\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\\r\\n    }\\r\\n}\\r\\n\\r\\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\\r\\n    if (k2 === undefined) k2 = k;\\r\\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\\r\\n}) : (function(o, m, k, k2) {\\r\\n    if (k2 === undefined) k2 = k;\\r\\n    o[k2] = m[k];\\r\\n});\\r\\n\\r\\nfunction __exportStar(m, o) {\\r\\n    for (var p in m) if (p !== \\\"default\\\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\\r\\n}\\r\\n\\r\\nfunction __values(o) {\\r\\n    var s = typeof Symbol === \\\"function\\\" && Symbol.iterator, m = s && o[s], i = 0;\\r\\n    if (m) return m.call(o);\\r\\n    if (o && typeof o.length === \\\"number\\\") return {\\r\\n        next: function () {\\r\\n            if (o && i >= o.length) o = void 0;\\r\\n            return { value: o && o[i++], done: !o };\\r\\n        }\\r\\n    };\\r\\n    throw new TypeError(s ? \\\"Object is not iterable.\\\" : \\\"Symbol.iterator is not defined.\\\");\\r\\n}\\r\\n\\r\\nfunction __read(o, n) {\\r\\n    var m = typeof Symbol === \\\"function\\\" && o[Symbol.iterator];\\r\\n    if (!m) return o;\\r\\n    var i = m.call(o), r, ar = [], e;\\r\\n    try {\\r\\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\\r\\n    }\\r\\n    catch (error) { e = { error: error }; }\\r\\n    finally {\\r\\n        try {\\r\\n            if (r && !r.done && (m = i[\\\"return\\\"])) m.call(i);\\r\\n        }\\r\\n        finally { if (e) throw e.error; }\\r\\n    }\\r\\n    return ar;\\r\\n}\\r\\n\\r\\n/** @deprecated */\\r\\nfunction __spread() {\\r\\n    for (var ar = [], i = 0; i < arguments.length; i++)\\r\\n        ar = ar.concat(__read(arguments[i]));\\r\\n    return ar;\\r\\n}\\r\\n\\r\\n/** @deprecated */\\r\\nfunction __spreadArrays() {\\r\\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\\r\\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\\r\\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\\r\\n            r[k] = a[j];\\r\\n    return r;\\r\\n}\\r\\n\\r\\nfunction __spreadArray(to, from) {\\r\\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\\r\\n        to[j] = from[i];\\r\\n    return to;\\r\\n}\\r\\n\\r\\nfunction __await(v) {\\r\\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\\r\\n}\\r\\n\\r\\nfunction __asyncGenerator(thisArg, _arguments, generator) {\\r\\n    if (!Symbol.asyncIterator) throw new TypeError(\\\"Symbol.asyncIterator is not defined.\\\");\\r\\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\\r\\n    return i = {}, verb(\\\"next\\\"), verb(\\\"throw\\\"), verb(\\\"return\\\"), i[Symbol.asyncIterator] = function () { return this; }, i;\\r\\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\\r\\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\\r\\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\\r\\n    function fulfill(value) { resume(\\\"next\\\", value); }\\r\\n    function reject(value) { resume(\\\"throw\\\", value); }\\r\\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\\r\\n}\\r\\n\\r\\nfunction __asyncDelegator(o) {\\r\\n    var i, p;\\r\\n    return i = {}, verb(\\\"next\\\"), verb(\\\"throw\\\", function (e) { throw e; }), verb(\\\"return\\\"), i[Symbol.iterator] = function () { return this; }, i;\\r\\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \\\"return\\\" } : f ? f(v) : v; } : f; }\\r\\n}\\r\\n\\r\\nfunction __asyncValues(o) {\\r\\n    if (!Symbol.asyncIterator) throw new TypeError(\\\"Symbol.asyncIterator is not defined.\\\");\\r\\n    var m = o[Symbol.asyncIterator], i;\\r\\n    return m ? m.call(o) : (o = typeof __values === \\\"function\\\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\\\"next\\\"), verb(\\\"throw\\\"), verb(\\\"return\\\"), i[Symbol.asyncIterator] = function () { return this; }, i);\\r\\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\\r\\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\\r\\n}\\r\\n\\r\\nfunction __makeTemplateObject(cooked, raw) {\\r\\n    if (Object.defineProperty) { Object.defineProperty(cooked, \\\"raw\\\", { value: raw }); } else { cooked.raw = raw; }\\r\\n    return cooked;\\r\\n};\\r\\n\\r\\nvar __setModuleDefault = Object.create ? (function(o, v) {\\r\\n    Object.defineProperty(o, \\\"default\\\", { enumerable: true, value: v });\\r\\n}) : function(o, v) {\\r\\n    o[\\\"default\\\"] = v;\\r\\n};\\r\\n\\r\\nfunction __importStar(mod) {\\r\\n    if (mod && mod.__esModule) return mod;\\r\\n    var result = {};\\r\\n    if (mod != null) for (var k in mod) if (k !== \\\"default\\\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\\r\\n    __setModuleDefault(result, mod);\\r\\n    return result;\\r\\n}\\r\\n\\r\\nfunction __importDefault(mod) {\\r\\n    return (mod && mod.__esModule) ? mod : { default: mod };\\r\\n}\\r\\n\\r\\nfunction __classPrivateFieldGet(receiver, privateMap) {\\r\\n    if (!privateMap.has(receiver)) {\\r\\n        throw new TypeError(\\\"attempted to get private field on non-instance\\\");\\r\\n    }\\r\\n    return privateMap.get(receiver);\\r\\n}\\r\\n\\r\\nfunction __classPrivateFieldSet(receiver, privateMap, value) {\\r\\n    if (!privateMap.has(receiver)) {\\r\\n        throw new TypeError(\\\"attempted to set private field on non-instance\\\");\\r\\n    }\\r\\n    privateMap.set(receiver, value);\\r\\n    return value;\\r\\n}\\r\\n\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/rxjs/node_modules/tslib/tslib.es6.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js ***!\n  \\*********************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ _arrayLikeToArray)\\n/* harmony export */ });\\nfunction _arrayLikeToArray(arr, len) {\\n  if (len == null || len > arr.length) len = arr.length;\\n\\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\\n    arr2[i] = arr[i];\\n  }\\n\\n  return arr2;\\n}\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js ***!\n  \\*******************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ _arrayWithHoles)\\n/* harmony export */ });\\nfunction _arrayWithHoles(arr) {\\n  if (Array.isArray(arr)) return arr;\\n}\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\":\n/*!**************************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js ***!\n  \\**************************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ _assertThisInitialized)\\n/* harmony export */ });\\nfunction _assertThisInitialized(self) {\\n  if (self === void 0) {\\n    throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\");\\n  }\\n\\n  return self;\\n}\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js ***!\n  \\*********************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ _asyncToGenerator)\\n/* harmony export */ });\\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\\n  try {\\n    var info = gen[key](arg);\\n    var value = info.value;\\n  } catch (error) {\\n    reject(error);\\n    return;\\n  }\\n\\n  if (info.done) {\\n    resolve(value);\\n  } else {\\n    Promise.resolve(value).then(_next, _throw);\\n  }\\n}\\n\\nfunction _asyncToGenerator(fn) {\\n  return function () {\\n    var self = this,\\n        args = arguments;\\n    return new Promise(function (resolve, reject) {\\n      var gen = fn.apply(self, args);\\n\\n      function _next(value) {\\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \\\"next\\\", value);\\n      }\\n\\n      function _throw(err) {\\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \\\"throw\\\", err);\\n      }\\n\\n      _next(undefined);\\n    });\\n  };\\n}\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!\n  \\*******************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ _classCallCheck)\\n/* harmony export */ });\\nfunction _classCallCheck(instance, Constructor) {\\n  if (!(instance instanceof Constructor)) {\\n    throw new TypeError(\\\"Cannot call a class as a function\\\");\\n  }\\n}\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/@babel/runtime/helpers/esm/classCallCheck.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/esm/construct.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/esm/construct.js ***!\n  \\**************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ _construct)\\n/* harmony export */ });\\n/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf.js */ \\\"./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\\\");\\n/* harmony import */ var _isNativeReflectConstruct_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isNativeReflectConstruct.js */ \\\"./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js\\\");\\n\\n\\nfunction _construct(Parent, args, Class) {\\n  if ((0,_isNativeReflectConstruct_js__WEBPACK_IMPORTED_MODULE_1__.default)()) {\\n    _construct = Reflect.construct;\\n  } else {\\n    _construct = function _construct(Parent, args, Class) {\\n      var a = [null];\\n      a.push.apply(a, args);\\n      var Constructor = Function.bind.apply(Parent, a);\\n      var instance = new Constructor();\\n      if (Class) (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__.default)(instance, Class.prototype);\\n      return instance;\\n    };\\n  }\\n\\n  return _construct.apply(null, arguments);\\n}\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/@babel/runtime/helpers/esm/construct.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/esm/createClass.js ***!\n  \\****************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ _createClass)\\n/* harmony export */ });\\nfunction _defineProperties(target, props) {\\n  for (var i = 0; i < props.length; i++) {\\n    var descriptor = props[i];\\n    descriptor.enumerable = descriptor.enumerable || false;\\n    descriptor.configurable = true;\\n    if (\\\"value\\\" in descriptor) descriptor.writable = true;\\n    Object.defineProperty(target, descriptor.key, descriptor);\\n  }\\n}\\n\\nfunction _createClass(Constructor, protoProps, staticProps) {\\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\\n  if (staticProps) _defineProperties(Constructor, staticProps);\\n  return Constructor;\\n}\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/@babel/runtime/helpers/esm/createClass.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!\n  \\*******************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ _defineProperty)\\n/* harmony export */ });\\nfunction _defineProperty(obj, key, value) {\\n  if (key in obj) {\\n    Object.defineProperty(obj, key, {\\n      value: value,\\n      enumerable: true,\\n      configurable: true,\\n      writable: true\\n    });\\n  } else {\\n    obj[key] = value;\\n  }\\n\\n  return obj;\\n}\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/@babel/runtime/helpers/esm/defineProperty.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js ***!\n  \\*******************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ _getPrototypeOf)\\n/* harmony export */ });\\nfunction _getPrototypeOf(o) {\\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\\n    return o.__proto__ || Object.getPrototypeOf(o);\\n  };\\n  return _getPrototypeOf(o);\\n}\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/esm/inherits.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/esm/inherits.js ***!\n  \\*************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ _inherits)\\n/* harmony export */ });\\n/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf.js */ \\\"./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\\\");\\n\\nfunction _inherits(subClass, superClass) {\\n  if (typeof superClass !== \\\"function\\\" && superClass !== null) {\\n    throw new TypeError(\\\"Super expression must either be null or a function\\\");\\n  }\\n\\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\\n    constructor: {\\n      value: subClass,\\n      writable: true,\\n      configurable: true\\n    }\\n  });\\n  if (superClass) (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__.default)(subClass, superClass);\\n}\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/@babel/runtime/helpers/esm/inherits.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/esm/isNativeFunction.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/esm/isNativeFunction.js ***!\n  \\*********************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ _isNativeFunction)\\n/* harmony export */ });\\nfunction _isNativeFunction(fn) {\\n  return Function.toString.call(fn).indexOf(\\\"[native code]\\\") !== -1;\\n}\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/@babel/runtime/helpers/esm/isNativeFunction.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js\":\n/*!*****************************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js ***!\n  \\*****************************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ _isNativeReflectConstruct)\\n/* harmony export */ });\\nfunction _isNativeReflectConstruct() {\\n  if (typeof Reflect === \\\"undefined\\\" || !Reflect.construct) return false;\\n  if (Reflect.construct.sham) return false;\\n  if (typeof Proxy === \\\"function\\\") return true;\\n\\n  try {\\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\\n    return true;\\n  } catch (e) {\\n    return false;\\n  }\\n}\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js\":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js ***!\n  \\*************************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ _iterableToArrayLimit)\\n/* harmony export */ });\\nfunction _iterableToArrayLimit(arr, i) {\\n  var _i = arr == null ? null : typeof Symbol !== \\\"undefined\\\" && arr[Symbol.iterator] || arr[\\\"@@iterator\\\"];\\n\\n  if (_i == null) return;\\n  var _arr = [];\\n  var _n = true;\\n  var _d = false;\\n\\n  var _s, _e;\\n\\n  try {\\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\\n      _arr.push(_s.value);\\n\\n      if (i && _arr.length === i) break;\\n    }\\n  } catch (err) {\\n    _d = true;\\n    _e = err;\\n  } finally {\\n    try {\\n      if (!_n && _i[\\\"return\\\"] != null) _i[\\\"return\\\"]();\\n    } finally {\\n      if (_d) throw _e;\\n    }\\n  }\\n\\n  return _arr;\\n}\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js ***!\n  \\********************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ _nonIterableRest)\\n/* harmony export */ });\\nfunction _nonIterableRest() {\\n  throw new TypeError(\\\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\");\\n}\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\":\n/*!******************************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js ***!\n  \\******************************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ _possibleConstructorReturn)\\n/* harmony export */ });\\n/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ \\\"./node_modules/@babel/runtime/helpers/esm/typeof.js\\\");\\n/* harmony import */ var _assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assertThisInitialized.js */ \\\"./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\\\");\\n\\n\\nfunction _possibleConstructorReturn(self, call) {\\n  if (call && ((0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__.default)(call) === \\\"object\\\" || typeof call === \\\"function\\\")) {\\n    return call;\\n  } else if (call !== void 0) {\\n    throw new TypeError(\\\"Derived constructors may only return object or undefined\\\");\\n  }\\n\\n  return (0,_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_1__.default)(self);\\n}\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!\n  \\*******************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ _setPrototypeOf)\\n/* harmony export */ });\\nfunction _setPrototypeOf(o, p) {\\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\\n    o.__proto__ = p;\\n    return o;\\n  };\\n\\n  return _setPrototypeOf(o, p);\\n}\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/esm/slicedToArray.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js ***!\n  \\******************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ _slicedToArray)\\n/* harmony export */ });\\n/* harmony import */ var _arrayWithHoles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithHoles.js */ \\\"./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js\\\");\\n/* harmony import */ var _iterableToArrayLimit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArrayLimit.js */ \\\"./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js\\\");\\n/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ \\\"./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js\\\");\\n/* harmony import */ var _nonIterableRest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nonIterableRest.js */ \\\"./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js\\\");\\n\\n\\n\\n\\nfunction _slicedToArray(arr, i) {\\n  return (0,_arrayWithHoles_js__WEBPACK_IMPORTED_MODULE_0__.default)(arr) || (0,_iterableToArrayLimit_js__WEBPACK_IMPORTED_MODULE_1__.default)(arr, i) || (0,_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__.default)(arr, i) || (0,_nonIterableRest_js__WEBPACK_IMPORTED_MODULE_3__.default)();\\n}\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/@babel/runtime/helpers/esm/slicedToArray.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/esm/typeof.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/esm/typeof.js ***!\n  \\***********************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ _typeof)\\n/* harmony export */ });\\nfunction _typeof(obj) {\\n  \\\"@babel/helpers - typeof\\\";\\n\\n  if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") {\\n    _typeof = function _typeof(obj) {\\n      return typeof obj;\\n    };\\n  } else {\\n    _typeof = function _typeof(obj) {\\n      return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj;\\n    };\\n  }\\n\\n  return _typeof(obj);\\n}\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/@babel/runtime/helpers/esm/typeof.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js\":\n/*!*******************************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js ***!\n  \\*******************************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ _unsupportedIterableToArray)\\n/* harmony export */ });\\n/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ \\\"./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js\\\");\\n\\nfunction _unsupportedIterableToArray(o, minLen) {\\n  if (!o) return;\\n  if (typeof o === \\\"string\\\") return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__.default)(o, minLen);\\n  var n = Object.prototype.toString.call(o).slice(8, -1);\\n  if (n === \\\"Object\\\" && o.constructor) n = o.constructor.name;\\n  if (n === \\\"Map\\\" || n === \\\"Set\\\") return Array.from(o);\\n  if (n === \\\"Arguments\\\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__.default)(o, minLen);\\n}\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js ***!\n  \\********************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ _wrapNativeSuper)\\n/* harmony export */ });\\n/* harmony import */ var _getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getPrototypeOf.js */ \\\"./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\\\");\\n/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setPrototypeOf.js */ \\\"./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\\\");\\n/* harmony import */ var _isNativeFunction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isNativeFunction.js */ \\\"./node_modules/@babel/runtime/helpers/esm/isNativeFunction.js\\\");\\n/* harmony import */ var _construct_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./construct.js */ \\\"./node_modules/@babel/runtime/helpers/esm/construct.js\\\");\\n\\n\\n\\n\\nfunction _wrapNativeSuper(Class) {\\n  var _cache = typeof Map === \\\"function\\\" ? new Map() : undefined;\\n\\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\\n    if (Class === null || !(0,_isNativeFunction_js__WEBPACK_IMPORTED_MODULE_2__.default)(Class)) return Class;\\n\\n    if (typeof Class !== \\\"function\\\") {\\n      throw new TypeError(\\\"Super expression must either be null or a function\\\");\\n    }\\n\\n    if (typeof _cache !== \\\"undefined\\\") {\\n      if (_cache.has(Class)) return _cache.get(Class);\\n\\n      _cache.set(Class, Wrapper);\\n    }\\n\\n    function Wrapper() {\\n      return (0,_construct_js__WEBPACK_IMPORTED_MODULE_3__.default)(Class, arguments, (0,_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__.default)(this).constructor);\\n    }\\n\\n    Wrapper.prototype = Object.create(Class.prototype, {\\n      constructor: {\\n        value: Wrapper,\\n        enumerable: false,\\n        writable: true,\\n        configurable: true\\n      }\\n    });\\n    return (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__.default)(Wrapper, Class);\\n  };\\n\\n  return _wrapNativeSuper(Class);\\n}\\n\\n//# sourceURL=webpack://DerivAPIBasic/./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js?\");\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_466557__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_466557__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/compat get default export */\n/******/ \t(() => {\n/******/ \t\t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t\t__nested_webpack_require_466557__.n = (module) => {\n/******/ \t\t\tvar getter = module && module.__esModule ?\n/******/ \t\t\t\t() => (module['default']) :\n/******/ \t\t\t\t() => (module);\n/******/ \t\t\t__nested_webpack_require_466557__.d(getter, { a: getter });\n/******/ \t\t\treturn getter;\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__nested_webpack_require_466557__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__nested_webpack_require_466557__.o(definition, key) && !__nested_webpack_require_466557__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__nested_webpack_require_466557__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__nested_webpack_require_466557__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module can't be inlined because the eval devtool is used.\n/******/ \tvar __webpack_exports__ = __nested_webpack_require_466557__(\"./src/deriv_api/DerivAPIBasic.js\");\n/******/ \t__webpack_exports__ = __webpack_exports__.default;\n/******/ \t\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZXJpdi9kZXJpdi1hcGkvZGlzdC9EZXJpdkFQSUJhc2ljLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZXJpdi9kZXJpdi1hcGkvZGlzdC9EZXJpdkFQSUJhc2ljLmpzP2E2YzQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIEFUVEVOVElPTjogVGhlIFwiZXZhbFwiIGRldnRvb2wgaGFzIGJlZW4gdXNlZCAobWF5YmUgYnkgZGVmYXVsdCBpbiBtb2RlOiBcImRldmVsb3BtZW50XCIpLlxuICogVGhpcyBkZXZ0b29sIGlzIG5laXRoZXIgbWFkZSBmb3IgcHJvZHVjdGlvbiBub3IgZm9yIHJlYWRhYmxlIG91dHB1dCBmaWxlcy5cbiAqIEl0IHVzZXMgXCJldmFsKClcIiBjYWxscyB0byBjcmVhdGUgYSBzZXBhcmF0ZSBzb3VyY2UgZmlsZSBpbiB0aGUgYnJvd3NlciBkZXZ0b29scy5cbiAqIElmIHlvdSBhcmUgdHJ5aW5nIHRvIHJlYWQgdGhlIG91dHB1dCBmaWxlLCBzZWxlY3QgYSBkaWZmZXJlbnQgZGV2dG9vbCAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL2RldnRvb2wvKVxuICogb3IgZGlzYWJsZSB0aGUgZGVmYXVsdCBkZXZ0b29sIHdpdGggXCJkZXZ0b29sOiBmYWxzZVwiLlxuICogSWYgeW91IGFyZSBsb29raW5nIGZvciBwcm9kdWN0aW9uLXJlYWR5IG91dHB1dCBmaWxlcywgc2VlIG1vZGU6IFwicHJvZHVjdGlvblwiIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmZpZ3VyYXRpb24vbW9kZS8pLlxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJEZXJpdkFQSUJhc2ljXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkRlcml2QVBJQmFzaWNcIl0gPSBmYWN0b3J5KCk7XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qc1xcXCIpO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZXJpdl9hcGkvQ2FjaGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2Rlcml2X2FwaS9DYWNoZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBDYWNoZSlcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19hc3luY1RvR2VuZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FzeW5jVG9HZW5lcmF0b3IuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19jbGFzc0NhbGxDaGVja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjayAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2suanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19jcmVhdGVDbGFzc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19pbmhlcml0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19nZXRQcm90b3R5cGVPZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZ2V0UHJvdG90eXBlT2YuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfcmVnZW5lcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmFiZWxfcnVudGltZV9yZWdlbmVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9iYWJlbF9ydW50aW1lX3JlZ2VuZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfRGVyaXZBUElDYWxsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9EZXJpdkFQSUNhbGxzICovIFxcXCIuL3NyYy9kZXJpdl9hcGkvRGVyaXZBUElDYWxscy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Vycm9ycyAqLyBcXFwiLi9zcmMvZGVyaXZfYXBpL2Vycm9ycy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMgKi8gXFxcIi4vc3JjL2Rlcml2X2FwaS91dGlscy5qc1xcXCIpO1xcblxcblxcblxcblxcblxcblxcblxcblxcbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9ICgwLF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZ2V0UHJvdG90eXBlT2ZfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5kZWZhdWx0KShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsX2JhYmVsX3J1bnRpbWVfaGVscGVyc19nZXRQcm90b3R5cGVPZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLmRlZmF1bHQpKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiAoMCxfYmFiZWxfcnVudGltZV9oZWxwZXJzX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5kZWZhdWx0KSh0aGlzLCByZXN1bHQpOyB9OyB9XFxuXFxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcXFwidW5kZWZpbmVkXFxcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXFxcImZ1bmN0aW9uXFxcIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBDYWNoZSAtIEEgY2xhc3MgZm9yIGltcGxlbWVudGluZyBpbi1tZW1vcnkgYW5kIHBlcnNpc3RlbnQgY2FjaGVcXG4gKlxcbiAqIFRoZSByZWFsIGltcGxlbWVudGF0aW9uIG9mIHRoZSB1bmRlcmx5aW5nIGNhY2hlIGlzIGRlbGVnYXRlZCB0byB0aGUgc3RvcmFnZVxcbiAqIG9iamVjdCAoU2VlIHRoZSBwYXJhbXMpLlxcbiAqXFxuICogVGhlIHN0b3JhZ2Ugb2JqZWN0IG5lZWRzIHRvIGltcGxlbWVudCB0aGUgQVBJLlxcbiAqXFxuICogQGV4YW1wbGVcXG4gKiAvLyBSZWFkIHRoZSBsYXRlc3QgYWN0aXZlIHN5bWJvbHNcXG4gKiBjb25zdCBzeW1ib2xzID0gYXdhaXQgYXBpLmFjdGl2ZVN5bWJvbHMoKTtcXG4gKlxcbiAqIC8vIFJlYWQgdGhlIGRhdGEgZnJvbSBjYWNoZSBpZiBhdmFpbGFibGVcXG4gKiBjb25zdCBjYWNoZWRfc3ltYm9scyA9IGF3YWl0IGFwaS5jYWNoZS5hY3RpdmVTeW1ib2xzKCk7XFxuICpcXG4gKiBAcGFyYW0ge0Rlcml2QVBJQmFzaWN9IGFwaSBBUEkgaW5zdGFuY2UgdG8gZ2V0IGRhdGEgdGhhdCBpcyBub3QgY2FjaGVkXFxuICogQHBhcmFtIHtPYmplY3R9IHN0b3JhZ2UgQSBzdG9yYWdlIGluc3RhbmNlIHRvIHVzZSBmb3IgY2FjaGluZ1xcbiAqL1xcblxcbnZhciBDYWNoZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Rlcml2QVBJQ2FsbHMpIHtcXG4gICgwLF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfaW5oZXJpdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5kZWZhdWx0KShDYWNoZSwgX0Rlcml2QVBJQ2FsbHMpO1xcblxcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihDYWNoZSk7XFxuXFxuICBmdW5jdGlvbiBDYWNoZShhcGksIHN0b3JhZ2UpIHtcXG4gICAgdmFyIF90aGlzO1xcblxcbiAgICAoMCxfYmFiZWxfcnVudGltZV9oZWxwZXJzX2NsYXNzQ2FsbENoZWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uZGVmYXVsdCkodGhpcywgQ2FjaGUpO1xcblxcbiAgICBpZiAoIWFwaSkge1xcbiAgICAgIHRocm93IG5ldyBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18uQ29uc3RydWN0aW9uRXJyb3IoJ0NhY2hlIG9iamVjdCBuZWVkcyBhbiBBUEkgdG8gd29yaycpO1xcbiAgICB9XFxuXFxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XFxuICAgIF90aGlzLmFwaSA9IGFwaTtcXG4gICAgX3RoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XFxuICAgIHJldHVybiBfdGhpcztcXG4gIH1cXG5cXG4gICgwLF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfY3JlYXRlQ2xhc3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5kZWZhdWx0KShDYWNoZSwgW3tcXG4gICAga2V5OiBcXFwic2VuZFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIF9zZW5kID0gKDAsX2JhYmVsX3J1bnRpbWVfaGVscGVyc19hc3luY1RvR2VuZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZGVmYXVsdCkoIC8qI19fUFVSRV9fKi9fYmFiZWxfcnVudGltZV9yZWdlbmVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fX2RlZmF1bHQoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocmVxdWVzdCkge1xcbiAgICAgICAgdmFyIHJlc3BvbnNlO1xcbiAgICAgICAgcmV0dXJuIF9iYWJlbF9ydW50aW1lX3JlZ2VuZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19fZGVmYXVsdCgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcXG4gICAgICAgICAgd2hpbGUgKDEpIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XFxuICAgICAgICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYXMocmVxdWVzdCk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgICAgICAgIGlmICghX2NvbnRleHQuc2VudCkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXFxcInJldHVyblxcXCIsIHRoaXMuZ2V0KHJlcXVlc3QpKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgNDpcXG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaS5zZW5kKHJlcXVlc3QpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA2OlxcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0LnNlbnQ7XFxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5O1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXQocmVxdWVzdCwgcmVzcG9uc2UpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA5OlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFxcXCJyZXR1cm5cXFwiLCByZXNwb25zZSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDEwOlxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZW5kXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICBmdW5jdGlvbiBzZW5kKF94KSB7XFxuICAgICAgICByZXR1cm4gX3NlbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHNlbmQ7XFxuICAgIH0oKVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJoYXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBfaGFzID0gKDAsX2JhYmVsX3J1bnRpbWVfaGVscGVyc19hc3luY1RvR2VuZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZGVmYXVsdCkoIC8qI19fUFVSRV9fKi9fYmFiZWxfcnVudGltZV9yZWdlbmVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fX2RlZmF1bHQoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHJlcXVlc3QpIHtcXG4gICAgICAgIHJldHVybiBfYmFiZWxfcnVudGltZV9yZWdlbmVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fX2RlZmF1bHQoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcXG4gICAgICAgICAgd2hpbGUgKDEpIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXFxcInJldHVyblxcXCIsIHRoaXMuc3RvcmFnZS5oYXMoKDAsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18ub2JqZWN0VG9DYWNoZUtleSkocmVxdWVzdCkpKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMTpcXG4gICAgICAgICAgICAgIGNhc2UgXFxcImVuZFxcXCI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICBmdW5jdGlvbiBoYXMoX3gyKSB7XFxuICAgICAgICByZXR1cm4gX2hhcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gaGFzO1xcbiAgICB9KClcXG4gICAgLyogUmVkaXJlY3RlZCB0byB0aGUgbWV0aG9kIGRlZmluZWQgYnkgdGhlIHN0b3JhZ2UgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZ2V0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgX2dldCA9ICgwLF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfYXN5bmNUb0dlbmVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmRlZmF1bHQpKCAvKiNfX1BVUkVfXyovX2JhYmVsX3J1bnRpbWVfcmVnZW5lcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX19kZWZhdWx0KCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhyZXF1ZXN0KSB7XFxuICAgICAgICByZXR1cm4gX2JhYmVsX3J1bnRpbWVfcmVnZW5lcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX19kZWZhdWx0KCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XFxuICAgICAgICAgIHdoaWxlICgxKSB7XFxuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XFxuICAgICAgICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFxcXCJyZXR1cm5cXFwiLCB0aGlzLnN0b3JhZ2UuZ2V0KCgwLF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fLm9iamVjdFRvQ2FjaGVLZXkpKHJlcXVlc3QpKSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDE6XFxuICAgICAgICAgICAgICBjYXNlIFxcXCJlbmRcXFwiOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcXG4gICAgICB9KSk7XFxuXFxuICAgICAgZnVuY3Rpb24gZ2V0KF94Mykge1xcbiAgICAgICAgcmV0dXJuIF9nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGdldDtcXG4gICAgfSgpXFxuICAgIC8qIFJlZGlyZWN0ZWQgdG8gdGhlIG1ldGhvZCBkZWZpbmVkIGJ5IHRoZSBzdG9yYWdlICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImdldEJ5TXNnVHlwZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIF9nZXRCeU1zZ1R5cGUgPSAoMCxfYmFiZWxfcnVudGltZV9oZWxwZXJzX2FzeW5jVG9HZW5lcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5kZWZhdWx0KSggLyojX19QVVJFX18qL19iYWJlbF9ydW50aW1lX3JlZ2VuZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19fZGVmYXVsdCgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQodHlwZSkge1xcbiAgICAgICAgcmV0dXJuIF9iYWJlbF9ydW50aW1lX3JlZ2VuZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19fZGVmYXVsdCgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xcbiAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcXFwicmV0dXJuXFxcIiwgdGhpcy5zdG9yYWdlLmdldEJ5TXNnVHlwZSh0eXBlKSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDE6XFxuICAgICAgICAgICAgICBjYXNlIFxcXCJlbmRcXFwiOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIF9jYWxsZWU0LCB0aGlzKTtcXG4gICAgICB9KSk7XFxuXFxuICAgICAgZnVuY3Rpb24gZ2V0QnlNc2dUeXBlKF94NCkge1xcbiAgICAgICAgcmV0dXJuIF9nZXRCeU1zZ1R5cGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGdldEJ5TXNnVHlwZTtcXG4gICAgfSgpXFxuICAgIC8qIFJlZGlyZWN0ZWQgdG8gdGhlIG1ldGhvZCBkZWZpbmVkIGJ5IHRoZSBzdG9yYWdlICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInNldFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIF9zZXQgPSAoMCxfYmFiZWxfcnVudGltZV9oZWxwZXJzX2FzeW5jVG9HZW5lcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5kZWZhdWx0KSggLyojX19QVVJFX18qL19iYWJlbF9ydW50aW1lX3JlZ2VuZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19fZGVmYXVsdCgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUocmVxdWVzdCwgcmVzcG9uc2UpIHtcXG4gICAgICAgIHJldHVybiBfYmFiZWxfcnVudGltZV9yZWdlbmVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fX2RlZmF1bHQoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcXG4gICAgICAgICAgd2hpbGUgKDEpIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXFxcInJldHVyblxcXCIsIHRoaXMuc3RvcmFnZS5zZXQoKDAsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18ub2JqZWN0VG9DYWNoZUtleSkocmVxdWVzdCksIHJlc3BvbnNlKSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDE6XFxuICAgICAgICAgICAgICBjYXNlIFxcXCJlbmRcXFwiOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIF9jYWxsZWU1LCB0aGlzKTtcXG4gICAgICB9KSk7XFxuXFxuICAgICAgZnVuY3Rpb24gc2V0KF94NSwgX3g2KSB7XFxuICAgICAgICByZXR1cm4gX3NldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gc2V0O1xcbiAgICB9KClcXG4gIH1dKTtcXG5cXG4gIHJldHVybiBDYWNoZTtcXG59KF9EZXJpdkFQSUNhbGxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18uZGVmYXVsdCk7XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL3NyYy9kZXJpdl9hcGkvQ2FjaGUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZXJpdl9hcGkvQ3VzdG9tUHJvbWlzZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kZXJpdl9hcGkvQ3VzdG9tUHJvbWlzZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIEN1c3RvbVByb21pc2UpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfY2xhc3NDYWxsQ2hlY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2sgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfY3JlYXRlQ2xhc3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfaW5oZXJpdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZ2V0UHJvdG90eXBlT2ZfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfd3JhcE5hdGl2ZVN1cGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBOYXRpdmVTdXBlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vd3JhcE5hdGl2ZVN1cGVyLmpzXFxcIik7XFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gKDAsX2JhYmVsX3J1bnRpbWVfaGVscGVyc19nZXRQcm90b3R5cGVPZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLmRlZmF1bHQpKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCxfYmFiZWxfcnVudGltZV9oZWxwZXJzX2dldFByb3RvdHlwZU9mX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uZGVmYXVsdCkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLmRlZmF1bHQpKHRoaXMsIHJlc3VsdCk7IH07IH1cXG5cXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFxcXCJ1bmRlZmluZWRcXFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcXFwiZnVuY3Rpb25cXFwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxcblxcbnZhciBDdXN0b21Qcm9taXNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUHJvbWlzZSkge1xcbiAgKDAsX2JhYmVsX3J1bnRpbWVfaGVscGVyc19pbmhlcml0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmRlZmF1bHQpKEN1c3RvbVByb21pc2UsIF9Qcm9taXNlKTtcXG5cXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQ3VzdG9tUHJvbWlzZSk7XFxuXFxuICBmdW5jdGlvbiBDdXN0b21Qcm9taXNlKCkge1xcbiAgICB2YXIgX3RoaXM7XFxuXFxuICAgIHZhciBjYiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZnVuY3Rpb24gKCkge307XFxuXFxuICAgICgwLF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfY2xhc3NDYWxsQ2hlY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5kZWZhdWx0KSh0aGlzLCBDdXN0b21Qcm9taXNlKTtcXG5cXG4gICAgdmFyIHJlc29sdmU7XFxuICAgIHZhciByZWplY3Q7XFxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZnVuY3Rpb24gKHBhcmVudFJlc29sdmUsIHBhcmVudFJlamVjdCkge1xcbiAgICAgIHJlc29sdmUgPSBwYXJlbnRSZXNvbHZlO1xcbiAgICAgIHJlamVjdCA9IHBhcmVudFJlamVjdDtcXG4gICAgfSk7XFxuICAgIGNiKHJlc29sdmUsIHJlamVjdCk7XFxuICAgIF90aGlzLnJlc29sdmVDYWxsYmFjayA9IHJlc29sdmU7XFxuICAgIF90aGlzLnJlamVjdENhbGxiYWNrID0gcmVqZWN0O1xcbiAgICBfdGhpcy5zdGF0ZSA9ICdwZW5kaW5nJztcXG4gICAgcmV0dXJuIF90aGlzO1xcbiAgfVxcblxcbiAgKDAsX2JhYmVsX3J1bnRpbWVfaGVscGVyc19jcmVhdGVDbGFzc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmRlZmF1bHQpKEN1c3RvbVByb21pc2UsIFt7XFxuICAgIGtleTogXFxcInJlc29sdmVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZShkYXRhKSB7XFxuICAgICAgdGhpcy5yZXNvbHZlQ2FsbGJhY2soZGF0YSk7XFxuICAgICAgdGhpcy5zdGF0ZSA9ICdyZXNvbHZlZCc7XFxuICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicmVqZWN0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlamVjdChlcnJvcikge1xcbiAgICAgIHRoaXMucmVqZWN0Q2FsbGJhY2soZXJyb3IpO1xcbiAgICAgIHRoaXMuc3RhdGUgPSAncmVqZWN0ZWQnO1xcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcImlzUGVuZGluZ1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1BlbmRpbmcoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09ICdwZW5kaW5nJztcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJpc1JlamVjdGVkXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzUmVqZWN0ZWQoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09ICdyZWplY3RlZCc7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiaXNSZXNvbHZlZFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1Jlc29sdmVkKCkge1xcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSAncmVzb2x2ZWQnO1xcbiAgICB9XFxuICB9XSwgW3tcXG4gICAga2V5OiBcXFwid3JhcFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3cmFwKHByb21pc2UpIHtcXG4gICAgICBpZiAocHJvbWlzZSBpbnN0YW5jZW9mIHRoaXMpIHJldHVybiBwcm9taXNlO1xcbiAgICAgIHZhciBjdXN0b21fcHJvbWlzZSA9IG5ldyB0aGlzKCk7XFxuICAgICAgcHJvbWlzZS50aGVuKGN1c3RvbV9wcm9taXNlLnJlc29sdmUuYmluZChjdXN0b21fcHJvbWlzZSksIGN1c3RvbV9wcm9taXNlLnJlamVjdC5iaW5kKGN1c3RvbV9wcm9taXNlKSk7XFxuICAgICAgcmV0dXJuIGN1c3RvbV9wcm9taXNlO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gQ3VzdG9tUHJvbWlzZTtcXG59KCAvKiNfX1BVUkVfXyovKDAsX2JhYmVsX3J1bnRpbWVfaGVscGVyc193cmFwTmF0aXZlU3VwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5kZWZhdWx0KShQcm9taXNlKSk7XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL3NyYy9kZXJpdl9hcGkvQ3VzdG9tUHJvbWlzZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2Rlcml2X2FwaS9EZXJpdkFQSUJhc2ljLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2Rlcml2X2FwaS9EZXJpdkFQSUJhc2ljLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRGVyaXZBUElCYXNpYylcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19zbGljZWRUb0FycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXkuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc190eXBlb2ZfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2YuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19hc3luY1RvR2VuZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FzeW5jVG9HZW5lcmF0b3IuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19jbGFzc0NhbGxDaGVja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjayAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2suanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19jcmVhdGVDbGFzc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19hc3NlcnRUaGlzSW5pdGlhbGl6ZWRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19pbmhlcml0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19nZXRQcm90b3R5cGVPZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZ2V0UHJvdG90eXBlT2YuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfcmVnZW5lcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmFiZWxfcnVudGltZV9yZWdlbmVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9iYWJlbF9ydW50aW1lX3JlZ2VuZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciByeGpzX29wZXJhdG9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHJ4anMvb3BlcmF0b3JzICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvZmlyc3QuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcnhqc19vcGVyYXRvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE4X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISByeGpzL29wZXJhdG9ycyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL2ZpbHRlci5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciByeGpzX29wZXJhdG9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHJ4anMvb3BlcmF0b3JzICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvc2hhcmUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcnhqc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHJ4anMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL1N1YmplY3QuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX0NhY2hlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9DYWNoZSAqLyBcXFwiLi9zcmMvZGVyaXZfYXBpL0NhY2hlLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9DdXN0b21Qcm9taXNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9DdXN0b21Qcm9taXNlICovIFxcXCIuL3NyYy9kZXJpdl9hcGkvQ3VzdG9tUHJvbWlzZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfRGVyaXZBUElDYWxsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vRGVyaXZBUElDYWxscyAqLyBcXFwiLi9zcmMvZGVyaXZfYXBpL0Rlcml2QVBJQ2FsbHMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX0luTWVtb3J5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9Jbk1lbW9yeSAqLyBcXFwiLi9zcmMvZGVyaXZfYXBpL0luTWVtb3J5LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9TdWJzY3JpcHRpb25NYW5hZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9TdWJzY3JpcHRpb25NYW5hZ2VyICovIFxcXCIuL3NyYy9kZXJpdl9hcGkvU3Vic2NyaXB0aW9uTWFuYWdlci5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9lcnJvcnMgKi8gXFxcIi4vc3JjL2Rlcml2X2FwaS9lcnJvcnMuanNcXFwiKTtcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSAoMCxfYmFiZWxfcnVudGltZV9oZWxwZXJzX2dldFByb3RvdHlwZU9mX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18uZGVmYXVsdCkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZ2V0UHJvdG90eXBlT2ZfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXy5kZWZhdWx0KSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsX2JhYmVsX3J1bnRpbWVfaGVscGVyc19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18uZGVmYXVsdCkodGhpcywgcmVzdWx0KTsgfTsgfVxcblxcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXFxcInVuZGVmaW5lZFxcXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFxcXCJmdW5jdGlvblxcXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuLyoqXFxuICogVGhlIG1pbmltdW0gZnVuY3Rpb25hbGl0eSBwcm92aWRlZCBieSBEZXJpdkFQSSwgcHJvdmlkZXMgZGlyZWN0IGNhbGxzIHRvIHRoZVxcbiAqIEFQSS5cXG4gKiBgYXBpLmNhY2hlYCBpcyBhdmFpbGFibGUgaWYgeW91IHdhbnQgdG8gdXNlIHRoZSBjYWNoZWQgZGF0YSAoc2VlIHtAbGluayBDYWNoZX0pXFxuICpcXG4gKiBAZXhhbXBsZVxcbiAqIGNvbnN0IGFwaUZyb21PcGVuQ29ubmVjdGlvbiA9IG5ldyBEZXJpdkFQSSh7IGNvbm5lY3Rpb24gfSk7XFxuICogY29uc3QgYXBpRnJvbUVuZHBvaW50ID0gbmV3IERlcml2QVBJKHsgZW5kcG9pbnQ6ICd3cy5iaW5hcnl3cy5jb20nLCBhcHBfaWQ6IDEyMzQgfSk7XFxuICpcXG4gKiBAcGFyYW0ge09iamVjdH0gICAgIG9wdGlvbnNcXG4gKiBAcGFyYW0ge1dlYlNvY2tldD19IG9wdGlvbnMuY29ubmVjdGlvbiAtIEEgcmVhZHkgdG8gdXNlIGNvbm5lY3Rpb25cXG4gKiBAcGFyYW0ge1N0cmluZ30gICAgIG9wdGlvbnMuZW5kcG9pbnQgICAtIEFQSSBzZXJ2ZXIgdG8gY29ubmVjdCB0b1xcbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgb3B0aW9ucy5hcHBfaWQgICAgIC0gQXBwbGljYXRpb24gSUQgb2YgdGhlIEFQSSB1c2VyXFxuICogQHBhcmFtIHtTdHJpbmd9ICAgICBvcHRpb25zLmxhbmcgICAgICAgLSBMYW5ndWFnZSBvZiB0aGUgQVBJIGNvbW11bmljYXRpb25cXG4gKiBAcGFyYW0ge1N0cmluZ30gICAgIG9wdGlvbnMuYnJhbmQgICAgICAtIEJyYW5kIG5hbWVcXG4gKiBAcGFyYW0ge09iamVjdH0gICAgIG9wdGlvbnMubWlkZGxld2FyZSAtIEEgbWlkZGxld2FyZSB0byBjYWxsIG9uIGNlcnRhaW4gQVBJIGFjdGlvbnNcXG4gKlxcbiAqIEBwcm9wZXJ0eSB7T2JzZXJ2YWJsZX0gZXZlbnRzXFxuICogQHByb3BlcnR5IHtDYWNoZX0gY2FjaGUgLSBUZW1wb3JhcnkgY2FjaGUgZGVmYXVsdCB0byBAbGlua3tJbk1lbW9yeX1cXG4gKiBAcHJvcGVydHkge0NhY2hlfSBzdG9yYWdlIC0gSWYgc3BlY2lmaWVkLCB1c2VzIGEgbW9yZSBwcmVzaXN0ZW50IGNhY2hlIChsb2NhbCBzdG9yYWdlLCBldGMuKVxcbiAqL1xcblxcbnZhciBEZXJpdkFQSUJhc2ljID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRGVyaXZBUElDYWxscykge1xcbiAgKDAsX2JhYmVsX3J1bnRpbWVfaGVscGVyc19pbmhlcml0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLmRlZmF1bHQpKERlcml2QVBJQmFzaWMsIF9EZXJpdkFQSUNhbGxzKTtcXG5cXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRGVyaXZBUElCYXNpYyk7XFxuXFxuICBmdW5jdGlvbiBEZXJpdkFQSUJhc2ljKCkge1xcbiAgICB2YXIgX3RoaXM7XFxuXFxuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcXG4gICAgICAgIHN0b3JhZ2UgPSBfcmVmLnN0b3JhZ2UsXFxuICAgICAgICBhcHBfaWQgPSBfcmVmLmFwcF9pZCxcXG4gICAgICAgIGNvbm5lY3Rpb24gPSBfcmVmLmNvbm5lY3Rpb24sXFxuICAgICAgICBfcmVmJGNhY2hlID0gX3JlZi5jYWNoZSxcXG4gICAgICAgIGNhY2hlID0gX3JlZiRjYWNoZSA9PT0gdm9pZCAwID8gbmV3IF9Jbk1lbW9yeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfXy5kZWZhdWx0KCkgOiBfcmVmJGNhY2hlLFxcbiAgICAgICAgX3JlZiRlbmRwb2ludCA9IF9yZWYuZW5kcG9pbnQsXFxuICAgICAgICBlbmRwb2ludCA9IF9yZWYkZW5kcG9pbnQgPT09IHZvaWQgMCA/ICdmcm9udGVuZC5iaW5hcnl3cy5jb20nIDogX3JlZiRlbmRwb2ludCxcXG4gICAgICAgIF9yZWYkbGFuZyA9IF9yZWYubGFuZyxcXG4gICAgICAgIGxhbmcgPSBfcmVmJGxhbmcgPT09IHZvaWQgMCA/ICdFTicgOiBfcmVmJGxhbmcsXFxuICAgICAgICBfcmVmJGJyYW5kID0gX3JlZi5icmFuZCxcXG4gICAgICAgIGJyYW5kID0gX3JlZiRicmFuZCA9PT0gdm9pZCAwID8gJycgOiBfcmVmJGJyYW5kLFxcbiAgICAgICAgX3JlZiRtaWRkbGV3YXJlID0gX3JlZi5taWRkbGV3YXJlLFxcbiAgICAgICAgbWlkZGxld2FyZSA9IF9yZWYkbWlkZGxld2FyZSA9PT0gdm9pZCAwID8ge30gOiBfcmVmJG1pZGRsZXdhcmU7XFxuXFxuICAgICgwLF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfY2xhc3NDYWxsQ2hlY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5kZWZhdWx0KSh0aGlzLCBEZXJpdkFQSUJhc2ljKTtcXG5cXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcXG4gICAgX3RoaXMuZXZlbnRzID0gbmV3IHJ4anNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X18uU3ViamVjdCgpO1xcblxcbiAgICBpZiAoY29ubmVjdGlvbikge1xcbiAgICAgIF90aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGlmICghYXBwX2lkKSB0aHJvdyBFcnJvcignQW4gYXBwX2lkIGlzIHJlcXVpcmVkIHRvIGNvbm5lY3QgdG8gdGhlIEFQSScpO1xcbiAgICAgIF90aGlzLnNob3VsZFJlY29ubmVjdCA9IHRydWU7XFxuICAgICAgX3RoaXMuY29ubmVjdGlvbkFyZ3MgPSB7XFxuICAgICAgICBhcHBfaWQ6IGFwcF9pZCxcXG4gICAgICAgIGVuZHBvaW50VXJsOiBnZXRVcmwoZW5kcG9pbnQpLFxcbiAgICAgICAgbGFuZzogbGFuZy50b1VwcGVyQ2FzZSgpLFxcbiAgICAgICAgYnJhbmQ6IGJyYW5kLnRvTG93ZXJDYXNlKClcXG4gICAgICB9O1xcblxcbiAgICAgIF90aGlzLmNvbm5lY3QoKTtcXG4gICAgfVxcblxcbiAgICBfdGhpcy5sYW5nID0gbGFuZztcXG4gICAgX3RoaXMucmVxSWQgPSAwO1xcbiAgICBfdGhpcy5jb25uZWN0ZWQgPSBuZXcgX0N1c3RvbVByb21pc2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX18uZGVmYXVsdCgpO1xcbiAgICBfdGhpcy5zYW5pdHlFcnJvcnMgPSBuZXcgcnhqc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfXy5TdWJqZWN0KCk7XFxuICAgIF90aGlzLm1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlO1xcbiAgICBfdGhpcy5wZW5kaW5nUmVxdWVzdHMgPSB7fTtcXG4gICAgX3RoaXMuZXhwZWN0X3Jlc3BvbnNlX3R5cGVzID0ge307XFxuICAgIF90aGlzLnN1YnNjcmlwdGlvbl9tYW5hZ2VyID0gbmV3IF9TdWJzY3JpcHRpb25NYW5hZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fLmRlZmF1bHQoKDAsX2JhYmVsX3J1bnRpbWVfaGVscGVyc19hc3NlcnRUaGlzSW5pdGlhbGl6ZWRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5kZWZhdWx0KShfdGhpcykpO1xcbiAgICBfdGhpcy5yZWNvbm5lY3RfdGltZW91dCA9IGZhbHNlO1xcbiAgICBfdGhpcy5rZWVwX2FsaXZlX2ludGVydmFsID0gZmFsc2U7XFxuXFxuICAgIGlmIChzdG9yYWdlKSB7XFxuICAgICAgX3RoaXMuc3RvcmFnZSA9IG5ldyBfQ2FjaGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18uZGVmYXVsdCgoMCxfYmFiZWxfcnVudGltZV9oZWxwZXJzX2Fzc2VydFRoaXNJbml0aWFsaXplZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLmRlZmF1bHQpKF90aGlzKSwgc3RvcmFnZSk7XFxuICAgIH0gLy8gSWYgd2UgaGF2ZSB0aGUgc3RvcmFnZSBsb29rIHRoYXQgb25lIHVwXFxuXFxuXFxuICAgIF90aGlzLmNhY2hlID0gbmV3IF9DYWNoZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXy5kZWZhdWx0KF90aGlzLnN0b3JhZ2UgPyBfdGhpcy5zdG9yYWdlIDogKDAsX2JhYmVsX3J1bnRpbWVfaGVscGVyc19hc3NlcnRUaGlzSW5pdGlhbGl6ZWRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5kZWZhdWx0KShfdGhpcyksIGNhY2hlKTtcXG5cXG4gICAgX3RoaXMuY29ubmVjdGlvbkhhbmRsZXJzKCk7XFxuXFxuICAgIHJldHVybiBfdGhpcztcXG4gIH1cXG5cXG4gICgwLF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfY3JlYXRlQ2xhc3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5kZWZhdWx0KShEZXJpdkFQSUJhc2ljLCBbe1xcbiAgICBrZXk6IFxcXCJjb25uZWN0aW9uSGFuZGxlcnNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29ubmVjdGlvbkhhbmRsZXJzKCkge1xcbiAgICAgIHRoaXMuY29ubmVjdGlvbi5vbm9wZW4gPSB0aGlzLm9wZW5IYW5kbGVyLmJpbmQodGhpcyk7XFxuICAgICAgdGhpcy5jb25uZWN0aW9uLm9uY2xvc2UgPSB0aGlzLmNsb3NlSGFuZGxlci5iaW5kKHRoaXMpO1xcbiAgICAgIHRoaXMuY29ubmVjdGlvbi5vbm1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VIYW5kbGVyLmJpbmQodGhpcyk7XFxuICAgICAgdGhpcy5jb25uZWN0aW9uLm9uZXJyb3IgPSB0aGlzLmVycm9ySGFuZGxlci5iaW5kKHRoaXMpO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcImNvbm5lY3RcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29ubmVjdCgpIHtcXG4gICAgICBpZiAoIXRoaXMuY29ubmVjdGlvbkFyZ3MpIHtcXG4gICAgICAgIHRocm93IG5ldyBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNV9fLkNvbnN0cnVjdGlvbkVycm9yKCdDb25uZWN0aW9uIGFyZ3VtZW50cyBhcmUgcmVxdWlyZWQgdG8gY3JlYXRlIGEgY29ubmVjdGlvbi4nKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5ldmVudHMubmV4dCh7XFxuICAgICAgICBuYW1lOiAnY29ubmVjdCdcXG4gICAgICB9KTtcXG4gICAgICB2YXIgX3RoaXMkY29ubmVjdGlvbkFyZ3MgPSB0aGlzLmNvbm5lY3Rpb25BcmdzLFxcbiAgICAgICAgICBlbmRwb2ludFVybCA9IF90aGlzJGNvbm5lY3Rpb25BcmdzLmVuZHBvaW50VXJsLFxcbiAgICAgICAgICBsYW5nID0gX3RoaXMkY29ubmVjdGlvbkFyZ3MubGFuZyxcXG4gICAgICAgICAgYXBwX2lkID0gX3RoaXMkY29ubmVjdGlvbkFyZ3MuYXBwX2lkLFxcbiAgICAgICAgICBicmFuZCA9IF90aGlzJGNvbm5lY3Rpb25BcmdzLmJyYW5kO1xcbiAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG5ldyBXZWJTb2NrZXQoXFxcIlxcXCIuY29uY2F0KGVuZHBvaW50VXJsLnRvU3RyaW5nKCksIFxcXCJ3ZWJzb2NrZXRzL3YzP2FwcF9pZD1cXFwiKS5jb25jYXQoYXBwX2lkLCBcXFwiJmw9XFxcIikuY29uY2F0KGxhbmcsIFxcXCImYnJhbmQ9XFxcIikuY29uY2F0KGJyYW5kKSk7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZGlzY29ubmVjdFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNjb25uZWN0KCkge1xcbiAgICAgIHRoaXMuc2hvdWxkUmVjb25uZWN0ID0gZmFsc2U7IC8vIHByZXZlbnRzIHJlLWNvbm5lY3RpbmcgYXV0b21hdGljYWxseVxcblxcbiAgICAgIHRoaXMuY29ubmVjdGlvbi5jbG9zZSgpO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcImlzQ29ubmVjdGlvbkNsb3NlZFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0Nvbm5lY3Rpb25DbG9zZWQoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5yZWFkeVN0YXRlID09PSAyIHx8IHRoaXMuY29ubmVjdGlvbi5yZWFkeVN0YXRlID09PSAzO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcInNlbmRBbmRHZXRTb3VyY2VcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZEFuZEdldFNvdXJjZShyZXF1ZXN0KSB7XFxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICAgICAgdmFyIHBlbmRpbmcgPSBuZXcgcnhqc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfXy5TdWJqZWN0KCk7XFxuICAgICAgcmVxdWVzdC5yZXFfaWQgPSByZXF1ZXN0LnJlcV9pZCB8fCArK3RoaXMucmVxSWQ7XFxuICAgICAgdGhpcy5wZW5kaW5nUmVxdWVzdHNbcmVxdWVzdC5yZXFfaWRdID0gcGVuZGluZztcXG4gICAgICB0aGlzLmNvbm5lY3RlZC50aGVuKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmIChfdGhpczIuaXNDb25uZWN0aW9uQ2xvc2VkKCkpIHJldHVybjtcXG5cXG4gICAgICAgIF90aGlzMi5jb25uZWN0aW9uLnNlbmQoSlNPTi5zdHJpbmdpZnkocmVxdWVzdCkpO1xcbiAgICAgIH0pW1xcXCJjYXRjaFxcXCJdKGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICByZXR1cm4gcGVuZGluZy5lcnJvcihlKTtcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gcGVuZGluZztcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJzZW5kXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgX3NlbmQgPSAoMCxfYmFiZWxfcnVudGltZV9oZWxwZXJzX2FzeW5jVG9HZW5lcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5kZWZhdWx0KSggLyojX19QVVJFX18qL19iYWJlbF9ydW50aW1lX3JlZ2VuZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19fZGVmYXVsdCgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcXG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xcblxcbiAgICAgICAgdmFyIF9sZW4sXFxuICAgICAgICAgICAgYXJncyxcXG4gICAgICAgICAgICBfa2V5LFxcbiAgICAgICAgICAgIHNlbmRfd2lsbF9iZV9jYWxsZWQsXFxuICAgICAgICAgICAgcmVxdWVzdCxcXG4gICAgICAgICAgICByZXNwb25zZV9wcm9taXNlLFxcbiAgICAgICAgICAgIHNlbmRfaXNfY2FsbGVkLFxcbiAgICAgICAgICAgIF9hcmdzID0gYXJndW1lbnRzO1xcblxcbiAgICAgICAgcmV0dXJuIF9iYWJlbF9ydW50aW1lX3JlZ2VuZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19fZGVmYXVsdCgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcXG4gICAgICAgICAgd2hpbGUgKDEpIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XFxuICAgICAgICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgICAgICAgIGZvciAoX2xlbiA9IF9hcmdzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcXG4gICAgICAgICAgICAgICAgICBhcmdzW19rZXldID0gX2FyZ3NbX2tleV07XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgc2VuZF93aWxsX2JlX2NhbGxlZCA9IHRoaXMuY2FsbE1pZGRsZXdhcmUoJ3NlbmRXaWxsQmVDYWxsZWQnLCB7XFxuICAgICAgICAgICAgICAgICAgYXJnczogYXJnc1xcbiAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKCFzZW5kX3dpbGxfYmVfY2FsbGVkKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcXFwicmV0dXJuXFxcIiwgc2VuZF93aWxsX2JlX2NhbGxlZCk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDQ6XFxuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBhcmdzWzBdO1xcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5uZXh0KHtcXG4gICAgICAgICAgICAgICAgICBuYW1lOiAnc2VuZCcsXFxuICAgICAgICAgICAgICAgICAgZGF0YTogcmVxdWVzdFxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGVGcm9tRXhwZWN0UmVzcG9uc2UocmVxdWVzdCk7XFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlX3Byb21pc2UgPSB0aGlzLnNlbmRBbmRHZXRTb3VyY2UocmVxdWVzdCkucGlwZSgoMCxyeGpzX29wZXJhdG9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTdfXy5maXJzdCkoKSkudG9Qcm9taXNlKCk7XFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlX3Byb21pc2UudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcXG4gICAgICAgICAgICAgICAgICBfdGhpczMuY2FjaGUuc2V0KHJlcXVlc3QsIHJlc3BvbnNlKTtcXG5cXG4gICAgICAgICAgICAgICAgICBpZiAoX3RoaXMzLnN0b3JhZ2UpIHtcXG4gICAgICAgICAgICAgICAgICAgIF90aGlzMy5zdG9yYWdlLnNldChyZXF1ZXN0LCByZXNwb25zZSk7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7fSk7IC8vIElnbm9yZSBlcnJvcnMgaGVyZVxcblxcbiAgICAgICAgICAgICAgICBzZW5kX2lzX2NhbGxlZCA9IHRoaXMuY2FsbE1pZGRsZXdhcmUoJ3NlbmRJc0NhbGxlZCcsIHtcXG4gICAgICAgICAgICAgICAgICByZXNwb25zZV9wcm9taXNlOiByZXNwb25zZV9wcm9taXNlLFxcbiAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcXG4gICAgICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgICAgIGlmICghc2VuZF9pc19jYWxsZWQpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcXFwicmV0dXJuXFxcIiwgc2VuZF9pc19jYWxsZWQpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxMjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcXFwicmV0dXJuXFxcIiwgcmVzcG9uc2VfcHJvbWlzZSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDEzOlxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZW5kXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICBmdW5jdGlvbiBzZW5kKCkge1xcbiAgICAgICAgcmV0dXJuIF9zZW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBzZW5kO1xcbiAgICB9KClcXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiY2FsbE1pZGRsZXdhcmVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsbE1pZGRsZXdhcmUobmFtZSwgYXJncykge1xcbiAgICAgIGlmICghKG5hbWUgaW4gdGhpcy5taWRkbGV3YXJlKSkgcmV0dXJuIHVuZGVmaW5lZDtcXG4gICAgICByZXR1cm4gdGhpcy5taWRkbGV3YXJlW25hbWVdKGFyZ3MpO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcInN1YnNjcmliZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJzY3JpYmUocmVxdWVzdCkge1xcbiAgICAgIHJldHVybiB0aGlzLnN1YnNjcmlwdGlvbl9tYW5hZ2VyLnN1YnNjcmliZShyZXF1ZXN0KTtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJmb3JnZXRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBfZm9yZ2V0ID0gKDAsX2JhYmVsX3J1bnRpbWVfaGVscGVyc19hc3luY1RvR2VuZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uZGVmYXVsdCkoIC8qI19fUFVSRV9fKi9fYmFiZWxfcnVudGltZV9yZWdlbmVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fX2RlZmF1bHQoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGlkKSB7XFxuICAgICAgICByZXR1cm4gX2JhYmVsX3J1bnRpbWVfcmVnZW5lcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX19kZWZhdWx0KCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XFxuICAgICAgICAgIHdoaWxlICgxKSB7XFxuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XFxuICAgICAgICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFxcXCJyZXR1cm5cXFwiLCB0aGlzLnN1YnNjcmlwdGlvbl9tYW5hZ2VyLmZvcmdldChpZCkpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxOlxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZW5kXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XFxuICAgICAgfSkpO1xcblxcbiAgICAgIGZ1bmN0aW9uIGZvcmdldChfeCkge1xcbiAgICAgICAgcmV0dXJuIF9mb3JnZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGZvcmdldDtcXG4gICAgfSgpXFxuICB9LCB7XFxuICAgIGtleTogXFxcImZvcmdldEFsbFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIF9mb3JnZXRBbGwgPSAoMCxfYmFiZWxfcnVudGltZV9oZWxwZXJzX2FzeW5jVG9HZW5lcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5kZWZhdWx0KSggLyojX19QVVJFX18qL19iYWJlbF9ydW50aW1lX3JlZ2VuZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19fZGVmYXVsdCgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoKSB7XFxuICAgICAgICB2YXIgX3RoaXMkc3Vic2NyaXB0aW9uX21hO1xcblxcbiAgICAgICAgdmFyIF9hcmdzMyA9IGFyZ3VtZW50cztcXG4gICAgICAgIHJldHVybiBfYmFiZWxfcnVudGltZV9yZWdlbmVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fX2RlZmF1bHQoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcXG4gICAgICAgICAgd2hpbGUgKDEpIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXFxcInJldHVyblxcXCIsIChfdGhpcyRzdWJzY3JpcHRpb25fbWEgPSB0aGlzLnN1YnNjcmlwdGlvbl9tYW5hZ2VyKS5mb3JnZXRBbGwuYXBwbHkoX3RoaXMkc3Vic2NyaXB0aW9uX21hLCBfYXJnczMpKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMTpcXG4gICAgICAgICAgICAgIGNhc2UgXFxcImVuZFxcXCI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgX2NhbGxlZTMsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICBmdW5jdGlvbiBmb3JnZXRBbGwoKSB7XFxuICAgICAgICByZXR1cm4gX2ZvcmdldEFsbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gZm9yZ2V0QWxsO1xcbiAgICB9KClcXG4gIH0sIHtcXG4gICAga2V5OiBcXFwia2VlcEFsaXZlUGluZ1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBrZWVwQWxpdmVQaW5nKCkge1xcbiAgICAgIHRoaXMucGluZyh7XFxuICAgICAgICBwaW5nOiAxXFxuICAgICAgfSk7XFxuICAgICAgdGhpcy5yZWNvbm5lY3RfdGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5yZWNvbm5lY3QuYmluZCh0aGlzKSwgNTAwMCk7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicG9uZ1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb25nKCkge1xcbiAgICAgIGlmICh0aGlzLnJlY29ubmVjdF90aW1lb3V0KSB7XFxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RfdGltZW91dCk7XFxuICAgICAgICB0aGlzLnJlY29ubmVjdF90aW1lb3V0ID0gZmFsc2U7XFxuICAgICAgfVxcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcIm9wZW5IYW5kbGVyXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW5IYW5kbGVyKCkge1xcbiAgICAgIHRoaXMuZXZlbnRzLm5leHQoe1xcbiAgICAgICAgbmFtZTogJ29wZW4nXFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKHRoaXMuc2hvdWxkUmVjb25uZWN0KSB7XFxuICAgICAgICB0aGlzLmtlZXBfYWxpdmVfaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aGlzLmtlZXBBbGl2ZVBpbmcuYmluZCh0aGlzKSwgMzAwMDApO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5jb25uZWN0aW9uLnJlYWR5U3RhdGUgPT09IDEpIHtcXG4gICAgICAgIHRoaXMuY29ubmVjdGVkLnJlc29sdmUoKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLm9wZW5IYW5kbGVyLmJpbmQodGhpcyksIDUwKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwibWVzc2FnZUhhbmRsZXJcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVzc2FnZUhhbmRsZXIobXNnKSB7XFxuICAgICAgaWYgKCFtc2cuZGF0YSkge1xcbiAgICAgICAgdGhpcy5zYW5pdHlFcnJvcnMubmV4dChuZXcgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfXy5BUElFcnJvcignU29tZXRoaW5nIHdlbnQgd3Jvbmcgd2hpbGUgcmVjZWl2aW5nIHRoZSByZXNwb25zZSBmcm9tIEFQSS4nKSk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHZhciByZXNwb25zZSA9IEpTT04ucGFyc2UobXNnLmRhdGEpO1xcblxcbiAgICAgIGlmICh0aGlzLnJlY29ubmVjdF90aW1lb3V0ICYmIHJlc3BvbnNlLnBpbmcgPT09ICdwb25nJykge1xcbiAgICAgICAgdGhpcy5wb25nKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuZXZlbnRzLm5leHQoe1xcbiAgICAgICAgbmFtZTogJ21lc3NhZ2UnLFxcbiAgICAgICAgZGF0YTogcmVzcG9uc2VcXG4gICAgICB9KTtcXG4gICAgICB2YXIgcmVxSWQgPSByZXNwb25zZS5yZXFfaWQ7XFxuXFxuICAgICAgaWYgKHJlcUlkIGluIHRoaXMucGVuZGluZ1JlcXVlc3RzKSB7XFxuICAgICAgICB2YXIgZXhwZWN0X3Jlc3BvbnNlID0gdGhpcy5leHBlY3RfcmVzcG9uc2VfdHlwZXNbcmVzcG9uc2UubXNnX3R5cGVdO1xcblxcbiAgICAgICAgaWYgKGV4cGVjdF9yZXNwb25zZSAmJiBleHBlY3RfcmVzcG9uc2UuaXNQZW5kaW5nKCkpIHtcXG4gICAgICAgICAgZXhwZWN0X3Jlc3BvbnNlLnJlc29sdmUocmVzcG9uc2UpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIHJlcXVlc3QgPSByZXNwb25zZS5lY2hvX3JlcTsgLy8gV2hlbiBvbmUgb2YgdGhlIGNoaWxkIHN1YnNjcmlwdGlvbnMgb2YgYHByb3Bvc2FsX29wZW5fY29udHJhY3RgIGhhcyBhbiBlcnJvciBpbiB0aGUgcmVzcG9uc2UsXFxuICAgICAgICAvLyBpdCBzaG91bGQgYmUgaGFuZGxlZCBpbiB0aGUgY2FsbGJhY2sgb2YgY29uc3VtZXIgaW5zdGVhZC4gQ2FsbGluZyBgZXJyb3IoKWAgd2l0aCBwYXJlbnQgc3Vic2NyaXB0aW9uXFxuICAgICAgICAvLyB3aWxsIG1hcmsgdGhlIHBhcmVudCBzdWJzY3JpcHRpb24gYXMgY29tcGxldGUgYW5kIGFsbCBjaGlsZCBzdWJzY3JpcHRpb25zIHdpbGwgYmUgZm9yZ290dGVuLlxcblxcbiAgICAgICAgdmFyIGlzX3BhcmVudF9zdWJzY3JpcHRpb24gPSByZXF1ZXN0ICYmIHJlcXVlc3QucHJvcG9zYWxfb3Blbl9jb250cmFjdCAmJiAhcmVxdWVzdC5jb250cmFjdF9pZDtcXG5cXG4gICAgICAgIGlmIChyZXNwb25zZS5lcnJvciAmJiAhaXNfcGFyZW50X3N1YnNjcmlwdGlvbikge1xcbiAgICAgICAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0c1tyZXFJZF0uZXJyb3IocmVzcG9uc2UpO1xcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBlbmRpbmdSZXF1ZXN0c1tyZXFJZF0uaXNTdG9wcGVkICYmIHJlc3BvbnNlLnN1YnNjcmlwdGlvbikge1xcbiAgICAgICAgICAvLyBTb3VyY2UgaXMgYWxyZWFkeSBtYXJrZWQgYXMgY29tcGxldGVkLiBJbiB0aGlzIGNhc2Ugd2Ugc2hvdWxkXFxuICAgICAgICAgIC8vIHNlbmQgYSBmb3JnZXQgcmVxdWVzdCB3aXRoIHRoZSBzdWJzY3JpcHRpb24gaWQgYW5kIGlnbm9yZSB0aGUgcmVzcG9uc2UgcmVjZWl2ZWQuXFxuICAgICAgICAgIHZhciBpZCA9IHJlc3BvbnNlLnN1YnNjcmlwdGlvbi5pZDtcXG4gICAgICAgICAgdGhpcy5mb3JnZXQoaWQpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy5wZW5kaW5nUmVxdWVzdHNbcmVxSWRdLm5leHQocmVzcG9uc2UpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLnNhbml0eUVycm9ycy5uZXh0KG5ldyBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNV9fLkFQSUVycm9yKCdFeHRyYSByZXNwb25zZScpKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFJlY29ubmVjdHMgdG8gdGhlIEFQSSBpbiBjYXNlIG9mIGNvbm5lY3Rpb24gZXJyb3IsIHVubGVzcyBjb25uZWN0aW9uIGlzXFxuICAgICAqIHBhc3NlZCBhcyBhbiBhcmd1bWVudCwgaW4gdGhhdCBjYXNlIHJlY29ubmVjdGluZyBzaG91bGQgYmUgaGFuZGxlZCBpbiB0aGVcXG4gICAgICogQVBJIHVzZXIgc2lkZS5cXG4gICAgICogKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiY2xvc2VIYW5kbGVyXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlSGFuZGxlcigpIHtcXG4gICAgICB0aGlzLmV2ZW50cy5uZXh0KHtcXG4gICAgICAgIG5hbWU6ICdjbG9zZSdcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAodGhpcy5zaG91bGRSZWNvbm5lY3QpIHtcXG4gICAgICAgIHRoaXMuZXZlbnRzLm5leHQoe1xcbiAgICAgICAgICBuYW1lOiAncmVjb25uZWN0aW5nJ1xcbiAgICAgICAgfSk7XFxuICAgICAgICB0aGlzLnJlY29ubmVjdCgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2xlYXJzIHByZXZpb3VzIGNvbm5lY3Rpb24ga2VlcGxpdmUgcGluZyB0aW1lb3V0IGFuZCBjb25uZWN0ICYgYXNzaWduIHRoZSBoYW5kbGVzXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJyZWNvbm5lY3RcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVjb25uZWN0KCkge1xcbiAgICAgIGlmICh0aGlzLnNob3VsZFJlY29ubmVjdCkge1xcbiAgICAgICAgaWYgKHRoaXMua2VlcF9hbGl2ZV9pbnRlcnZhbCkge1xcbiAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMua2VlcF9hbGl2ZV9pbnRlcnZhbCk7XFxuICAgICAgICAgIHRoaXMua2VlcF9hbGl2ZV9pbnRlcnZhbCA9IGZhbHNlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5wb25nKCk7IC8vIGNsZWFyIGFsbCBwcmV2aW91cyB0aW1lb3V0XFxuXFxuICAgICAgICB0aGlzLmNvbm5lY3QoKTtcXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkhhbmRsZXJzKCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcImVycm9ySGFuZGxlclxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcnJvckhhbmRsZXIoKSB7XFxuICAgICAgdGhpcy5zYW5pdHlFcnJvcnMubmV4dChuZXcgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfXy5BUElFcnJvcignU29tZXRoaW5nIHdlbnQgd3Jvbmcgd2hpbGUgcmVjZWl2aW5nIHRoZSByZXNwb25zZSBmcm9tIEFQSS4nKSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBmb3IgY2xvc2UgZXZlbnRzXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJvbkNsb3NlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2xvc2UoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzLnBpcGUoKDAscnhqc19vcGVyYXRvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE4X18uZmlsdGVyKShmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgcmV0dXJuIGUubmFtZSA9PT0gJ2Nsb3NlJztcXG4gICAgICB9KSwgKDAscnhqc19vcGVyYXRvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE5X18uc2hhcmUpKCkpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gZm9yIG9wZW4gZXZlbnRzXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJvbk9wZW5cXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25PcGVuKCkge1xcbiAgICAgIHJldHVybiB0aGlzLmV2ZW50cy5waXBlKCgwLHJ4anNfb3BlcmF0b3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xOF9fLmZpbHRlcikoZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIHJldHVybiBlLm5hbWUgPT09ICdvcGVuJztcXG4gICAgICB9KSwgKDAscnhqc19vcGVyYXRvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE5X18uc2hhcmUpKCkpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gZm9yIG5ldyBtZXNzYWdlc1xcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwib25NZXNzYWdlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTWVzc2FnZSgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5ldmVudHMucGlwZSgoMCxyeGpzX29wZXJhdG9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMThfXy5maWx0ZXIpKGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICByZXR1cm4gZS5uYW1lID09PSAnbWVzc2FnZSc7XFxuICAgICAgfSksICgwLHJ4anNfb3BlcmF0b3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xOV9fLnNoYXJlKSgpKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzIEV4cGVjdCB0aGVzZSB0eXBlcyB0byBiZSByZWNlaXZlZCBieSB0aGUgQVBJXFxuICAgICAqXFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58UHJvbWlzZTxBcnJheT59IFJlc29sdmVzIHRvIGEgc2luZ2xlIHJlc3BvbnNlIG9yIGFuIGFycmF5XFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJleHBlY3RSZXNwb25zZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIF9leHBlY3RSZXNwb25zZSA9ICgwLF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfYXN5bmNUb0dlbmVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmRlZmF1bHQpKCAvKiNfX1BVUkVfXyovX2JhYmVsX3J1bnRpbWVfcmVnZW5lcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX19kZWZhdWx0KCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNCgpIHtcXG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xcblxcbiAgICAgICAgdmFyIF9sZW4yLFxcbiAgICAgICAgICAgIHR5cGVzLFxcbiAgICAgICAgICAgIF9rZXkyLFxcbiAgICAgICAgICAgIF9hcmdzNCA9IGFyZ3VtZW50cztcXG5cXG4gICAgICAgIHJldHVybiBfYmFiZWxfcnVudGltZV9yZWdlbmVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fX2RlZmF1bHQoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcXG4gICAgICAgICAgd2hpbGUgKDEpIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgZm9yIChfbGVuMiA9IF9hcmdzNC5sZW5ndGgsIHR5cGVzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XFxuICAgICAgICAgICAgICAgICAgdHlwZXNbX2tleTJdID0gX2FyZ3M0W19rZXkyXTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XFxuICAgICAgICAgICAgICAgICAgaWYgKCEodHlwZSBpbiBfdGhpczQuZXhwZWN0X3Jlc3BvbnNlX3R5cGVzKSkge1xcbiAgICAgICAgICAgICAgICAgICAgX3RoaXM0LmV4cGVjdF9yZXNwb25zZV90eXBlc1t0eXBlXSA9IHRyYW5zZm9ybVVuZGVmaW5lZFRvUHJvbWlzZShfdGhpczQuY2FjaGUuZ2V0QnlNc2dUeXBlKHR5cGUpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUgJiYgX3RoaXM0LnN0b3JhZ2UpIHJldHVybiBfdGhpczQuc3RvcmFnZS5nZXRCeU1zZ1R5cGUodHlwZSk7XFxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0pOyAvLyBleHBlY3Qgb24gYSBzaW5nbGUgcmVzcG9uc2UgcmV0dXJucyBhIHNpbmdsZSByZXNwb25zZSwgbm90IGEgbGlzdFxcblxcbiAgICAgICAgICAgICAgICBpZiAoISh0eXBlcy5sZW5ndGggPT09IDEpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA0O1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFxcXCJyZXR1cm5cXFwiLCB0aGlzLmV4cGVjdF9yZXNwb25zZV90eXBlc1t0eXBlc1swXV0pO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA0OlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcXFwicmV0dXJuXFxcIiwgUHJvbWlzZS5hbGwodHlwZXMubWFwKGZ1bmN0aW9uICh0eXBlKSB7XFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNC5leHBlY3RfcmVzcG9uc2VfdHlwZXNbdHlwZV07XFxuICAgICAgICAgICAgICAgIH0pKSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDU6XFxuICAgICAgICAgICAgICBjYXNlIFxcXCJlbmRcXFwiOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIF9jYWxsZWU0LCB0aGlzKTtcXG4gICAgICB9KSk7XFxuXFxuICAgICAgZnVuY3Rpb24gZXhwZWN0UmVzcG9uc2UoKSB7XFxuICAgICAgICByZXR1cm4gX2V4cGVjdFJlc3BvbnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBleHBlY3RSZXNwb25zZTtcXG4gICAgfSgpXFxuICB9LCB7XFxuICAgIGtleTogXFxcImRlbGV0ZUZyb21FeHBlY3RSZXNwb25zZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVGcm9tRXhwZWN0UmVzcG9uc2UocmVxdWVzdCkge1xcbiAgICAgIHZhciByZXNwb25zZV90eXBlID0gT2JqZWN0LmtleXModGhpcy5leHBlY3RfcmVzcG9uc2VfdHlwZXMpLmZpbmQoZnVuY3Rpb24gKHR5cGUpIHtcXG4gICAgICAgIHJldHVybiB0eXBlIGluIHJlcXVlc3Q7XFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKHRoaXMuZXhwZWN0X3Jlc3BvbnNlX3R5cGVzW3Jlc3BvbnNlX3R5cGVdICYmICF0aGlzLmV4cGVjdF9yZXNwb25zZV90eXBlc1tyZXNwb25zZV90eXBlXS5pc1BlbmRpbmcoKSkge1xcbiAgICAgICAgZGVsZXRlIHRoaXMuZXhwZWN0X3Jlc3BvbnNlX3R5cGVzW3Jlc3BvbnNlX3R5cGVdO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIERlcml2QVBJQmFzaWM7XFxufShfRGVyaXZBUElDYWxsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfXy5kZWZhdWx0KTtcXG5cXG5cXG5cXG5mdW5jdGlvbiBnZXRVcmwob3JpZ2luYWxFbmRwb2ludCkge1xcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbEVuZHBvaW50ICE9PSAnc3RyaW5nJykge1xcbiAgICB0aHJvdyBuZXcgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfXy5Db25zdHJ1Y3Rpb25FcnJvcihcXFwiRW5kcG9pbnQgbXVzdCBiZSBhIHN0cmluZywgcGFzc2VkOiBcXFwiLmNvbmNhdCgoMCxfYmFiZWxfcnVudGltZV9oZWxwZXJzX3R5cGVvZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmRlZmF1bHQpKG9yaWdpbmFsRW5kcG9pbnQpKSk7XFxuICB9XFxuXFxuICB2YXIgdXJsO1xcblxcbiAgdHJ5IHtcXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXFxuICAgIHZhciBfb3JpZ2luYWxFbmRwb2ludCRtYXQgPSBvcmlnaW5hbEVuZHBvaW50Lm1hdGNoKC8oKD86XFxcXHcqOlxcXFwvXFxcXC8pKikoLiopLyksXFxuICAgICAgICBfb3JpZ2luYWxFbmRwb2ludCRtYXQyID0gKDAsX2JhYmVsX3J1bnRpbWVfaGVscGVyc19zbGljZWRUb0FycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZGVmYXVsdCkoX29yaWdpbmFsRW5kcG9pbnQkbWF0LCAzKSxcXG4gICAgICAgIF8gPSBfb3JpZ2luYWxFbmRwb2ludCRtYXQyWzBdLFxcbiAgICAgICAgcHJvdG9jb2wgPSBfb3JpZ2luYWxFbmRwb2ludCRtYXQyWzFdLFxcbiAgICAgICAgZW5kcG9pbnQgPSBfb3JpZ2luYWxFbmRwb2ludCRtYXQyWzJdO1xcblxcbiAgICB1cmwgPSBuZXcgVVJMKFxcXCJcXFwiLmNvbmNhdChwcm90b2NvbCA9PT0gJ3dzOi8vJyA/IHByb3RvY29sIDogJ3dzczovLycpLmNvbmNhdChlbmRwb2ludCkpO1xcbiAgfSBjYXRjaCAoZSkge1xcbiAgICB0aHJvdyBuZXcgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfXy5Db25zdHJ1Y3Rpb25FcnJvcihcXFwiSW52YWxpZCBVUkw6IFxcXCIuY29uY2F0KG9yaWdpbmFsRW5kcG9pbnQpKTtcXG4gIH1cXG5cXG4gIHJldHVybiB1cmw7XFxufVxcblxcbmZ1bmN0aW9uIHRyYW5zZm9ybVVuZGVmaW5lZFRvUHJvbWlzZShwcm9taXNlKSB7XFxuICByZXR1cm4gX0N1c3RvbVByb21pc2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX18uZGVmYXVsdC53cmFwKHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuIG5ldyBfQ3VzdG9tUHJvbWlzZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXy5kZWZhdWx0KCk7XFxuICAgIHJldHVybiB2YWx1ZTtcXG4gIH0pKTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL3NyYy9kZXJpdl9hcGkvRGVyaXZBUElCYXNpYy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2Rlcml2X2FwaS9EZXJpdkFQSUNhbGxzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2Rlcml2X2FwaS9EZXJpdkFQSUNhbGxzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRGVyaXZBUElDYWxscylcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc190eXBlb2ZfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2YuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHkuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19jbGFzc0NhbGxDaGVja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjayAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2suanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19jcmVhdGVDbGFzc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MuanNcXFwiKTtcXG5cXG5cXG5cXG5cXG5cXG4vLyBUaGlzIGZpbGUgd2FzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IHJlZ2VuLWpzLnBsIGF0IDIwMjEwOTEzLTIzNTI0Nlxcbi8vIGFwcGxpZXMgSlNPTiBzY2hlbWEgdG8gZ2VuZXJhdGUgRGVyaXYgQVBJXFxuXFxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xcbi8vID09PT09PT09PT09PT09PT09PT09PT09XFxuLy8gLS0tLS0gQVBJIE1ldGhvZHMgLS0tLS1cXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxcbnZhciBEZXJpdkFQSUNhbGxzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcXG4gIGZ1bmN0aW9uIERlcml2QVBJQ2FsbHMoKSB7XFxuICAgICgwLF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfY2xhc3NDYWxsQ2hlY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5kZWZhdWx0KSh0aGlzLCBEZXJpdkFQSUNhbGxzKTtcXG4gIH1cXG5cXG4gICgwLF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfY3JlYXRlQ2xhc3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5kZWZhdWx0KShEZXJpdkFQSUNhbGxzLCBbe1xcbiAgICBrZXk6IFxcXCJhY2NvdW50Q2xvc3VyZVxcXCIsXFxuICAgIHZhbHVlOiAvLyBUbyBiZSBpbXBsZW1lbnRlZCBieSB0aGUgc3ViLWNsYXNzXFxuICAgIC8vIGNvbnN0cnVjdG9yKCkgeyB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5hY2NvdW50X2Nsb3N1cmUgLSBNdXN0IGJlIGAxYFxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnJlYXNvbiAtIFJlYXNvbiBmb3IgY2xvc2luZyBvZmYgYWNjb3VudHMuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICovXFxuICAgIGZ1bmN0aW9uIGFjY291bnRDbG9zdXJlKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgYWNjb3VudF9jbG9zdXJlOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZWFzb246IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdhY2NvdW50X2Nsb3N1cmUnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmFjY291bnRfc2VjdXJpdHkgLSBNdXN0IGJlIGAxYFxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5vdHAgLSBbT3B0aW9uYWxdIE9UUCAob25lLXRpbWUgcGFzc2NvZGUpIGdlbmVyYXRlZCBieSBhIDJGQSBhcHBsaWNhdGlvbiBsaWtlIEF1dGh5LCBHb29nbGUgQXV0aGVudGljYXRvciBvciBZdWJpa2V5LlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MudG90cF9hY3Rpb24gLSBbT3B0aW9uYWxdIEFjdGlvbiB0byBiZSB0YWtlbiBmb3IgbWFuYWdpbmcgVE9UUCAodGltZS1iYXNlZCBvbmUtdGltZSBwYXNzd29yZCwgUkZDNjIzOCkuIEdlbmVyYXRlIHdpbGwgY3JlYXRlIGEgc2VjcmV0IGtleSB3aGljaCBpcyB0aGVuIHJldHVybmVkIGluIHRoZSBzZWNyZXRfa2V5IHJlc3BvbnNlIGZpZWxkLCB5b3UgY2FuIHRoZW4gZW5hYmxlIGJ5IHVzaW5nIHRoYXQgY29kZSBpbiBhIDJGQSBhcHBsaWNhdGlvbi5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImFjY291bnRTZWN1cml0eVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NvdW50U2VjdXJpdHkoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBhY2NvdW50X3NlY3VyaXR5OiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBvdHA6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgdG90cF9hY3Rpb246IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAnYWNjb3VudF9zZWN1cml0eScsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuYWNjb3VudF9zdGF0aXN0aWNzIC0gTXVzdCBiZSBgMWBcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJhY2NvdW50U3RhdGlzdGljc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NvdW50U3RhdGlzdGljcygpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGFjY291bnRfc3RhdGlzdGljczoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdhY2NvdW50X3N0YXRpc3RpY3MnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmFjdGl2ZV9zeW1ib2xzIC0gSWYgeW91IHVzZSBgYnJpZWZgLCBvbmx5IGEgc3Vic2V0IG9mIGZpZWxkcyB3aWxsIGJlIHJldHVybmVkLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5sYW5kaW5nX2NvbXBhbnkgLSBbT3B0aW9uYWxdIElmIHlvdSBzcGVjaWZ5IHRoaXMgZmllbGQsIG9ubHkgc3ltYm9scyBhdmFpbGFibGUgZm9yIHRyYWRpbmcgYnkgdGhhdCBsYW5kaW5nIGNvbXBhbnkgd2lsbCBiZSByZXR1cm5lZC4gSWYgeW91IGFyZSBsb2dnZWQgaW4sIG9ubHkgc3ltYm9scyBhdmFpbGFibGUgZm9yIHRyYWRpbmcgYnkgeW91ciBsYW5kaW5nIGNvbXBhbnkgd2lsbCBiZSByZXR1cm5lZCByZWdhcmRsZXNzIG9mIHdoYXQgeW91IHNwZWNpZnkgaW4gdGhpcyBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5wcm9kdWN0X3R5cGUgLSBbT3B0aW9uYWxdIElmIHlvdSBzcGVjaWZ5IHRoaXMgZmllbGQsIG9ubHkgc3ltYm9scyB0aGF0IGNhbiBiZSB0cmFkZWQgdGhyb3VnaCB0aGF0IHByb2R1Y3QgdHlwZSB3aWxsIGJlIHJldHVybmVkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJhY3RpdmVTeW1ib2xzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjdGl2ZVN5bWJvbHMoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBhY3RpdmVfc3ltYm9sczoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBsYW5kaW5nX2NvbXBhbnk6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICBwcm9kdWN0X3R5cGU6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ2FjdGl2ZV9zeW1ib2xzJyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5hY2NvdW50X29wZW5pbmdfcmVhc29uIC0gW09wdGlvbmFsXSBQdXJwb3NlIGFuZCByZWFzb24gZm9yIHJlcXVlc3RpbmcgdGhlIGFjY291bnQgb3BlbmluZy5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuYWNjb3VudF90dXJub3ZlciAtIFtPcHRpb25hbF0gVGhlIGFudGljaXBhdGVkIGFjY291bnQgdHVybm92ZXIuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmFkZHJlc3NfY2l0eSAtIFtPcHRpb25hbF0gV2l0aGluIDEwMCBjaGFyYWN0ZXJzLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5hZGRyZXNzX2xpbmVfMSAtIFdpdGhpbiA3MCBjaGFyYWN0ZXJzLCB3aXRoIG5vIGxlYWRpbmcgd2hpdGVzcGFjZXMgYW5kIG1heSBjb250YWluIGxldHRlcnMvbnVtYmVycyBhbmQvb3IgYW55IG9mIGZvbGxvd2luZyBjaGFyYWN0ZXJzICcuLDo7KClAIy8tXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmFkZHJlc3NfbGluZV8yIC0gW09wdGlvbmFsXSBXaXRoaW4gNzAgY2hhcmFjdGVycy5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuYWRkcmVzc19wb3N0Y29kZSAtIFtPcHRpb25hbF0gV2l0aGluIDIwIGNoYXJhY3RlcnMgYW5kIG1heSBub3QgY29udGFpbiAnKycuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmFkZHJlc3Nfc3RhdGUgLSBbT3B0aW9uYWxdIFBvc3NpYmxlIHZhbHVlIHJlY2VpdmUgZnJvbSBgc3RhdGVzX2xpc3RgIGNhbGwuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmFmZmlsaWF0ZV9hY2NvdW50X2FkZCAtIE11c3QgYmUgYDFgXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmFmZmlsaWF0ZV9wbGFuIC0gVGhlIGFmZmlsaWF0ZSBwbGFuIHRoZSBhY2NvdW50IHdpbGwgc3Vic2NyaWJlIHRvXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmFmZmlsaWF0ZV90b2tlbiAtIFtPcHRpb25hbF0gQWZmaWxpYXRlIHRva2VuLCB3aXRoaW4gMzIgY2hhcmFjdGVycy5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MuY2l0aXplbiAtIFtPcHRpb25hbF0gQ291bnRyeSBvZiBsZWdhbCBjaXRpemVuc2hpcCwgMi1sZXR0ZXIgY291bnRyeSBjb2RlLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5jbGllbnRfdHlwZSAtIFtPcHRpb25hbF0gSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBmb3IgYSBjbGllbnQgcmVxdWVzdGluZyBhbiBhY2NvdW50IHdpdGggcHJvZmVzc2lvbmFsIHN0YXR1cy5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuY3VycmVuY3kgLSBbT3B0aW9uYWxdIFRvIHNldCBjdXJyZW5jeSBvZiB0aGUgYWNjb3VudC4gTGlzdCBvZiBzdXBwb3J0ZWQgY3VycmVuY2llcyBjYW4gYmUgYWNxdWlyZWQgd2l0aCBgcGF5b3V0X2N1cnJlbmNpZXNgIGNhbGwuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmRhdGVfb2ZfYmlydGggLSBEYXRlIG9mIGJpcnRoIGZvcm1hdDogYHl5eXktbW0tZGRgLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5maXJzdF9uYW1lIC0gV2l0aGluIDItNTAgY2hhcmFjdGVycywgdXNlIG9ubHkgbGV0dGVycywgc3BhY2VzLCBoeXBoZW5zLCBmdWxsLXN0b3BzIG9yIGFwb3N0cm9waGVzLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5sYXN0X25hbWUgLSBXaXRoaW4gMi01MCBjaGFyYWN0ZXJzLCB1c2Ugb25seSBsZXR0ZXJzLCBzcGFjZXMsIGh5cGhlbnMsIGZ1bGwtc3RvcHMgb3IgYXBvc3Ryb3BoZXMuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLm5vbl9wZXBfZGVjbGFyYXRpb24gLSBbT3B0aW9uYWxdIEluZGljYXRlcyBjbGllbnQncyBzZWxmLWRlY2xhcmF0aW9uIG9mIG5vdCBiZWluZyBhIFBFUC9SQ0EgKFBvbGl0aWNhbGx5IEV4cG9zZWQgUGVyc29uL1JlbGF0aXZlcyBhbmQgQ2xvc2UgQXNzb2NpYXRlcykuXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGhvbmUgLSBbT3B0aW9uYWxdIFN0YXJ0aW5nIHdpdGggYCtgIGZvbGxvd2VkIGJ5IDktMzUgZGlnaXRzLCBoeXBoZW5zIG9yIHNwYWNlLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5wbGFjZV9vZl9iaXJ0aCAtIFtPcHRpb25hbF0gUGxhY2Ugb2YgYmlydGgsIDItbGV0dGVyIGNvdW50cnkgY29kZS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5yZXNpZGVuY2UgLSAyLWxldHRlciBjb3VudHJ5IGNvZGUsIHBvc3NpYmxlIHZhbHVlIHJlY2VpdmUgZnJvbSBgcmVzaWRlbmNlX2xpc3RgIGNhbGwuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnNhbHV0YXRpb24gLSBbT3B0aW9uYWxdIEFjY2VwdCBhbnkgdmFsdWUgaW4gZW51bSBsaXN0LlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5zZWNyZXRfYW5zd2VyIC0gW09wdGlvbmFsXSBBbnN3ZXIgdG8gc2VjcmV0IHF1ZXN0aW9uLCB3aXRoaW4gNC01MCBjaGFyYWN0ZXJzLiBSZXF1aXJlZCBmb3IgbmV3IGFjY291bnQgYW5kIGV4aXN0aW5nIGNsaWVudCBkZXRhaWxzIHdpbGwgYmUgdXNlZCBpZiBjbGllbnQgb3BlbiBhbm90aGVyIGFjY291bnQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnNlY3JldF9xdWVzdGlvbiAtIFtPcHRpb25hbF0gQWNjZXB0IGFueSB2YWx1ZSBpbiBlbnVtIGxpc3QuIFJlcXVpcmVkIGZvciBuZXcgYWNjb3VudCBhbmQgZXhpc3RpbmcgY2xpZW50IGRldGFpbHMgd2lsbCBiZSB1c2VkIGlmIGNsaWVudCBvcGVuIGFub3RoZXIgYWNjb3VudC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MudGF4X2lkZW50aWZpY2F0aW9uX251bWJlciAtIFtPcHRpb25hbF0gVGF4IGlkZW50aWZpY2F0aW9uIG51bWJlci4gT25seSBhcHBsaWNhYmxlIGZvciByZWFsIG1vbmV5IGFjY291bnQuIFJlcXVpcmVkIGZvciBgbWFsdGFpbnZlc3RgIGxhbmRpbmcgY29tcGFueS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MudGF4X3Jlc2lkZW5jZSAtIFtPcHRpb25hbF0gUmVzaWRlbmNlIGZvciB0YXggcHVycG9zZS4gQ29tbWEgc2VwYXJhdGVkIGlzbyBjb3VudHJ5IGNvZGUgaWYgbXVsdGlwbGUganVyaXNkaWN0aW9ucy4gT25seSBhcHBsaWNhYmxlIGZvciByZWFsIG1vbmV5IGFjY291bnQuIFJlcXVpcmVkIGZvciBgbWFsdGFpbnZlc3RgIGxhbmRpbmcgY29tcGFueS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImFmZmlsaWF0ZUFjY291bnRBZGRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWZmaWxpYXRlQWNjb3VudEFkZCgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGFjY291bnRfb3BlbmluZ19yZWFzb246IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBhY2NvdW50X3R1cm5vdmVyOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgYWRkcmVzc19jaXR5OiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgYWRkcmVzc19saW5lXzE6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBhZGRyZXNzX2xpbmVfMjoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGFkZHJlc3NfcG9zdGNvZGU6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBhZGRyZXNzX3N0YXRlOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgYWZmaWxpYXRlX2FjY291bnRfYWRkOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBhZmZpbGlhdGVfcGxhbjoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGFmZmlsaWF0ZV90b2tlbjoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGNpdGl6ZW46IHt9LFxcbiAgICAgICAgY2xpZW50X3R5cGU6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBjdXJyZW5jeToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGRhdGVfb2ZfYmlydGg6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBmaXJzdF9uYW1lOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgbGFzdF9uYW1lOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgbm9uX3BlcF9kZWNsYXJhdGlvbjoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICBwaG9uZToge30sXFxuICAgICAgICBwbGFjZV9vZl9iaXJ0aDoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICByZXNpZGVuY2U6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBzYWx1dGF0aW9uOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgc2VjcmV0X2Fuc3dlcjoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHNlY3JldF9xdWVzdGlvbjoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHRheF9pZGVudGlmaWNhdGlvbl9udW1iZXI6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICB0YXhfcmVzaWRlbmNlOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ2FmZmlsaWF0ZV9hY2NvdW50X2FkZCcsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuYXBpX3Rva2VuIC0gTXVzdCBiZSBgMWBcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuZGVsZXRlX3Rva2VuIC0gW09wdGlvbmFsXSBUaGUgdG9rZW4gdG8gcmVtb3ZlLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5uZXdfdG9rZW4gLSBbT3B0aW9uYWxdIFRoZSBuYW1lIG9mIHRoZSBjcmVhdGVkIHRva2VuLlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5uZXdfdG9rZW5fc2NvcGVzIC0gW09wdGlvbmFsXSBMaXN0IG9mIHBlcm1pc3Npb24gc2NvcGVzIHRvIHByb3ZpZGUgd2l0aCB0aGUgdG9rZW4uXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy52YWxpZF9mb3JfY3VycmVudF9pcF9vbmx5IC0gW09wdGlvbmFsXSBJZiB5b3Ugc2V0IHRoaXMgcGFyYW1ldGVyIGR1cmluZyB0b2tlbiBjcmVhdGlvbiwgdGhlbiB0aGUgdG9rZW4gY3JlYXRlZCB3aWxsIG9ubHkgd29yayBmb3IgdGhlIElQIGFkZHJlc3MgdGhhdCB3YXMgdXNlZCB0byBjcmVhdGUgdGhlIHRva2VuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJhcGlUb2tlblxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcGlUb2tlbigpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGFwaV90b2tlbjoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgZGVsZXRlX3Rva2VuOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgbmV3X3Rva2VuOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgbmV3X3Rva2VuX3Njb3Blczoge30sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgdmFsaWRfZm9yX2N1cnJlbnRfaXBfb25seToge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAnYXBpX3Rva2VuJyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5hcHBfZGVsZXRlIC0gQXBwbGljYXRpb24gYXBwX2lkXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiYXBwRGVsZXRlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcERlbGV0ZSgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGFwcF9kZWxldGU6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAnYXBwX2RlbGV0ZScsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuYXBwX2dldCAtIEFwcGxpY2F0aW9uIGFwcF9pZFxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImFwcEdldFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBHZXQoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBhcHBfZ2V0OiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ2FwcF9nZXQnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmFwcF9saXN0IC0gTXVzdCBiZSBgMWBcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJhcHBMaXN0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcExpc3QoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBhcHBfbGlzdDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdhcHBfbGlzdCcsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuYXBwX2lkIC0gW09wdGlvbmFsXSBTcGVjaWZpYyBhcHBsaWNhdGlvbiBgYXBwX2lkYCB0byByZXBvcnQgb24uXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmFwcF9tYXJrdXBfZGV0YWlscyAtIE11c3QgYmUgYDFgXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmNsaWVudF9sb2dpbmlkIC0gW09wdGlvbmFsXSBTcGVjaWZpYyBjbGllbnQgbG9naW5pZCB0byByZXBvcnQgb24sIGxpa2UgQ1IxMjM0NVxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5kYXRlX2Zyb20gLSBTdGFydCBkYXRlIChlcG9jaCBvciBZWVlZLU1NLUREIEhIOk1NOlNTKS4gUmVzdWx0cyBhcmUgaW5jbHVzaXZlIG9mIHRoaXMgdGltZS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuZGF0ZV90byAtIEVuZCBkYXRlIChlcG9jaCBvciBZWVlZLU1NLUREIEhIOjpNTTo6U1MpLiBSZXN1bHRzIGFyZSBpbmNsdXNpdmUgb2YgdGhpcyB0aW1lLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5kZXNjcmlwdGlvbiAtIFtPcHRpb25hbF0gSWYgc2V0IHRvIDEsIHdpbGwgcmV0dXJuIGBhcHBfbWFya3VwYCB0cmFuc2FjdGlvbiBkZXRhaWxzLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5saW1pdCAtIFtPcHRpb25hbF0gQXBwbHkgdXBwZXIgbGltaXQgdG8gY291bnQgb2YgdHJhbnNhY3Rpb25zIHJlY2VpdmVkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5vZmZzZXQgLSBbT3B0aW9uYWxdIE51bWJlciBvZiB0cmFuc2FjdGlvbnMgdG8gc2tpcC5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnNvcnQgLSBbT3B0aW9uYWxdIFNvcnQgZGlyZWN0aW9uIG9uIGB0cmFuc2FjdGlvbl90aW1lYC4gT3RoZXIgZmllbGRzIHNvcnQgb3JkZXIgaXMgQVNDLlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5zb3J0X2ZpZWxkcyAtIFtPcHRpb25hbF0gT25lIG9yIG1vcmUgb2YgdGhlIHNwZWNpZmllZCBmaWVsZHMgdG8gc29ydCBvbi4gRGVmYXVsdCBzb3J0IGZpZWxkIGlzIGJ5IGB0cmFuc2FjdGlvbl90aW1lYC5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImFwcE1hcmt1cERldGFpbHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwTWFya3VwRGV0YWlscygpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGFwcF9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBhcHBfbWFya3VwX2RldGFpbHM6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGNsaWVudF9sb2dpbmlkOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgZGF0ZV9mcm9tOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGRhdGVfdG86IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgZGVzY3JpcHRpb246IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgbGltaXQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgb2Zmc2V0OiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBzb3J0OiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgc29ydF9maWVsZHM6IHt9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ2FwcF9tYXJrdXBfZGV0YWlscycsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuYXBwX21hcmt1cF9wZXJjZW50YWdlIC0gW09wdGlvbmFsXSBNYXJrdXAgdG8gYmUgYWRkZWQgdG8gY29udHJhY3QgcHJpY2VzIChhcyBhIHBlcmNlbnRhZ2Ugb2YgY29udHJhY3QgcGF5b3V0KS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuYXBwX3JlZ2lzdGVyIC0gTXVzdCBiZSBgMWBcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuYXBwc3RvcmUgLSBbT3B0aW9uYWxdIEFwcGxpY2F0aW9uJ3MgQXBwIFN0b3JlIFVSTCAoaWYgYXBwbGljYWJsZSkuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmdpdGh1YiAtIFtPcHRpb25hbF0gQXBwbGljYXRpb24ncyBHaXRIdWIgcGFnZSAoZm9yIG9wZW4tc291cmNlIHByb2plY3RzKS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuZ29vZ2xlcGxheSAtIFtPcHRpb25hbF0gQXBwbGljYXRpb24ncyBHb29nbGUgUGxheSBVUkwgKGlmIGFwcGxpY2FibGUpLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5ob21lcGFnZSAtIFtPcHRpb25hbF0gQXBwbGljYXRpb24ncyBob21lcGFnZSBVUkwuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLm5hbWUgLSBBcHBsaWNhdGlvbiBuYW1lLlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnJlZGlyZWN0X3VyaSAtIFtPcHRpb25hbF0gVGhlIFVSTCB0byByZWRpcmVjdCB0byBhZnRlciBhIHN1Y2Nlc3NmdWwgbG9naW4uIFJlcXVpcmVkIGlmIGNoYXJnaW5nIG1hcmt1cCBwZXJjZW50YWdlXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3Muc2NvcGVzIC0gTGlzdCBvZiBwZXJtaXNzaW9uIHNjb3BlcyB0byBncmFudCB0aGUgYXBwbGljYXRpb24uXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnZlcmlmaWNhdGlvbl91cmkgLSBbT3B0aW9uYWxdIFVzZWQgd2hlbiBgdmVyaWZ5X2VtYWlsYCBjYWxsZWQuIElmIGF2YWlsYWJsZSwgYSBVUkwgY29udGFpbmluZyB0aGUgdmVyaWZpY2F0aW9uIHRva2VuIHdpbGwgYmUgc2VudCB0byB0aGUgY2xpZW50J3MgZW1haWwsIG90aGVyd2lzZSBvbmx5IHRoZSB0b2tlbiB3aWxsIGJlIHNlbnQuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJhcHBSZWdpc3RlclxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBSZWdpc3RlcigpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGFwcF9tYXJrdXBfcGVyY2VudGFnZToge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBhcHBfcmVnaXN0ZXI6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGFwcHN0b3JlOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgZ2l0aHViOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgZ29vZ2xlcGxheToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGhvbWVwYWdlOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgbmFtZToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZWRpcmVjdF91cmk6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgc2NvcGVzOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxXFxuICAgICAgICB9LFxcbiAgICAgICAgdmVyaWZpY2F0aW9uX3VyaToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdhcHBfcmVnaXN0ZXInLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmFwcF9tYXJrdXBfcGVyY2VudGFnZSAtIFtPcHRpb25hbF0gTWFya3VwIHRvIGJlIGFkZGVkIHRvIGNvbnRyYWN0IHByaWNlcyAoYXMgYSBwZXJjZW50YWdlIG9mIGNvbnRyYWN0IHBheW91dCkuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmFwcF91cGRhdGUgLSBBcHBsaWNhdGlvbiBhcHBfaWQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmFwcHN0b3JlIC0gW09wdGlvbmFsXSBBcHBsaWNhdGlvbidzIEFwcCBTdG9yZSBVUkwgKGlmIGFwcGxpY2FibGUpLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5naXRodWIgLSBbT3B0aW9uYWxdIEFwcGxpY2F0aW9uJ3MgR2l0SHViIHBhZ2UgKGZvciBvcGVuLXNvdXJjZSBwcm9qZWN0cykuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmdvb2dsZXBsYXkgLSBbT3B0aW9uYWxdIEFwcGxpY2F0aW9uJ3MgR29vZ2xlIFBsYXkgVVJMIChpZiBhcHBsaWNhYmxlKS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuaG9tZXBhZ2UgLSBbT3B0aW9uYWxdIEFwcGxpY2F0aW9uJ3MgaG9tZXBhZ2UgVVJMLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5uYW1lIC0gQXBwbGljYXRpb24gbmFtZS5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5yZWRpcmVjdF91cmkgLSBbT3B0aW9uYWxdIFRoZSBVUkwgdG8gcmVkaXJlY3QgdG8gYWZ0ZXIgYSBzdWNjZXNzZnVsIGxvZ2luLiBSZXF1aXJlZCBpZiBjaGFyZ2luZyBtYXJrdXAgcGVyY2VudGFnZS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5zY29wZXMgLSBDaGFuZ2Ugc2NvcGVzIHdpbGwgcmV2b2tlIGFsbCB1c2VyJ3MgZ3JhbnRzIGFuZCBsb2cgdGhlbSBvdXQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnZlcmlmaWNhdGlvbl91cmkgLSBbT3B0aW9uYWxdIFVzZWQgd2hlbiBgdmVyaWZ5X2VtYWlsYCBjYWxsZWQuIElmIGF2YWlsYWJsZSwgYSBVUkwgY29udGFpbmluZyB0aGUgdmVyaWZpY2F0aW9uIHRva2VuIHdpbGwgc2VuZCB0byB0aGUgY2xpZW50J3MgZW1haWwsIG90aGVyd2lzZSBvbmx5IHRoZSB0b2tlbiB3aWxsIGJlIHNlbnQuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJhcHBVcGRhdGVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwVXBkYXRlKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgYXBwX21hcmt1cF9wZXJjZW50YWdlOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGFwcF91cGRhdGU6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGFwcHN0b3JlOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgZ2l0aHViOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgZ29vZ2xlcGxheToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGhvbWVwYWdlOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgbmFtZToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZWRpcmVjdF91cmk6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgc2NvcGVzOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxXFxuICAgICAgICB9LFxcbiAgICAgICAgdmVyaWZpY2F0aW9uX3VyaToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdhcHBfdXBkYXRlJyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5hc3NldF9pbmRleCAtIE11c3QgYmUgYDFgXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmxhbmRpbmdfY29tcGFueSAtIFtPcHRpb25hbF0gSWYgc3BlY2lmaWVkLCB3aWxsIHJldHVybiBvbmx5IHRoZSB1bmRlcmx5aW5ncyBmb3IgdGhlIHNwZWNpZmllZCBsYW5kaW5nIGNvbXBhbnkuXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiYXNzZXRJbmRleFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhc3NldEluZGV4KCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgYXNzZXRfaW5kZXg6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGxhbmRpbmdfY29tcGFueToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAnYXNzZXRfaW5kZXgnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmFkZF90b19sb2dpbl9oaXN0b3J5IC0gW09wdGlvbmFsXSBTZW5kIHRoaXMgd2hlbiB5b3UgdXNlIGFwaSB0b2tlbnMgZm9yIGF1dGhvcml6YXRpb24gYW5kIHdhbnQgdG8gdHJhY2sgYWN0aXZpdHkgdXNpbmcgYGxvZ2luX2hpc3RvcnlgIGNhbGwuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmF1dGhvcml6ZSAtIEF1dGhlbnRpY2F0aW9uIHRva2VuLiBNYXkgYmUgcmV0cmlldmVkIGZyb20gaHR0cHM6Ly93d3cuYmluYXJ5LmNvbS9lbi91c2VyL3NlY3VyaXR5L2FwaV90b2tlbndzLmh0bWxcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJhdXRob3JpemVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXV0aG9yaXplKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgYWRkX3RvX2xvZ2luX2hpc3Rvcnk6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgYXV0aG9yaXplOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAnYXV0aG9yaXplJyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5hY2NvdW50IC0gW09wdGlvbmFsXSBJZiBzZXQgdG8gYGFsbGAsIHJldHVybiB0aGUgYmFsYW5jZXMgb2YgYWxsIGFjY291bnRzIG9uZSBieSBvbmU7IGlmIHNldCB0byBgY3VycmVudGAsIHJldHVybiB0aGUgYmFsYW5jZSBvZiBjdXJyZW50IGFjY291bnQ7IGlmIHNldCBhcyBhbiBhY2NvdW50IGlkLCByZXR1cm4gdGhlIGJhbGFuY2Ugb2YgdGhhdCBhY2NvdW50LlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5iYWxhbmNlIC0gTXVzdCBiZSBgMWBcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnN1YnNjcmliZSAtIFtPcHRpb25hbF0gSWYgc2V0IHRvIDEsIHdpbGwgc2VuZCB1cGRhdGVzIHdoZW5ldmVyIHRoZSBiYWxhbmNlIGNoYW5nZXMuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJiYWxhbmNlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJhbGFuY2UoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBhY2NvdW50OiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgYmFsYW5jZToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHN1YnNjcmliZToge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAnYmFsYW5jZScsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuYnV5IC0gRWl0aGVyIHRoZSBJRCByZWNlaXZlZCBmcm9tIGEgUHJpY2UgUHJvcG9zYWwgKGBwcm9wb3NhbGAgY2FsbCksIG9yIGAxYCBpZiBjb250cmFjdCBidXkgcGFyYW1ldGVycyBhcmUgcGFzc2VkIGluIHRoZSBgcGFyYW1ldGVyc2AgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhcmFtZXRlcnMgLVxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnByaWNlIC0gTWF4aW11bSBwcmljZSBhdCB3aGljaCB0byBwdXJjaGFzZSB0aGUgY29udHJhY3QuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3Muc3Vic2NyaWJlIC0gW09wdGlvbmFsXSBgMWAgdG8gc3RyZWFtLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiYnV5XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1eSgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGJ1eToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXJhbWV0ZXJzOiB7XFxuICAgICAgICAgIGFtb3VudDoge1xcbiAgICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBhcHBfbWFya3VwX3BlcmNlbnRhZ2U6IHtcXG4gICAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgYmFycmllcjoge1xcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIGJhcnJpZXIyOiB7XFxuICAgICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgYmFzaXM6IHtcXG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBjYW5jZWxsYXRpb246IHtcXG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBjb250cmFjdF90eXBlOiB7XFxuICAgICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgY3VycmVuY3k6IHtcXG4gICAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBkYXRlX2V4cGlyeToge1xcbiAgICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBkYXRlX3N0YXJ0OiB7XFxuICAgICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIGR1cmF0aW9uOiB7XFxuICAgICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIGR1cmF0aW9uX3VuaXQ6IHtcXG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBsaW1pdF9vcmRlcjoge1xcbiAgICAgICAgICAgIHN0b3BfbG9zczoge1xcbiAgICAgICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICB0YWtlX3Byb2ZpdDoge1xcbiAgICAgICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBtdWx0aXBsaWVyOiB7XFxuICAgICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIHByb2R1Y3RfdHlwZToge1xcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIHNlbGVjdGVkX3RpY2s6IHtcXG4gICAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgc3ltYm9sOiB7XFxuICAgICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgdHJhZGluZ19wZXJpb2Rfc3RhcnQ6IHtcXG4gICAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHByaWNlOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgc3Vic2NyaWJlOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdidXknLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmJ1eV9jb250cmFjdF9mb3JfbXVsdGlwbGVfYWNjb3VudHMgLSBFaXRoZXIgdGhlIElEIHJlY2VpdmVkIGZyb20gYSBQcmljZSBQcm9wb3NhbCAoYHByb3Bvc2FsYCBjYWxsKSwgb3IgYDFgIGlmIGNvbnRyYWN0IGJ1eSBwYXJhbWV0ZXJzIGFyZSBwYXNzZWQgaW4gdGhlIGBwYXJhbWV0ZXJzYCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFyYW1ldGVycyAtXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucHJpY2UgLSBNYXhpbXVtIHByaWNlIGF0IHdoaWNoIHRvIHB1cmNoYXNlIHRoZSBjb250cmFjdC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy50b2tlbnMgLSBMaXN0IG9mIEFQSSB0b2tlbnMgaWRlbnRpZnlpbmcgdGhlIGFjY291bnRzIGZvciB3aGljaCB0aGUgY29udHJhY3QgaXMgYm91Z2h0LiBOb3RlOiBJZiB0aGUgc2FtZSB0b2tlbiBhcHBlYXJzIG11bHRpcGxlIHRpbWVzIG9yIGlmIG11bHRpcGxlIHRva2VucyBkZXNpZ25hdGUgdGhlIHNhbWUgYWNjb3VudCwgdGhlIGNvbnRyYWN0IGlzIGJvdWdodCBtdWx0aXBsZSB0aW1lcyBmb3IgdGhpcyBhY2NvdW50LlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiYnV5Q29udHJhY3RGb3JNdWx0aXBsZUFjY291bnRzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1eUNvbnRyYWN0Rm9yTXVsdGlwbGVBY2NvdW50cygpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGJ1eV9jb250cmFjdF9mb3JfbXVsdGlwbGVfYWNjb3VudHM6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFyYW1ldGVyczoge1xcbiAgICAgICAgICBhbW91bnQ6IHtcXG4gICAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgYXBwX21hcmt1cF9wZXJjZW50YWdlOiB7XFxuICAgICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIGJhcnJpZXI6IHtcXG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBiYXJyaWVyMjoge1xcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIGJhc2lzOiB7XFxuICAgICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgY29udHJhY3RfdHlwZToge1xcbiAgICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIGN1cnJlbmN5OiB7XFxuICAgICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgZGF0ZV9leHBpcnk6IHtcXG4gICAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgZGF0ZV9zdGFydDoge1xcbiAgICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBkdXJhdGlvbjoge1xcbiAgICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBkdXJhdGlvbl91bml0OiB7XFxuICAgICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgbXVsdGlwbGllcjoge1xcbiAgICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBzZWxlY3RlZF90aWNrOiB7XFxuICAgICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIHN5bWJvbDoge1xcbiAgICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICBwcmljZToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHRva2Vuczoge1xcbiAgICAgICAgICByZXF1aXJlZDogMVxcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdidXlfY29udHJhY3RfZm9yX211bHRpcGxlX2FjY291bnRzJyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5jYW5jZWwgLSBWYWx1ZSBzaG91bGQgYmUgdGhlIGBjb250cmFjdF9pZGAgd2hpY2ggcmVjZWl2ZWQgZnJvbSB0aGUgYHBvcnRmb2xpb2AgY2FsbC5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJjYW5jZWxcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuY2VsKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgY2FuY2VsOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ2NhbmNlbCcsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuYWRkcmVzcyAtIFtPcHRpb25hbF0gQWRkcmVzcyBmb3IgY3J5cHRvIHdpdGhkcmF3YWwuIE9ubHkgYXBwbGljYWJsZSBmb3IgYGFwaWAgdHlwZS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuYW1vdW50IC0gW09wdGlvbmFsXSBBbW91bnQgZm9yIGNyeXB0byB3aXRoZHJhd2FsLiBPbmx5IGFwcGxpY2FibGUgZm9yIGBhcGlgIHR5cGUuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmNhc2hpZXIgLSBPcGVyYXRpb24gd2hpY2ggbmVlZHMgdG8gYmUgcmVxdWVzdGVkIGZyb20gY2FzaGllclxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5kcnlfcnVuIC0gW09wdGlvbmFsXSBJZiBzZXQgdG8gYDFgLCBvbmx5IHZhbGlkYXRpb24gaXMgcGVyZm9ybWVkLiBPbmx5IGFwcGxpY2FibGUgZm9yIGB3aXRoZHJhd2AgdXNpbmcgYGNyeXB0b2AgcHJvdmlkZXIgYW5kIGBhcGlgIHR5cGUuXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MucHJvdmlkZXIgLSBbT3B0aW9uYWxdIENhc2hpZXIgcHJvdmlkZXIuIGBjcnlwdG9gIHdpbGwgYmUgZGVmYXVsdCBvcHRpb24gZm9yIGNyeXB0byBjdXJyZW5jeSBhY2NvdW50cy5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy50eXBlIC0gW09wdGlvbmFsXSBEYXRhIG5lZWQgdG8gYmUgcmV0dXJuZWQgZnJvbSBjYXNoaWVyLiBgYXBpYCBpcyBzdXBwb3J0ZWQgb25seSBmb3IgYGNyeXB0b2AgcHJvdmlkZXIuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnZlcmlmaWNhdGlvbl9jb2RlIC0gW09wdGlvbmFsXSBFbWFpbCB2ZXJpZmljYXRpb24gY29kZSAocmVjZWl2ZWQgZnJvbSBhIGB2ZXJpZnlfZW1haWxgIGNhbGwsIHdoaWNoIG11c3QgYmUgZG9uZSBmaXJzdClcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImNhc2hpZXJcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FzaGllcigpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGFkZHJlc3M6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBhbW91bnQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgY2FzaGllcjoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBkcnlfcnVuOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHByb3ZpZGVyOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHR5cGU6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICB2ZXJpZmljYXRpb25fY29kZToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdjYXNoaWVyJyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5jYXNoaWVyX3BheW1lbnRzIC0gTXVzdCBiZSBgMWBcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5wcm92aWRlciAtIFtPcHRpb25hbF0gQ2FzaGllciBwcm92aWRlci4gYGNyeXB0b2Agd2lsbCBiZSBkZWZhdWx0IG9wdGlvbiBmb3IgY3J5cHRvIGN1cnJlbmN5IGFjY291bnRzLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnN1YnNjcmliZSAtIFtPcHRpb25hbF0gSWYgc2V0IHRvIDEsIHdpbGwgc2VuZCB1cGRhdGVzIHdoZW5ldmVyIHRoZXJlIGlzIHVwZGF0ZSB0byBjcnlwdG8gcGF5bWVudHMuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnRyYW5zYWN0aW9uX3R5cGUgLSBbT3B0aW9uYWxdIFR5cGUgb2YgdHJhbnNhY3Rpb25zIHRvIHJlY2VpdmUuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJjYXNoaWVyUGF5bWVudHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FzaGllclBheW1lbnRzKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgY2FzaGllcl9wYXltZW50czoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcHJvdmlkZXI6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgc3Vic2NyaWJlOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHRyYW5zYWN0aW9uX3R5cGU6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAnY2FzaGllcl9wYXltZW50cycsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuY2FzaGllcl93aXRoZHJhd2FsX2NhbmNlbCAtIE11c3QgYmUgYDFgXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdHJhbnNhY3Rpb24uXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiY2FzaGllcldpdGhkcmF3YWxDYW5jZWxcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FzaGllcldpdGhkcmF3YWxDYW5jZWwoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBjYXNoaWVyX3dpdGhkcmF3YWxfY2FuY2VsOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBpZDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ2Nhc2hpZXJfd2l0aGRyYXdhbF9jYW5jZWwnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmNoYW5nZV9wYXNzd29yZCAtIE11c3QgYmUgYDFgXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLm5ld19wYXNzd29yZCAtIE5ldyBwYXNzd29yZCAoQWNjZXB0cyBhbnkgcHJpbnRhYmxlIEFTQ0lJIGNoYXJhY3Rlci4gTXVzdCBiZSB3aXRoaW4gOC0yNSBjaGFyYWN0ZXJzLCBhbmQgaW5jbHVkZSBudW1iZXJzLCBsb3dlcmNhc2UgYW5kIHVwcGVyY2FzZSBsZXR0ZXJzLiBNdXN0IG5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgdXNlcidzIGVtYWlsIGFkZHJlc3MpXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLm9sZF9wYXNzd29yZCAtIE9sZCBwYXNzd29yZCBmb3IgdmFsaWRhdGlvbiAobm9uLWVtcHR5IHN0cmluZywgYWNjZXB0cyBhbnkgcHJpbnRhYmxlIEFTQ0lJIGNoYXJhY3RlcilcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJjaGFuZ2VQYXNzd29yZFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGFuZ2VQYXNzd29yZCgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGNoYW5nZV9wYXNzd29yZDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgbmV3X3Bhc3N3b3JkOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIG9sZF9wYXNzd29yZDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ2NoYW5nZV9wYXNzd29yZCcsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuY29udHJhY3RfaWQgLSBJbnRlcm5hbCB1bmlxdWUgY29udHJhY3QgaWRlbnRpZmllci5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuY29udHJhY3RfdXBkYXRlIC0gTXVzdCBiZSBgMWBcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MubGltaXRfb3JkZXIgLVxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImNvbnRyYWN0VXBkYXRlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRyYWN0VXBkYXRlKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgY29udHJhY3RfaWQ6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGNvbnRyYWN0X3VwZGF0ZToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgbGltaXRfb3JkZXI6IHtcXG4gICAgICAgICAgc3RvcF9sb3NzOiB7fSxcXG4gICAgICAgICAgdGFrZV9wcm9maXQ6IHt9XFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdjb250cmFjdF91cGRhdGUnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmNvbnRyYWN0X2lkIC0gSW50ZXJuYWwgdW5pcXVlIGNvbnRyYWN0IGlkZW50aWZpZXIuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmNvbnRyYWN0X3VwZGF0ZV9oaXN0b3J5IC0gTXVzdCBiZSBgMWBcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MubGltaXQgLSBbT3B0aW9uYWxdIE1heGltdW0gbnVtYmVyIG9mIGhpc3RvcmljYWwgdXBkYXRlcyB0byByZWNlaXZlLlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImNvbnRyYWN0VXBkYXRlSGlzdG9yeVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb250cmFjdFVwZGF0ZUhpc3RvcnkoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBjb250cmFjdF9pZDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgY29udHJhY3RfdXBkYXRlX2hpc3Rvcnk6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGxpbWl0OiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAnY29udHJhY3RfdXBkYXRlX2hpc3RvcnknLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmNvbnRyYWN0c19mb3IgLSBUaGUgc2hvcnQgc3ltYm9sIG5hbWUgKG9idGFpbmVkIGZyb20gYGFjdGl2ZV9zeW1ib2xzYCBjYWxsKS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuY3VycmVuY3kgLSBbT3B0aW9uYWxdIEN1cnJlbmN5IG9mIHRoZSBjb250cmFjdCdzIHN0YWtlIGFuZCBwYXlvdXQgKG9idGFpbmVkIGZyb20gYHBheW91dF9jdXJyZW5jaWVzYCBjYWxsKS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MubGFuZGluZ19jb21wYW55IC0gW09wdGlvbmFsXSBJbmRpY2F0ZXMgd2hpY2ggbGFuZGluZyBjb21wYW55IHRvIGdldCBhIGxpc3Qgb2YgY29udHJhY3RzIGZvci4gSWYgeW91IGFyZSBsb2dnZWQgaW4sIHlvdXIgYWNjb3VudCdzIGxhbmRpbmcgY29tcGFueSB3aWxsIG92ZXJyaWRlIHRoaXMgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MucHJvZHVjdF90eXBlIC0gW09wdGlvbmFsXSBJZiB5b3Ugc3BlY2lmeSB0aGlzIGZpZWxkLCBvbmx5IGNvbnRyYWN0cyB0cmFkYWJsZSB0aHJvdWdoIHRoYXQgY29udHJhY3QgdHlwZSB3aWxsIGJlIHJldHVybmVkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJjb250cmFjdHNGb3JcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udHJhY3RzRm9yKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgY29udHJhY3RzX2Zvcjoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBjdXJyZW5jeToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGxhbmRpbmdfY29tcGFueToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHByb2R1Y3RfdHlwZToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAnY29udHJhY3RzX2ZvcicsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MuYXNzZXRzIC0gW09wdGlvbmFsXSBVc2VkIHRvIHNldCBhc3NldHMgdG8gYmUgY29waWVkLiBFLnggW1xcXCJmcnhVU0RKUFlcXFwiLCBcXFwiUl81MFxcXCJdXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmNvcHlfc3RhcnQgLSBBUEkgdG9rZW5zIGlkZW50aWZ5aW5nIHRoZSBhY2NvdW50cyBvZiB0cmFkZXIgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIGNvcHkgdHJhZGVzXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLm1heF90cmFkZV9zdGFrZSAtIFtPcHRpb25hbF0gVXNlZCB0byBzZXQgbWF4aW11bSB0cmFkZSBzdGFrZSB0byBiZSBjb3BpZWQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLm1pbl90cmFkZV9zdGFrZSAtIFtPcHRpb25hbF0gVXNlZCB0byBzZXQgbWluaW1hbCB0cmFkZSBzdGFrZSB0byBiZSBjb3BpZWQuXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy50cmFkZV90eXBlcyAtIFtPcHRpb25hbF0gVXNlZCB0byBzZXQgdHJhZGUgdHlwZXMgdG8gYmUgY29waWVkLiBFLnggW1xcXCJDQUxMXFxcIiwgXFxcIlBVVFxcXCJdXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJjb3B5U3RhcnRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weVN0YXJ0KCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgYXNzZXRzOiB7fSxcXG4gICAgICAgIGNvcHlfc3RhcnQ6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgbWF4X3RyYWRlX3N0YWtlOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIG1pbl90cmFkZV9zdGFrZToge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgdHJhZGVfdHlwZXM6IHt9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ2NvcHlfc3RhcnQnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmNvcHlfc3RvcCAtIEFQSSB0b2tlbnMgaWRlbnRpZnlpbmcgdGhlIGFjY291bnRzIHdoaWNoIG5lZWRzIG5vdCB0byBiZSBjb3BpZWRcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJjb3B5U3RvcFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5U3RvcCgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGNvcHlfc3RvcDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ2NvcHlfc3RvcCcsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuY29weXRyYWRpbmdfbGlzdCAtIE11c3QgYmUgYDFgXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiY29weXRyYWRpbmdMaXN0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHl0cmFkaW5nTGlzdCgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGNvcHl0cmFkaW5nX2xpc3Q6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAnY29weXRyYWRpbmdfbGlzdCcsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuY29weXRyYWRpbmdfc3RhdGlzdGljcyAtIE11c3QgYmUgYDFgXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy50cmFkZXJfaWQgLSBUaGUgSUQgb2YgdGhlIHRhcmdldCB0cmFkZXIuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJjb3B5dHJhZGluZ1N0YXRpc3RpY3NcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weXRyYWRpbmdTdGF0aXN0aWNzKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgY29weXRyYWRpbmdfc3RhdGlzdGljczoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHRyYWRlcl9pZDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAnY29weXRyYWRpbmdfc3RhdGlzdGljcycsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuZG9jdW1lbnRfZm9ybWF0IC0gRG9jdW1lbnQgZmlsZSBmb3JtYXRcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuZG9jdW1lbnRfaWQgLSBbT3B0aW9uYWxdIERvY3VtZW50IElEIChyZXF1aXJlZCBmb3IgUGFzc3BvcnQsIFByb29mIG9mIElEIGFuZCBEcml2ZXIncyBMaWNlbnNlKVxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5kb2N1bWVudF9pc3N1aW5nX2NvdW50cnkgLSBbT3B0aW9uYWxdIDItbGV0dGVyIGNvdW50cnkgY29kZVxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5kb2N1bWVudF90eXBlIC0gRG9jdW1lbnQgdHlwZVxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5kb2N1bWVudF91cGxvYWQgLSBNdXN0IGJlIGAxYFxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5leHBlY3RlZF9jaGVja3N1bSAtIFRoZSBjaGVja3N1bSBvZiB0aGUgZmlsZSB0byBiZSB1cGxvYWRlZFxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5leHBpcmF0aW9uX2RhdGUgLSBbT3B0aW9uYWxdIERvY3VtZW50IGV4cGlyYXRpb24gZGF0ZSAocmVxdWlyZWQgZm9yIFBhc3Nwb3J0LCBQcm9vZiBvZiBJRCBhbmQgRHJpdmVyJ3MgTGljZW5zZSlcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuZmlsZV9zaXplIC0gRG9jdW1lbnQgc2l6ZSAoc2hvdWxkIGJlIGxlc3MgdGhhbiAxME1CKVxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5saWZldGltZV92YWxpZCAtIFtPcHRpb25hbF0gQm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoaXMgZG9jdW1lbnQgaXMgbGlmZXRpbWUgdmFsaWQgKG9ubHkgYXBwbGllcyB0byBQT0kgZG9jdW1lbnQgdHlwZXMsIGNhbmNlbHMgb3V0IHRoZSBleHBpcmF0aW9uX2RhdGUgZ2l2ZW4gaWYgYW55KVxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5wYWdlX3R5cGUgLSBbT3B0aW9uYWxdIFRvIGRldGVybWluZSBkb2N1bWVudCBzaWRlXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZG9jdW1lbnRVcGxvYWRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG9jdW1lbnRVcGxvYWQoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBkb2N1bWVudF9mb3JtYXQ6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgZG9jdW1lbnRfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBkb2N1bWVudF9pc3N1aW5nX2NvdW50cnk6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBkb2N1bWVudF90eXBlOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGRvY3VtZW50X3VwbG9hZDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgZXhwZWN0ZWRfY2hlY2tzdW06IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgZXhwaXJhdGlvbl9kYXRlOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgZmlsZV9zaXplOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBsaWZldGltZV92YWxpZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYWdlX3R5cGU6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ2RvY3VtZW50X3VwbG9hZCcsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuY3VycmVuY3kgLSBbT3B0aW9uYWxdIEN1cnJlbmN5IHN5bWJvbC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuZWNvbm9taWNfY2FsZW5kYXIgLSBNdXN0IGJlIGAxYFxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5lbmRfZGF0ZSAtIFtPcHRpb25hbF0gRW5kIGRhdGUuXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5zdGFydF9kYXRlIC0gW09wdGlvbmFsXSBTdGFydCBkYXRlLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZWNvbm9taWNDYWxlbmRhclxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlY29ub21pY0NhbGVuZGFyKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgY3VycmVuY3k6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBlY29ub21pY19jYWxlbmRhcjoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgZW5kX2RhdGU6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHN0YXJ0X2RhdGU6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ2Vjb25vbWljX2NhbGVuZGFyJyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5iYXNlX2N1cnJlbmN5IC0gQmFzZSBjdXJyZW5jeSAoY2FuIGJlIG9idGFpbmVkIGZyb20gYHBheW91dF9jdXJyZW5jaWVzYCBjYWxsKVxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5leGNoYW5nZV9yYXRlcyAtIE11c3QgYmUgYDFgXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZXhjaGFuZ2VSYXRlc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleGNoYW5nZVJhdGVzKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgYmFzZV9jdXJyZW5jeToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBleGNoYW5nZV9yYXRlczoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdleGNoYW5nZV9yYXRlcycsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuZm9yZ2V0IC0gSUQgb2YgdGhlIHJlYWwtdGltZSBzdHJlYW0gb2YgbWVzc2FnZXMgdG8gY2FuY2VsLlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImZvcmdldFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JnZXQoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBmb3JnZXQ6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdmb3JnZXQnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLmZvcmdldF9hbGwgLSBDYW5jZWwgYWxsIHN0cmVhbXMgYnkgdHlwZS4gVGhlIHZhbHVlIGNhbiBiZSBlaXRoZXIgYSBzaW5nbGUgdHlwZSBlLmcuIGBcXFwidGlja3NcXFwiYCwgb3IgYW4gYXJyYXkgb2YgbXVsdGlwbGUgdHlwZXMgZS5nLiBgW1xcXCJjYW5kbGVzXFxcIiwgXFxcInRpY2tzXFxcIl1gLlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImZvcmdldEFsbFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JnZXRBbGwoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBmb3JnZXRfYWxsOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdmb3JnZXRfYWxsJyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5nZXRfYWNjb3VudF9zdGF0dXMgLSBNdXN0IGJlIGAxYFxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImdldEFjY291bnRTdGF0dXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWNjb3VudFN0YXR1cygpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGdldF9hY2NvdW50X3N0YXR1czoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdnZXRfYWNjb3VudF9zdGF0dXMnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmdldF9maW5hbmNpYWxfYXNzZXNzbWVudCAtIE11c3QgYmUgYDFgXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZ2V0RmluYW5jaWFsQXNzZXNzbWVudFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGaW5hbmNpYWxBc3Nlc3NtZW50KCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgZ2V0X2ZpbmFuY2lhbF9hc3Nlc3NtZW50OiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ2dldF9maW5hbmNpYWxfYXNzZXNzbWVudCcsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuZ2V0X2xpbWl0cyAtIE11c3QgYmUgYDFgXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZ2V0TGltaXRzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExpbWl0cygpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGdldF9saW1pdHM6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAnZ2V0X2xpbWl0cycsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuZ2V0X3NlbGZfZXhjbHVzaW9uIC0gTXVzdCBiZSBgMWBcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJnZXRTZWxmRXhjbHVzaW9uXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGZFeGNsdXNpb24oKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBnZXRfc2VsZl9leGNsdXNpb246IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAnZ2V0X3NlbGZfZXhjbHVzaW9uJyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5nZXRfc2V0dGluZ3MgLSBNdXN0IGJlIGAxYFxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImdldFNldHRpbmdzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNldHRpbmdzKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgZ2V0X3NldHRpbmdzOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ2dldF9zZXR0aW5ncycsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuZG9jdW1lbnRfbnVtYmVyIC0gVGhlIGlkZW50aWZpY2F0aW9uIG51bWJlciBvZiB0aGUgZG9jdW1lbnQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmRvY3VtZW50X3R5cGUgLSBUaGUgdHlwZSBvZiB0aGUgZG9jdW1lbnQgYmFzZWQgb24gcHJvdmlkZWQgYGlzc3VpbmdfY291bnRyeWAgKGNhbiBvYnRhaW5lZCBmcm9tIGByZXNpZGVuY2VfbGlzdGAgY2FsbCkuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmlkZW50aXR5X3ZlcmlmaWNhdGlvbl9kb2N1bWVudF9hZGQgLSBNdXN0IGJlIGAxYFxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5pc3N1aW5nX2NvdW50cnkgLSAyLWxldHRlciBjb3VudHJ5IGNvZGUgKGNhbiBvYnRhaW5lZCBmcm9tIGByZXNpZGVuY2VfbGlzdGAgY2FsbCkuXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiaWRlbnRpdHlWZXJpZmljYXRpb25Eb2N1bWVudEFkZFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpZGVudGl0eVZlcmlmaWNhdGlvbkRvY3VtZW50QWRkKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgZG9jdW1lbnRfbnVtYmVyOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGRvY3VtZW50X3R5cGU6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgaWRlbnRpdHlfdmVyaWZpY2F0aW9uX2RvY3VtZW50X2FkZDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgaXNzdWluZ19jb3VudHJ5OiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAnaWRlbnRpdHlfdmVyaWZpY2F0aW9uX2RvY3VtZW50X2FkZCcsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MubGFuZGluZ19jb21wYW55IC0gQ2xpZW50J3MgMi1sZXR0ZXIgY291bnRyeSBjb2RlIChvYnRhaW5lZCBmcm9tIGByZXNpZGVuY2VfbGlzdGAgY2FsbCkuXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwibGFuZGluZ0NvbXBhbnlcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGFuZGluZ0NvbXBhbnkoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBsYW5kaW5nX2NvbXBhbnk6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdsYW5kaW5nX2NvbXBhbnknLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmxhbmRpbmdfY29tcGFueV9kZXRhaWxzIC0gTGFuZGluZyBjb21wYW55IHNob3J0Y29kZS5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJsYW5kaW5nQ29tcGFueURldGFpbHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGFuZGluZ0NvbXBhbnlEZXRhaWxzKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgbGFuZGluZ19jb21wYW55X2RldGFpbHM6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdsYW5kaW5nX2NvbXBhbnlfZGV0YWlscycsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuY2xpZW50X2lkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIHRyYWRpbmcgYWNjb3VudC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MubGlua193YWxsZXQgLSBNdXN0IGJlIGAxYFxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3Mud2FsbGV0X2lkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIHdhbGxldC5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImxpbmtXYWxsZXRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlua1dhbGxldCgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGNsaWVudF9pZDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBsaW5rX3dhbGxldDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHdhbGxldF9pZDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAnbGlua193YWxsZXQnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmxpbWl0IC0gW09wdGlvbmFsXSBBcHBseSBsaW1pdCB0byBjb3VudCBvZiBsb2dpbiBoaXN0b3J5IHJlY29yZHMuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmxvZ2luX2hpc3RvcnkgLSBNdXN0IGJlIGAxYFxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImxvZ2luSGlzdG9yeVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2dpbkhpc3RvcnkoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBsaW1pdDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBsb2dpbl9oaXN0b3J5OiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ2xvZ2luX2hpc3RvcnknLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmxvZ291dCAtIE11c3QgYmUgYDFgXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwibG9nb3V0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvZ291dCgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGxvZ291dDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdsb2dvdXQnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmFtb3VudCAtIEFtb3VudCB0byBkZXBvc2l0IChpbiB0aGUgY3VycmVuY3kgb2YgZnJvbV9iaW5hcnkpOyBtaW4gPSAkMSBvciBhbiBlcXVpdmFsZW50IGFtb3VudCwgbWF4ID0gJDIwMDAwIG9yIGFuIGVxdWl2YWxlbnQgYW1vdW50XFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmZyb21fYmluYXJ5IC0gQmluYXJ5IGFjY291bnQgbG9naW5pZCB0byB0cmFuc2ZlciBtb25leSBmcm9tXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLm10NV9kZXBvc2l0IC0gTXVzdCBiZSBgMWBcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnRvX210NSAtIE1UNSBhY2NvdW50IGxvZ2luIHRvIGRlcG9zaXQgbW9uZXkgdG9cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIm10NURlcG9zaXRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbXQ1RGVwb3NpdCgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGFtb3VudDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBmcm9tX2JpbmFyeToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIG10NV9kZXBvc2l0OiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgdG9fbXQ1OiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdtdDVfZGVwb3NpdCcsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MubG9naW4gLSBNVDUgdXNlciBsb2dpblxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5tdDVfZ2V0X3NldHRpbmdzIC0gTXVzdCBiZSBgMWBcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJtdDVHZXRTZXR0aW5nc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtdDVHZXRTZXR0aW5ncygpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGxvZ2luOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIG10NV9nZXRfc2V0dGluZ3M6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAnbXQ1X2dldF9zZXR0aW5ncycsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MubXQ1X2xvZ2luX2xpc3QgLSBNdXN0IGJlIGAxYFxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIm10NUxvZ2luTGlzdFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtdDVMb2dpbkxpc3QoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBtdDVfbG9naW5fbGlzdDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdtdDVfbG9naW5fbGlzdCcsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuYWNjb3VudF90eXBlIC0gQWNjb3VudCB0eXBlLiBJZiBzZXQgdG8gJ2ZpbmFuY2lhbCcsIHNldHRpbmcgJ210NV9hY2NvdW50X3R5cGUnIGlzIGFsc28gcmVxdWlyZWQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmFkZHJlc3MgLSBbT3B0aW9uYWxdIFRoZSBhZGRyZXNzIG9mIHRoZSB1c2VyLiBUaGUgbWF4aW11bSBsZW5ndGggb2YgdGhpcyBhZGRyZXNzIGZpZWxkIGlzIDEyOCBjaGFyYWN0ZXJzLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5jaXR5IC0gW09wdGlvbmFsXSBVc2VyJ3MgY2l0eSBvZiByZXNpZGVuY2UuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmNvbXBhbnkgLSBbT3B0aW9uYWxdIE5hbWUgb2YgdGhlIGNsaWVudCdzIGNvbXBhbnkuIFRoZSBtYXhpbXVtIGxlbmd0aCBvZiB0aGUgY29tcGFueSBuYW1lIGlzIDY0IGNoYXJhY3RlcnMuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmNvdW50cnkgLSBbT3B0aW9uYWxdIDItbGV0dGVyIGNvdW50cnkgY29kZSAodmFsdWUgcmVjZWl2ZWQgZnJvbSBgcmVzaWRlbmNlX2xpc3RgIGNhbGwpLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5jdXJyZW5jeSAtIFtPcHRpb25hbF0gTVQ1IGFjY291bnQgY3VycmVuY3ksIHRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgdGhlIHF1YWxpZmllZCBhY2NvdW50IGN1cnJlbmN5LlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5kcnlfcnVuIC0gW09wdGlvbmFsXSBJZiBzZXQgdG8gMSwgb25seSB2YWxpZGF0aW9uIGlzIHBlcmZvcm1lZC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuZW1haWwgLSBFbWFpbCBhZGRyZXNzXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmludmVzdFBhc3N3b3JkIC0gW09wdGlvbmFsXSBUaGUgaW52ZXN0b3IgcGFzc3dvcmQgb2YgdGhlIGFjY291bnQuIEZvciB2YWxpZGF0aW9uIChBY2NlcHRzIGFueSBwcmludGFibGUgQVNDSUkgY2hhcmFjdGVyLiBNdXN0IGJlIHdpdGhpbiA4LTI1IGNoYXJhY3RlcnMsIGFuZCBpbmNsdWRlIG51bWJlcnMsIGxvd2VyY2FzZSBhbmQgdXBwZXJjYXNlIGxldHRlcnMuIE11c3Qgbm90IGJlIHRoZSBzYW1lIGFzIHRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcykuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmxldmVyYWdlIC0gQ2xpZW50IGxldmVyYWdlIChmcm9tIDEgdG8gMTAwMCkuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLm1haW5QYXNzd29yZCAtIFRoZSBtYXN0ZXIgcGFzc3dvcmQgb2YgdGhlIGFjY291bnQuIEZvciB2YWxpZGF0aW9uIChBY2NlcHRzIGFueSBwcmludGFibGUgQVNDSUkgY2hhcmFjdGVyLiBNdXN0IGJlIHdpdGhpbiA4LTI1IGNoYXJhY3RlcnMsIGFuZCBpbmNsdWRlIG51bWJlcnMsIGxvd2VyY2FzZSBhbmQgdXBwZXJjYXNlIGxldHRlcnMuIE11c3Qgbm90IGJlIHRoZSBzYW1lIGFzIHRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcykuIFRoaXMgZmllbGQgaXMgcmVxdWlyZWQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLm10NV9hY2NvdW50X2NhdGVnb3J5IC0gW09wdGlvbmFsXSBUbyBjaG9vc2Ugd2hldGhlciBhY2NvdW50IGlzIGNvbnZlbnRpb25hbCBvciBzd2FwX2ZyZWUuIFVuYXZhaWxhYmxlIGZvciBmaW5hbmNpYWxfc3RwIE1UNV9hY2NvdW50X3R5cGVcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MubXQ1X2FjY291bnRfdHlwZSAtIFtPcHRpb25hbF0gRmluYW5jaWFsOiBWYXJpYWJsZSBzcHJlYWRzLCBIaWdoIGxldmVyYWdlLiBGaW5hbmNpYWwgU1RQOiBWYXJpYWJsZSBzcHJlYWRzLCBNZWRpdW0gTGV2ZXJhZ2UsIG1vcmUgcHJvZHVjdHMuIElmICdhY2NvdW50X3R5cGUnIHNldCB0byAnZmluYW5jaWFsJywgc2V0dGluZyAnbXQ1X2FjY291bnRfdHlwZScgaXMgYWxzbyByZXF1aXJlZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MubXQ1X25ld19hY2NvdW50IC0gTXVzdCBiZSBgMWBcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MubmFtZSAtIENsaWVudCdzIG5hbWUuIFRoZSBtYXhpbXVtIGxlbmd0aCBoZXJlIGlzIDEwMSBjaGFyYWN0ZXJzLlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnBob25lIC0gW09wdGlvbmFsXSBVc2VyJ3MgcGhvbmUgbnVtYmVyLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5waG9uZVBhc3N3b3JkIC0gW09wdGlvbmFsXSBUaGUgdXNlcidzIHBob25lIHBhc3N3b3JkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnNlcnZlciAtIFtPcHRpb25hbF0gVHJhZGUgc2VydmVyLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5zdGF0ZSAtIFtPcHRpb25hbF0gVXNlcidzIHN0YXRlIChyZWdpb24pIG9mIHJlc2lkZW5jZS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuemlwQ29kZSAtIFtPcHRpb25hbF0gVXNlcidzIHppcCBjb2RlLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwibXQ1TmV3QWNjb3VudFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtdDVOZXdBY2NvdW50KCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgYWNjb3VudF90eXBlOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGFkZHJlc3M6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBjaXR5OiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgY29tcGFueToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGNvdW50cnk6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBjdXJyZW5jeToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGRyeV9ydW46IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgZW1haWw6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgaW52ZXN0UGFzc3dvcmQ6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBsZXZlcmFnZToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgbWFpblBhc3N3b3JkOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIG10NV9hY2NvdW50X2NhdGVnb3J5OiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgbXQ1X2FjY291bnRfdHlwZToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIG10NV9uZXdfYWNjb3VudDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgbmFtZToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICBwaG9uZToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBob25lUGFzc3dvcmQ6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgc2VydmVyOiB7fSxcXG4gICAgICAgIHN0YXRlOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgemlwQ29kZToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdtdDVfbmV3X2FjY291bnQnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmxvZ2luIC0gTVQ1IHVzZXIgbG9naW5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MubXQ1X3Bhc3N3b3JkX2NoYW5nZSAtIE11c3QgYmUgYDFgXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLm5ld19wYXNzd29yZCAtIE5ldyBwYXNzd29yZCBvZiB0aGUgYWNjb3VudC4gRm9yIHZhbGlkYXRpb24gKEFjY2VwdHMgYW55IHByaW50YWJsZSBBU0NJSSBjaGFyYWN0ZXIuIE11c3QgYmUgd2l0aGluIDgtMjUgY2hhcmFjdGVycywgYW5kIGluY2x1ZGUgbnVtYmVycywgbG93ZXJjYXNlIGFuZCB1cHBlcmNhc2UgbGV0dGVycy4gTXVzdCBub3QgYmUgdGhlIHNhbWUgYXMgdGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzKS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3Mub2xkX3Bhc3N3b3JkIC0gT2xkIHBhc3N3b3JkIGZvciB2YWxpZGF0aW9uIChub24tZW1wdHkgc3RyaW5nLCBhY2NlcHRzIGFueSBwcmludGFibGUgQVNDSUkgY2hhcmFjdGVyKVxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnBhc3N3b3JkX3R5cGUgLSBbT3B0aW9uYWxdIFR5cGUgb2YgdGhlIHBhc3N3b3JkIHRvIGNoYW5nZS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwibXQ1UGFzc3dvcmRDaGFuZ2VcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbXQ1UGFzc3dvcmRDaGFuZ2UoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBsb2dpbjoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBtdDVfcGFzc3dvcmRfY2hhbmdlOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBuZXdfcGFzc3dvcmQ6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgb2xkX3Bhc3N3b3JkOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHBhc3N3b3JkX3R5cGU6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ210NV9wYXNzd29yZF9jaGFuZ2UnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmxvZ2luIC0gTVQ1IHVzZXIgbG9naW5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MubXQ1X3Bhc3N3b3JkX2NoZWNrIC0gTXVzdCBiZSBgMWBcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5wYXNzd29yZCAtIFRoZSBwYXNzd29yZCBvZiB0aGUgYWNjb3VudC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MucGFzc3dvcmRfdHlwZSAtIFtPcHRpb25hbF0gVHlwZSBvZiB0aGUgcGFzc3dvcmQgdG8gY2hlY2suXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIm10NVBhc3N3b3JkQ2hlY2tcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbXQ1UGFzc3dvcmRDaGVjaygpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGxvZ2luOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIG10NV9wYXNzd29yZF9jaGVjazoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcGFzc3dvcmQ6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3dvcmRfdHlwZToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAnbXQ1X3Bhc3N3b3JkX2NoZWNrJyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5sb2dpbiAtIE1UNSB1c2VyIGxvZ2luXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLm10NV9wYXNzd29yZF9yZXNldCAtIE11c3QgYmUgYDFgXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLm5ld19wYXNzd29yZCAtIE5ldyBwYXNzd29yZCBvZiB0aGUgYWNjb3VudC4gRm9yIHZhbGlkYXRpb24gKEFjY2VwdHMgYW55IHByaW50YWJsZSBBU0NJSSBjaGFyYWN0ZXIuIE11c3QgYmUgd2l0aGluIDgtMjUgY2hhcmFjdGVycywgYW5kIGluY2x1ZGUgbnVtYmVycywgbG93ZXJjYXNlIGFuZCB1cHBlcmNhc2UgbGV0dGVycy4gTXVzdCBub3QgYmUgdGhlIHNhbWUgYXMgdGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzKS5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5wYXNzd29yZF90eXBlIC0gW09wdGlvbmFsXSBUeXBlIG9mIHRoZSBwYXNzd29yZCB0byByZXNldC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy52ZXJpZmljYXRpb25fY29kZSAtIEVtYWlsIHZlcmlmaWNhdGlvbiBjb2RlIChyZWNlaXZlZCBmcm9tIGEgYHZlcmlmeV9lbWFpbGAgY2FsbCwgd2hpY2ggbXVzdCBiZSBkb25lIGZpcnN0KVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwibXQ1UGFzc3dvcmRSZXNldFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtdDVQYXNzd29yZFJlc2V0KCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgbG9naW46IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgbXQ1X3Bhc3N3b3JkX3Jlc2V0OiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBuZXdfcGFzc3dvcmQ6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcGFzc3dvcmRfdHlwZToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICB2ZXJpZmljYXRpb25fY29kZToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAnbXQ1X3Bhc3N3b3JkX3Jlc2V0JyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5hbW91bnQgLSBBbW91bnQgdG8gd2l0aGRyYXcgKGluIHRoZSBjdXJyZW5jeSBvZiB0aGUgTVQ1IGFjY291bnQpOyBtaW4gPSAkMSBvciBhbiBlcXVpdmFsZW50IGFtb3VudCwgbWF4ID0gJDIwMDAwIG9yIGFuIGVxdWl2YWxlbnQgYW1vdW50LlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5mcm9tX210NSAtIE1UNSBhY2NvdW50IGxvZ2luIHRvIHdpdGhkcmF3IG1vbmV5IGZyb21cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MubXQ1X3dpdGhkcmF3YWwgLSBNdXN0IGJlIGAxYFxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MudG9fYmluYXJ5IC0gQmluYXJ5IGFjY291bnQgbG9naW5pZCB0byB0cmFuc2ZlciBtb25leSB0b1xcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwibXQ1V2l0aGRyYXdhbFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtdDVXaXRoZHJhd2FsKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgYW1vdW50OiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBmcm9tX210NToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBtdDVfd2l0aGRyYXdhbDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHRvX2JpbmFyeToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAnbXQ1X3dpdGhkcmF3YWwnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmFjY2VwdF9yaXNrIC0gU2hvdyB3aGV0aGVyIGNsaWVudCBoYXMgYWNjZXB0ZWQgcmlzayBkaXNjbGFpbWVyLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5hY2NvdW50X29wZW5pbmdfcmVhc29uIC0gW09wdGlvbmFsXSBQdXJwb3NlIGFuZCByZWFzb24gZm9yIHJlcXVlc3RpbmcgdGhlIGFjY291bnQgb3BlbmluZy5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuYWNjb3VudF90dXJub3ZlciAtIFtPcHRpb25hbF0gVGhlIGFudGljaXBhdGVkIGFjY291bnQgdHVybm92ZXIuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmFkZHJlc3NfY2l0eSAtIFdpdGhpbiAxMDAgY2hhcmFjdGVyc1xcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5hZGRyZXNzX2xpbmVfMSAtIFdpdGhpbiA3MCBjaGFyYWN0ZXJzLCB3aXRoIG5vIGxlYWRpbmcgd2hpdGVzcGFjZXMgYW5kIG1heSBjb250YWluIGxldHRlcnMvbnVtYmVycyBhbmQvb3IgYW55IG9mIGZvbGxvd2luZyBjaGFyYWN0ZXJzICcuLDo7KClAIy8tXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmFkZHJlc3NfbGluZV8yIC0gW09wdGlvbmFsXSBXaXRoaW4gNzAgY2hhcmFjdGVycy5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuYWRkcmVzc19wb3N0Y29kZSAtIFtPcHRpb25hbF0gV2l0aGluIDIwIGNoYXJhY3RlcnMgYW5kIG1heSBub3QgY29udGFpbiAnKycuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmFkZHJlc3Nfc3RhdGUgLSBbT3B0aW9uYWxdIFBvc3NpYmxlIHZhbHVlIHJlY2VpdmUgZnJvbSBgc3RhdGVzX2xpc3RgIGNhbGwuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmFmZmlsaWF0ZV90b2tlbiAtIFtPcHRpb25hbF0gQWZmaWxpYXRlIHRva2VuLCB3aXRoaW4gMzIgY2hhcmFjdGVycy5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuYmluYXJ5X29wdGlvbnNfdHJhZGluZ19leHBlcmllbmNlIC0gW09wdGlvbmFsXSBCaW5hcnkgb3B0aW9ucyB0cmFkaW5nIGV4cGVyaWVuY2UuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmJpbmFyeV9vcHRpb25zX3RyYWRpbmdfZnJlcXVlbmN5IC0gW09wdGlvbmFsXSBCaW5hcnkgb3B0aW9ucyB0cmFkaW5nIGZyZXF1ZW5jeS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuY2ZkX3RyYWRpbmdfZXhwZXJpZW5jZSAtIFtPcHRpb25hbF0gQ0ZEcyB0cmFkaW5nIGV4cGVyaWVuY2UuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmNmZF90cmFkaW5nX2ZyZXF1ZW5jeSAtIFtPcHRpb25hbF0gQ0ZEcyB0cmFkaW5nIGZyZXF1ZW5jeS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuY2l0aXplbiAtIFtPcHRpb25hbF0gQ291bnRyeSBvZiBsZWdhbCBjaXRpemVuc2hpcCwgMi1sZXR0ZXIgY291bnRyeSBjb2RlLiBQb3NzaWJsZSB2YWx1ZSByZWNlaXZlIGZyb20gYHJlc2lkZW5jZV9saXN0YCBjYWxsLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5jbGllbnRfdHlwZSAtIFtPcHRpb25hbF0gSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBmb3IgYSBjbGllbnQgcmVxdWVzdGluZyBhbiBhY2NvdW50IHdpdGggcHJvZmVzc2lvbmFsIHN0YXR1cy5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuZGF0ZV9vZl9iaXJ0aCAtIERhdGUgb2YgYmlydGggZm9ybWF0OiB5eXl5LW1tLWRkLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5lZHVjYXRpb25fbGV2ZWwgLSBMZXZlbCBvZiBFZHVjYXRpb25cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuZW1wbG95bWVudF9pbmR1c3RyeSAtIEluZHVzdHJ5IG9mIEVtcGxveW1lbnQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmVtcGxveW1lbnRfc3RhdHVzIC0gW09wdGlvbmFsXSBFbXBsb3ltZW50IFN0YXR1cy5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuZXN0aW1hdGVkX3dvcnRoIC0gRXN0aW1hdGVkIE5ldCBXb3J0aC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuZmlyc3RfbmFtZSAtIFdpdGhpbiAyLTUwIGNoYXJhY3RlcnMsIHVzZSBvbmx5IGxldHRlcnMsIHNwYWNlcywgaHlwaGVucywgZnVsbC1zdG9wcyBvciBhcG9zdHJvcGhlcy5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuZm9yZXhfdHJhZGluZ19leHBlcmllbmNlIC0gW09wdGlvbmFsXSBGb3JleCB0cmFkaW5nIGV4cGVyaWVuY2UuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmZvcmV4X3RyYWRpbmdfZnJlcXVlbmN5IC0gW09wdGlvbmFsXSBGb3JleCB0cmFkaW5nIGZyZXF1ZW5jeS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuaW5jb21lX3NvdXJjZSAtIEluY29tZSBTb3VyY2UuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmxhc3RfbmFtZSAtIFdpdGhpbiAyLTUwIGNoYXJhY3RlcnMsIHVzZSBvbmx5IGxldHRlcnMsIHNwYWNlcywgaHlwaGVucywgZnVsbC1zdG9wcyBvciBhcG9zdHJvcGhlcy5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MubmV0X2luY29tZSAtIE5ldCBBbm51YWwgSW5jb21lLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5uZXdfYWNjb3VudF9tYWx0YWludmVzdCAtIE11c3QgYmUgYDFgXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLm5vbl9wZXBfZGVjbGFyYXRpb24gLSBbT3B0aW9uYWxdIEluZGljYXRlcyBjbGllbnQncyBzZWxmLWRlY2xhcmF0aW9uIG9mIG5vdCBiZWluZyBhIFBFUC9SQ0EuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLm9jY3VwYXRpb24gLSBPY2N1cGF0aW9uLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5vdGhlcl9pbnN0cnVtZW50c190cmFkaW5nX2V4cGVyaWVuY2UgLSBbT3B0aW9uYWxdIFRyYWRpbmcgZXhwZXJpZW5jZSBpbiBvdGhlciBmaW5hbmNpYWwgaW5zdHJ1bWVudHMuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLm90aGVyX2luc3RydW1lbnRzX3RyYWRpbmdfZnJlcXVlbmN5IC0gW09wdGlvbmFsXSBUcmFkaW5nIGZyZXF1ZW5jeSBpbiBvdGhlciBmaW5hbmNpYWwgaW5zdHJ1bWVudHMuXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGhvbmUgLSBbT3B0aW9uYWxdIFN0YXJ0aW5nIHdpdGggYCtgIGZvbGxvd2VkIGJ5IDktMzUgZGlnaXRzLCBoeXBoZW5zIG9yIHNwYWNlLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5wbGFjZV9vZl9iaXJ0aCAtIFtPcHRpb25hbF0gUGxhY2Ugb2YgYmlydGgsIDItbGV0dGVyIGNvdW50cnkgY29kZS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5yZXNpZGVuY2UgLSAyLWxldHRlciBjb3VudHJ5IGNvZGUsIHBvc3NpYmxlIHZhbHVlIHJlY2VpdmUgZnJvbSBgcmVzaWRlbmNlX2xpc3RgIGNhbGwuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnNhbHV0YXRpb24gLSBBY2NlcHQgYW55IHZhbHVlIGluIGVudW0gbGlzdC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3Muc2VjcmV0X2Fuc3dlciAtIFtPcHRpb25hbF0gQW5zd2VyIHRvIHNlY3JldCBxdWVzdGlvbiwgd2l0aGluIDQtNTAgY2hhcmFjdGVycy5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3Muc2VjcmV0X3F1ZXN0aW9uIC0gW09wdGlvbmFsXSBBY2NlcHQgYW55IHZhbHVlIGluIGVudW0gbGlzdC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3Muc291cmNlX29mX3dlYWx0aCAtIFtPcHRpb25hbF0gU291cmNlIG9mIHdlYWx0aC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MudGF4X2lkZW50aWZpY2F0aW9uX251bWJlciAtIFRheCBpZGVudGlmaWNhdGlvbiBudW1iZXIuIE9ubHkgYXBwbGljYWJsZSBmb3IgcmVhbCBtb25leSBhY2NvdW50LiBSZXF1aXJlZCBmb3IgYG1hbHRhaW52ZXN0YCBsYW5kaW5nIGNvbXBhbnkuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnRheF9yZXNpZGVuY2UgLSBSZXNpZGVuY2UgZm9yIHRheCBwdXJwb3NlLiBDb21tYSBzZXBhcmF0ZWQgaXNvIGNvdW50cnkgY29kZSBpZiBtdWx0aXBsZSBqdXJpc2RpY3Rpb25zLiBPbmx5IGFwcGxpY2FibGUgZm9yIHJlYWwgbW9uZXkgYWNjb3VudC4gUmVxdWlyZWQgZm9yIGBtYWx0YWludmVzdGAgbGFuZGluZyBjb21wYW55LlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwibmV3QWNjb3VudE1hbHRhaW52ZXN0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5ld0FjY291bnRNYWx0YWludmVzdCgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGFjY2VwdF9yaXNrOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBhY2NvdW50X29wZW5pbmdfcmVhc29uOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgYWNjb3VudF90dXJub3Zlcjoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGFkZHJlc3NfY2l0eToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBhZGRyZXNzX2xpbmVfMToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBhZGRyZXNzX2xpbmVfMjoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGFkZHJlc3NfcG9zdGNvZGU6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBhZGRyZXNzX3N0YXRlOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgYWZmaWxpYXRlX3Rva2VuOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgYmluYXJ5X29wdGlvbnNfdHJhZGluZ19leHBlcmllbmNlOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgYmluYXJ5X29wdGlvbnNfdHJhZGluZ19mcmVxdWVuY3k6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBjZmRfdHJhZGluZ19leHBlcmllbmNlOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgY2ZkX3RyYWRpbmdfZnJlcXVlbmN5OiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgY2l0aXplbjoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGNsaWVudF90eXBlOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgZGF0ZV9vZl9iaXJ0aDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBlZHVjYXRpb25fbGV2ZWw6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgZW1wbG95bWVudF9pbmR1c3RyeToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBlbXBsb3ltZW50X3N0YXR1czoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGVzdGltYXRlZF93b3J0aDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBmaXJzdF9uYW1lOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGZvcmV4X3RyYWRpbmdfZXhwZXJpZW5jZToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGZvcmV4X3RyYWRpbmdfZnJlcXVlbmN5OiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgaW5jb21lX3NvdXJjZToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBsYXN0X25hbWU6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgbmV0X2luY29tZToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBuZXdfYWNjb3VudF9tYWx0YWludmVzdDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgbm9uX3BlcF9kZWNsYXJhdGlvbjoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBvY2N1cGF0aW9uOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIG90aGVyX2luc3RydW1lbnRzX3RyYWRpbmdfZXhwZXJpZW5jZToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIG90aGVyX2luc3RydW1lbnRzX3RyYWRpbmdfZnJlcXVlbmN5OiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcGhvbmU6IHt9LFxcbiAgICAgICAgcGxhY2Vfb2ZfYmlydGg6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcmVzaWRlbmNlOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHNhbHV0YXRpb246IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgc2VjcmV0X2Fuc3dlcjoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHNlY3JldF9xdWVzdGlvbjoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHNvdXJjZV9vZl93ZWFsdGg6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICB0YXhfaWRlbnRpZmljYXRpb25fbnVtYmVyOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHRheF9yZXNpZGVuY2U6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ25ld19hY2NvdW50X21hbHRhaW52ZXN0JyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5hY2NvdW50X29wZW5pbmdfcmVhc29uIC0gW09wdGlvbmFsXSBQdXJwb3NlIGFuZCByZWFzb24gZm9yIHJlcXVlc3RpbmcgdGhlIGFjY291bnQgb3BlbmluZy5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuYWNjb3VudF90dXJub3ZlciAtIFtPcHRpb25hbF0gVGhlIGFudGljaXBhdGVkIGFjY291bnQgdHVybm92ZXIuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmFkZHJlc3NfY2l0eSAtIFtPcHRpb25hbF0gV2l0aGluIDEwMCBjaGFyYWN0ZXJzLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5hZGRyZXNzX2xpbmVfMSAtIFdpdGhpbiA3MCBjaGFyYWN0ZXJzLCB3aXRoIG5vIGxlYWRpbmcgd2hpdGVzcGFjZXMgYW5kIG1heSBjb250YWluIGxldHRlcnMvbnVtYmVycyBhbmQvb3IgYW55IG9mIGZvbGxvd2luZyBjaGFyYWN0ZXJzICcuLDo7KClAIy8tXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmFkZHJlc3NfbGluZV8yIC0gW09wdGlvbmFsXSBXaXRoaW4gNzAgY2hhcmFjdGVycy5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuYWRkcmVzc19wb3N0Y29kZSAtIFtPcHRpb25hbF0gV2l0aGluIDIwIGNoYXJhY3RlcnMgYW5kIG1heSBub3QgY29udGFpbiAnKycuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmFkZHJlc3Nfc3RhdGUgLSBbT3B0aW9uYWxdIFBvc3NpYmxlIHZhbHVlIHJlY2VpdmUgZnJvbSBgc3RhdGVzX2xpc3RgIGNhbGwuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmFmZmlsaWF0ZV90b2tlbiAtIFtPcHRpb25hbF0gQWZmaWxpYXRlIHRva2VuLCB3aXRoaW4gMzIgY2hhcmFjdGVycy5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MuY2l0aXplbiAtIFtPcHRpb25hbF0gQ291bnRyeSBvZiBsZWdhbCBjaXRpemVuc2hpcCwgMi1sZXR0ZXIgY291bnRyeSBjb2RlLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5jbGllbnRfdHlwZSAtIFtPcHRpb25hbF0gSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBmb3IgYSBjbGllbnQgcmVxdWVzdGluZyBhbiBhY2NvdW50IHdpdGggcHJvZmVzc2lvbmFsIHN0YXR1cy5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuY3VycmVuY3kgLSBbT3B0aW9uYWxdIFRvIHNldCBjdXJyZW5jeSBvZiB0aGUgYWNjb3VudC4gTGlzdCBvZiBzdXBwb3J0ZWQgY3VycmVuY2llcyBjYW4gYmUgYWNxdWlyZWQgd2l0aCBgcGF5b3V0X2N1cnJlbmNpZXNgIGNhbGwuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmRhdGVfb2ZfYmlydGggLSBEYXRlIG9mIGJpcnRoIGZvcm1hdDogYHl5eXktbW0tZGRgLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5maXJzdF9uYW1lIC0gV2l0aGluIDItNTAgY2hhcmFjdGVycywgdXNlIG9ubHkgbGV0dGVycywgc3BhY2VzLCBoeXBoZW5zLCBmdWxsLXN0b3BzIG9yIGFwb3N0cm9waGVzLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5sYXN0X25hbWUgLSBXaXRoaW4gMi01MCBjaGFyYWN0ZXJzLCB1c2Ugb25seSBsZXR0ZXJzLCBzcGFjZXMsIGh5cGhlbnMsIGZ1bGwtc3RvcHMgb3IgYXBvc3Ryb3BoZXMuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLm5ld19hY2NvdW50X3JlYWwgLSBNdXN0IGJlIGAxYFxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5ub25fcGVwX2RlY2xhcmF0aW9uIC0gW09wdGlvbmFsXSBJbmRpY2F0ZXMgY2xpZW50J3Mgc2VsZi1kZWNsYXJhdGlvbiBvZiBub3QgYmVpbmcgYSBQRVAvUkNBIChQb2xpdGljYWxseSBFeHBvc2VkIFBlcnNvbi9SZWxhdGl2ZXMgYW5kIENsb3NlIEFzc29jaWF0ZXMpLlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBob25lIC0gW09wdGlvbmFsXSBTdGFydGluZyB3aXRoIGArYCBmb2xsb3dlZCBieSA5LTM1IGRpZ2l0cywgaHlwaGVucyBvciBzcGFjZS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MucGxhY2Vfb2ZfYmlydGggLSBbT3B0aW9uYWxdIFBsYWNlIG9mIGJpcnRoLCAyLWxldHRlciBjb3VudHJ5IGNvZGUuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MucmVzaWRlbmNlIC0gMi1sZXR0ZXIgY291bnRyeSBjb2RlLCBwb3NzaWJsZSB2YWx1ZSByZWNlaXZlIGZyb20gYHJlc2lkZW5jZV9saXN0YCBjYWxsLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5zYWx1dGF0aW9uIC0gW09wdGlvbmFsXSBBY2NlcHQgYW55IHZhbHVlIGluIGVudW0gbGlzdC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3Muc2VjcmV0X2Fuc3dlciAtIFtPcHRpb25hbF0gQW5zd2VyIHRvIHNlY3JldCBxdWVzdGlvbiwgd2l0aGluIDQtNTAgY2hhcmFjdGVycy4gUmVxdWlyZWQgZm9yIG5ldyBhY2NvdW50IGFuZCBleGlzdGluZyBjbGllbnQgZGV0YWlscyB3aWxsIGJlIHVzZWQgaWYgY2xpZW50IG9wZW4gYW5vdGhlciBhY2NvdW50LlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5zZWNyZXRfcXVlc3Rpb24gLSBbT3B0aW9uYWxdIEFjY2VwdCBhbnkgdmFsdWUgaW4gZW51bSBsaXN0LiBSZXF1aXJlZCBmb3IgbmV3IGFjY291bnQgYW5kIGV4aXN0aW5nIGNsaWVudCBkZXRhaWxzIHdpbGwgYmUgdXNlZCBpZiBjbGllbnQgb3BlbiBhbm90aGVyIGFjY291bnQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnRheF9pZGVudGlmaWNhdGlvbl9udW1iZXIgLSBbT3B0aW9uYWxdIFRheCBpZGVudGlmaWNhdGlvbiBudW1iZXIuIE9ubHkgYXBwbGljYWJsZSBmb3IgcmVhbCBtb25leSBhY2NvdW50LiBSZXF1aXJlZCBmb3IgYG1hbHRhaW52ZXN0YCBsYW5kaW5nIGNvbXBhbnkuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnRheF9yZXNpZGVuY2UgLSBbT3B0aW9uYWxdIFJlc2lkZW5jZSBmb3IgdGF4IHB1cnBvc2UuIENvbW1hIHNlcGFyYXRlZCBpc28gY291bnRyeSBjb2RlIGlmIG11bHRpcGxlIGp1cmlzZGljdGlvbnMuIE9ubHkgYXBwbGljYWJsZSBmb3IgcmVhbCBtb25leSBhY2NvdW50LiBSZXF1aXJlZCBmb3IgYG1hbHRhaW52ZXN0YCBsYW5kaW5nIGNvbXBhbnkuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJuZXdBY2NvdW50UmVhbFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXdBY2NvdW50UmVhbCgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGFjY291bnRfb3BlbmluZ19yZWFzb246IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBhY2NvdW50X3R1cm5vdmVyOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgYWRkcmVzc19jaXR5OiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgYWRkcmVzc19saW5lXzE6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBhZGRyZXNzX2xpbmVfMjoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGFkZHJlc3NfcG9zdGNvZGU6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBhZGRyZXNzX3N0YXRlOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgYWZmaWxpYXRlX3Rva2VuOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgY2l0aXplbjoge30sXFxuICAgICAgICBjbGllbnRfdHlwZToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGN1cnJlbmN5OiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgZGF0ZV9vZl9iaXJ0aDoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGZpcnN0X25hbWU6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBsYXN0X25hbWU6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBuZXdfYWNjb3VudF9yZWFsOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBub25fcGVwX2RlY2xhcmF0aW9uOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHBob25lOiB7fSxcXG4gICAgICAgIHBsYWNlX29mX2JpcnRoOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlc2lkZW5jZToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHNhbHV0YXRpb246IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBzZWNyZXRfYW5zd2VyOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgc2VjcmV0X3F1ZXN0aW9uOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgdGF4X2lkZW50aWZpY2F0aW9uX251bWJlcjoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHRheF9yZXNpZGVuY2U6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAnbmV3X2FjY291bnRfcmVhbCcsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuYWZmaWxpYXRlX3Rva2VuIC0gW09wdGlvbmFsXSBBZmZpbGlhdGUgdG9rZW4sIHdpdGhpbiAzMiBjaGFyYWN0ZXJzLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5jbGllbnRfcGFzc3dvcmQgLSBQYXNzd29yZCAoQWNjZXB0cyBhbnkgcHJpbnRhYmxlIEFTQ0lJIGNoYXJhY3Rlci4gTXVzdCBiZSB3aXRoaW4gOC0yNSBjaGFyYWN0ZXJzLCBhbmQgaW5jbHVkZSBudW1iZXJzLCBsb3dlcmNhc2UgYW5kIHVwcGVyY2FzZSBsZXR0ZXJzLiBNdXN0IG5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgdXNlcidzIGVtYWlsIGFkZHJlc3MpLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5kYXRlX2ZpcnN0X2NvbnRhY3QgLSBbT3B0aW9uYWxdIERhdGUgb2YgZmlyc3QgY29udGFjdCwgZm9ybWF0OiBgeXl5eS1tbS1kZGAgaW4gR01UIHRpbWV6b25lLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5lbWFpbF9jb25zZW50IC0gW09wdGlvbmFsXSBCb29sZWFuIHZhbHVlOiAxIG9yIDAsIGluZGljYXRpbmcgd2hldGhlciB0aGUgY2xpZW50IGhhcyBnaXZlbiBjb25zZW50IGZvciBtYXJrZXRpbmcgZW1haWxzLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5nY2xpZF91cmwgLSBbT3B0aW9uYWxdIEdvb2dsZSBDbGljayBJZGVudGlmaWVyIHRvIHRyYWNrIHNvdXJjZS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MubmV3X2FjY291bnRfdmlydHVhbCAtIE11c3QgYmUgYDFgXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5yZXNpZGVuY2UgLSAyLWxldHRlciBjb3VudHJ5IGNvZGUgKG9idGFpbmVkIGZyb20gYHJlc2lkZW5jZV9saXN0YCBjYWxsKS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3Muc2lnbnVwX2RldmljZSAtIFtPcHRpb25hbF0gU2hvdyB3aGV0aGVyIHVzZXIgaGFzIHVzZWQgbW9iaWxlIG9yIGRlc2t0b3AuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnR5cGUgLSBBY2NvdW50IHR5cGVcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MudXRtX2FkX2lkIC0gW09wdGlvbmFsXSBJZGVudGlmaWVyIG9mIHBhcnRpY3VsYXIgYWQuIFZhbHVlIG11c3QgbWF0Y2ggUmVnZXggcGF0dGVybiB0byBiZSByZWNvcmRlZFxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy51dG1fYWRncm91cF9pZCAtIFtPcHRpb25hbF0gSWRlbnRpZmllciBvZiBhZCBncm91cCBpbiB0aGUgY2FtcGFpZ24uIFZhbHVlIG11c3QgbWF0Y2ggUmVnZXggcGF0dGVybiB0byBiZSByZWNvcmRlZFxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy51dG1fYWRyb2xsY2xrX2lkIC0gW09wdGlvbmFsXSBVbmlxdWUgaWRlbnRpZmllciBvZiBjbGljayBvbiBBZFJvbGwgYWRzIHBsYXRmb3JtLiBWYWx1ZSBtdXN0IG1hdGNoIFJlZ2V4IHBhdHRlcm4gdG8gYmUgcmVjb3JkZWRcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MudXRtX2NhbXBhaWduIC0gW09wdGlvbmFsXSBJZGVudGlmaWVzIGEgc3BlY2lmaWMgcHJvZHVjdCBwcm9tb3Rpb24gb3Igc3RyYXRlZ2ljIGNhbXBhaWduIHN1Y2ggYXMgYSBzcHJpbmcgc2FsZSBvciBvdGhlciBwcm9tb3Rpb25zLiBWYWx1ZSBtdXN0IG1hdGNoIFJlZ2V4IHBhdHRlcm4gdG8gYmUgcmVjb3JkZWRcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MudXRtX2NhbXBhaWduX2lkIC0gW09wdGlvbmFsXSBJZGVudGlmaWVyIG9mIHBhaWQgYWQgY2FtcGFpZ24uIFZhbHVlIG11c3QgbWF0Y2ggUmVnZXggcGF0dGVybiB0byBiZSByZWNvcmRlZFxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy51dG1fY29udGVudCAtIFtPcHRpb25hbF0gVXNlZCB0byBkaWZmZXJlbnRpYXRlIHNpbWlsYXIgY29udGVudCwgb3IgbGlua3Mgd2l0aGluIHRoZSBzYW1lIGFkLiBWYWx1ZSBtdXN0IG1hdGNoIFJlZ2V4IHBhdHRlcm4gdG8gYmUgcmVjb3JkZWRcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MudXRtX2ZiY2xfaWQgLSBbT3B0aW9uYWxdIFVuaXF1ZSBpZGVudGlmaWVyIG9mIGNsaWNrIG9uIEZhY2Vib29rIGFkcyBwbGF0Zm9ybS4gVmFsdWUgbXVzdCBtYXRjaCBSZWdleCBwYXR0ZXJuIHRvIGJlIHJlY29yZGVkXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnV0bV9nbF9jbGllbnRfaWQgLSBbT3B0aW9uYWxdIFVuaXF1ZSB2aXNpdG9yIGlkZW50aWZpZXIgb24gR29vZ2xlIEFkcyBwbGF0Zm9ybS4gVmFsdWUgbXVzdCBtYXRjaCBSZWdleCBwYXR0ZXJuIHRvIGJlIHJlY29yZGVkXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnV0bV9tZWRpdW0gLSBbT3B0aW9uYWxdIElkZW50aWZpZXMgdGhlIG1lZGl1bSB0aGUgbGluayB3YXMgdXNlZCB1cG9uIHN1Y2ggYXM6IGVtYWlsLCBDUEMsIG9yIG90aGVyIG1ldGhvZHMgb2Ygc2hhcmluZy4gVmFsdWUgbXVzdCBtYXRjaCBSZWdleCBwYXR0ZXJuIHRvIGJlIHJlY29yZGVkXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnV0bV9tc2Nsa19pZCAtIFtPcHRpb25hbF0gVW5pcXVlIGNsaWNrIGlkZW50aWZpZXIgb24gTWljcm9zb2Z0IEJpbmcgYWRzIHBsYXRmb3JtLiBWYWx1ZSBtdXN0IG1hdGNoIFJlZ2V4IHBhdHRlcm4gdG8gYmUgcmVjb3JkZWRcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MudXRtX3NvdXJjZSAtIFtPcHRpb25hbF0gSWRlbnRpZmllcyB0aGUgc291cmNlIG9mIHRyYWZmaWMgc3VjaCBhczogc2VhcmNoIGVuZ2luZSwgbmV3c2xldHRlciwgb3Igb3RoZXIgcmVmZXJyYWwuIFZhbHVlIG11c3QgbWF0Y2ggUmVnZXggcGF0dGVybiB0byBiZSByZWNvcmRlZFxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy51dG1fdGVybSAtIFtPcHRpb25hbF0gVXNlZCB0byBzZW5kIGluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gdGhlIGNhbXBhaWduIHRlcm0gbGlrZSBwYWlkIHNlYXJjaCBrZXl3b3Jkcy4gVmFsdWUgbXVzdCBtYXRjaCBSZWdleCBwYXR0ZXJuIHRvIGJlIHJlY29yZGVkXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnZlcmlmaWNhdGlvbl9jb2RlIC0gRW1haWwgdmVyaWZpY2F0aW9uIGNvZGUgKHJlY2VpdmVkIGZyb20gYSBgdmVyaWZ5X2VtYWlsYCBjYWxsLCB3aGljaCBtdXN0IGJlIGRvbmUgZmlyc3QpLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwibmV3QWNjb3VudFZpcnR1YWxcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV3QWNjb3VudFZpcnR1YWwoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBhZmZpbGlhdGVfdG9rZW46IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBjbGllbnRfcGFzc3dvcmQ6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBkYXRlX2ZpcnN0X2NvbnRhY3Q6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBlbWFpbF9jb25zZW50OiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGdjbGlkX3VybDoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIG5ld19hY2NvdW50X3ZpcnR1YWw6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICByZXNpZGVuY2U6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBzaWdudXBfZGV2aWNlOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgdHlwZToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHV0bV9hZF9pZDoge30sXFxuICAgICAgICB1dG1fYWRncm91cF9pZDoge30sXFxuICAgICAgICB1dG1fYWRyb2xsY2xrX2lkOiB7fSxcXG4gICAgICAgIHV0bV9jYW1wYWlnbjoge30sXFxuICAgICAgICB1dG1fY2FtcGFpZ25faWQ6IHt9LFxcbiAgICAgICAgdXRtX2NvbnRlbnQ6IHt9LFxcbiAgICAgICAgdXRtX2ZiY2xfaWQ6IHt9LFxcbiAgICAgICAgdXRtX2dsX2NsaWVudF9pZDoge30sXFxuICAgICAgICB1dG1fbWVkaXVtOiB7fSxcXG4gICAgICAgIHV0bV9tc2Nsa19pZDoge30sXFxuICAgICAgICB1dG1fc291cmNlOiB7fSxcXG4gICAgICAgIHV0bV90ZXJtOiB7fSxcXG4gICAgICAgIHZlcmlmaWNhdGlvbl9jb2RlOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ25ld19hY2NvdW50X3ZpcnR1YWwnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmFkZHJlc3NfY2l0eSAtIFtPcHRpb25hbF0gV2l0aGluIDM1IGNoYXJhY3RlcnMuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmFkZHJlc3NfbGluZV8xIC0gW09wdGlvbmFsXSBNYWlsaW5nIGFkZHJlc3MuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmFkZHJlc3NfbGluZV8yIC0gW09wdGlvbmFsXSBXaXRoaW4gNzAgY2hhcmFjdGVycy5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuYWRkcmVzc19wb3N0Y29kZSAtIFtPcHRpb25hbF0gV2l0aGluIDIwIGNoYXJhY3RlcnMgYW5kIG1heSBub3QgY29udGFpbiAnKycuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmFkZHJlc3Nfc3RhdGUgLSBbT3B0aW9uYWxdIFBvc3NpYmxlIHZhbHVlIHJlY2VpdmUgZnJvbSBgc3RhdGVzX2xpc3RgIGNhbGwuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmN1cnJlbmN5IC0gW09wdGlvbmFsXSBUbyBzZXQgY3VycmVuY3kgb2YgdGhlIGFjY291bnQuIExpc3Qgb2Ygc3VwcG9ydGVkIGN1cnJlbmNpZXMgY2FuIGJlIGFjcXVpcmVkIHdpdGggYHBheW91dF9jdXJyZW5jaWVzYCBjYWxsLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5kYXRlX29mX2JpcnRoIC0gW09wdGlvbmFsXSBEYXRlIG9mIGJpcnRoIGZvcm1hdDogYHl5eXktbW0tZGRgLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5maXJzdF9uYW1lIC0gW09wdGlvbmFsXSBXaXRoaW4gMi01MCBjaGFyYWN0ZXJzLCB1c2Ugb25seSBsZXR0ZXJzLCBzcGFjZXMsIGh5cGhlbnMsIGZ1bGwtc3RvcHMgb3IgYXBvc3Ryb3BoZXMuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmxhc3RfbmFtZSAtIFtPcHRpb25hbF0gV2l0aGluIDItNTAgY2hhcmFjdGVycywgdXNlIG9ubHkgbGV0dGVycywgc3BhY2VzLCBoeXBoZW5zLCBmdWxsLXN0b3BzIG9yIGFwb3N0cm9waGVzLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5uZXdfYWNjb3VudF93YWxsZXQgLSBNdXN0IGJlIGAxYFxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5ub25fcGVwX2RlY2xhcmF0aW9uIC0gW09wdGlvbmFsXSBJbmRpY2F0ZXMgY2xpZW50J3Mgc2VsZi1kZWNsYXJhdGlvbiBvZiBub3QgYmVpbmcgYSBQRVAvUkNBIChQb2xpdGljYWxseSBFeHBvc2VkIFBlcnNvbi9SZWxhdGl2ZXMgYW5kIENsb3NlIEFzc29jaWF0ZXMpLlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnBheW1lbnRfbWV0aG9kIC0gVG8gc2V0IG1ldGhvZCB3aGljaCBpcyB1c2VkIHRvIHRyYW5zZmVyIHRvL2Zyb20gd2FsbGV0LlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5waG9uZSAtIFtPcHRpb25hbF0gU3RhcnRpbmcgd2l0aCBgK2AgZm9sbG93ZWQgYnkgOC0zNSBkaWdpdHMsIGFsbG93aW5nIGh5cGhlbnMgb3Igc3BhY2UuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIm5ld0FjY291bnRXYWxsZXRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV3QWNjb3VudFdhbGxldCgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGFkZHJlc3NfY2l0eToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGFkZHJlc3NfbGluZV8xOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgYWRkcmVzc19saW5lXzI6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBhZGRyZXNzX3Bvc3Rjb2RlOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgYWRkcmVzc19zdGF0ZToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGN1cnJlbmN5OiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGRhdGVfb2ZfYmlydGg6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBmaXJzdF9uYW1lOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgbGFzdF9uYW1lOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgbmV3X2FjY291bnRfd2FsbGV0OiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBub25fcGVwX2RlY2xhcmF0aW9uOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHBheW1lbnRfbWV0aG9kOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBob25lOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICduZXdfYWNjb3VudF93YWxsZXQnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLmFyZ3MgLVxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5jYXRlZ29yeSAtIFRoZSBjYXRlZ29yeSBvciBuYXR1cmUgb2YgdGhlIGV2ZW50LlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5ldmVudCAtIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3Mubm90aWZpY2F0aW9uX2V2ZW50IC0gTXVzdCBiZSBgMWBcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJub3RpZmljYXRpb25FdmVudFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3RpZmljYXRpb25FdmVudCgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGFyZ3M6IHtcXG4gICAgICAgICAgZG9jdW1lbnRzOiB7fVxcbiAgICAgICAgfSxcXG4gICAgICAgIGNhdGVnb3J5OiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGV2ZW50OiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIG5vdGlmaWNhdGlvbl9ldmVudDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdub3RpZmljYXRpb25fZXZlbnQnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLm9hdXRoX2FwcHMgLSBNdXN0IGJlIGAxYFxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIm9hdXRoQXBwc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvYXV0aEFwcHMoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBvYXV0aF9hcHBzOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ29hdXRoX2FwcHMnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmFtb3VudCAtIFRoZSB0b3RhbCBhbW91bnQgb2YgdGhlIGFkdmVydCwgaW4gYWR2ZXJ0aXNlcidzIGFjY291bnQgY3VycmVuY3kuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmNvbnRhY3RfaW5mbyAtIFtPcHRpb25hbF0gQWR2ZXJ0aXNlciBjb250YWN0IGluZm9ybWF0aW9uLiBPbmx5IGFwcGxpY2FibGUgZm9yICdzZWxsIGFkdmVydHMnLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5kZXNjcmlwdGlvbiAtIFtPcHRpb25hbF0gR2VuZXJhbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYWR2ZXJ0LlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5sb2NhbF9jdXJyZW5jeSAtIFtPcHRpb25hbF0gTG9jYWwgY3VycmVuY3kgZm9yIHRoaXMgYWR2ZXJ0LiBJZiBub3QgcHJvdmlkZWQsIHdpbGwgdXNlIHRoZSBjdXJyZW5jeSBvZiBjbGllbnQncyByZXNpZGVuY2UgYnkgZGVmYXVsdC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MubWF4X29yZGVyX2Ftb3VudCAtIE1heGltdW0gYWxsb3dlZCBhbW91bnQgZm9yIHRoZSBvcmRlcnMgb2YgdGhpcyBhZHZlcnQsIGluIGFkdmVydGlzZXIncyBgYWNjb3VudF9jdXJyZW5jeWAuIFNob3VsZCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdG90YWwgYGFtb3VudGAgb2YgdGhlIGFkdmVydC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MubWluX29yZGVyX2Ftb3VudCAtIE1pbmltdW0gYWxsb3dlZCBhbW91bnQgZm9yIHRoZSBvcmRlcnMgb2YgdGhpcyBhZHZlcnQsIGluIGFkdmVydGlzZXIncyBgYWNjb3VudF9jdXJyZW5jeWAuIFNob3VsZCBiZSBsZXNzIHRoYW4gYG1heF9vcmRlcl9hbW91bnRgLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5wMnBfYWR2ZXJ0X2NyZWF0ZSAtIE11c3QgYmUgMVxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnBheW1lbnRfaW5mbyAtIFtPcHRpb25hbF0gUGF5bWVudCBpbnN0cnVjdGlvbnMuIE9ubHkgYXBwbGljYWJsZSBmb3IgJ3NlbGwgYWR2ZXJ0cycuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnBheW1lbnRfbWV0aG9kIC0gU3VwcG9ydGVkIHBheW1lbnQgbWV0aG9kcy4gU2VwYXJhdGUgbXVsdGlwbGUgdmFsdWVzIHdpdGggYSBjb21tYSwgbWF4aW11bSAzLlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXltZW50X21ldGhvZF9pZHMgLSBJRHMgb2YgcGF5bWVudCBtZXRob2RzLCBvbmx5IGFwcGxpY2FibGUgZm9yIHNlbGwgYWRzLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yYXRlIC0gQ29udmVyc2lvbiByYXRlIGZyb20gYWR2ZXJ0aXNlcidzIGFjY291bnQgY3VycmVuY3kgdG8gYGxvY2FsX2N1cnJlbmN5YC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy50eXBlIC0gV2hldGhlciB0aGlzIGlzIGEgYnV5IG9yIGEgc2VsbC5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInAycEFkdmVydENyZWF0ZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwMnBBZHZlcnRDcmVhdGUoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBhbW91bnQ6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGNvbnRhY3RfaW5mbzoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGRlc2NyaXB0aW9uOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgbG9jYWxfY3VycmVuY3k6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBtYXhfb3JkZXJfYW1vdW50OiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBtaW5fb3JkZXJfYW1vdW50OiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBwMnBfYWR2ZXJ0X2NyZWF0ZToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcGF5bWVudF9pbmZvOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGF5bWVudF9tZXRob2Q6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXltZW50X21ldGhvZF9pZHM6IHt9LFxcbiAgICAgICAgcmF0ZToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHR5cGU6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ3AycF9hZHZlcnRfY3JlYXRlJyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5pZCAtIFtPcHRpb25hbF0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGFkdmVydC4gT3B0aW9uYWwgd2hlbiBzdWJzY3JpYmUgaXMgMS4gSWYgbm90IHByb3ZpZGVkLCBhbGwgYWR2ZXJ0aXNlciBhZHZlcnRzIHdpbGwgYmUgc3Vic2NyaWJlZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucDJwX2FkdmVydF9pbmZvIC0gTXVzdCBiZSAxXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5zdWJzY3JpYmUgLSBbT3B0aW9uYWxdIElmIHNldCB0byAxLCB3aWxsIHNlbmQgdXBkYXRlcyB3aGVuIGNoYW5nZXMgb2NjdXIuIE9wdGlvbmFsIHdoZW4gaWQgaXMgcHJvdmlkZWQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnVzZV9jbGllbnRfbGltaXRzIC0gW09wdGlvbmFsXSBJZiBzZXQgdG8gMSwgdGhlIG1heGltdW0gb3JkZXIgYW1vdW50IHdpbGwgYmUgYWRqdXN0ZWQgdG8gdGhlIGN1cnJlbnQgYmFsYW5jZSBhbmQgdHVybm92ZXIgbGltaXRzIG9mIHRoZSBhY2NvdW50LlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicDJwQWR2ZXJ0SW5mb1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwMnBBZHZlcnRJbmZvKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBwMnBfYWR2ZXJ0X2luZm86IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBzdWJzY3JpYmU6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgdXNlX2NsaWVudF9saW1pdHM6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ3AycF9hZHZlcnRfaW5mbycsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuYWR2ZXJ0aXNlcl9pZCAtIFtPcHRpb25hbF0gSUQgb2YgdGhlIGFkdmVydGlzZXIgdG8gbGlzdCBhZHZlcnRzIGZvci5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuYWR2ZXJ0aXNlcl9uYW1lIC0gW09wdGlvbmFsXSBTZWFyY2ggZm9yIGFkdmVydGlzZXIgYnkgbmFtZS4gUGFydGlhbCBtYXRjaGVzIHdpbGwgYmUgcmV0dXJuZWQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmFtb3VudCAtIFtPcHRpb25hbF0gSG93IG11Y2ggdG8gYnV5IG9yIHNlbGwsIHVzZWQgdG8gY2FsY3VsYXRlIHByaWNlcy5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuY291bnRlcnBhcnR5X3R5cGUgLSBbT3B0aW9uYWxdIEZpbHRlciB0aGUgYWR2ZXJ0cyBieSBgY291bnRlcnBhcnR5X3R5cGVgLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5mYXZvdXJpdGVzX29ubHkgLSBbT3B0aW9uYWxdIE9ubHkgc2hvdyBhZHZlcnRzIGZyb20gZmF2b3VyaXRlIGFkdmVydGlzZXJzLiBEZWZhdWx0IGlzIDAuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmxpbWl0IC0gW09wdGlvbmFsXSBVc2VkIGZvciBwYWdpbmcuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmxvY2FsX2N1cnJlbmN5IC0gW09wdGlvbmFsXSBDdXJyZW5jeSB0byBjb25kdWN0IHBheW1lbnQgdHJhbnNhY3Rpb24gaW4sIGRlZmF1bHRzIHRvIHRoZSBtYWluIGN1cnJlbmN5IGZvciB0aGUgY2xpZW50J3MgY291bnRyeS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3Mub2Zmc2V0IC0gW09wdGlvbmFsXSBVc2VkIGZvciBwYWdpbmcuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnAycF9hZHZlcnRfbGlzdCAtIE11c3QgYmUgMVxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBheW1lbnRfbWV0aG9kIC0gW09wdGlvbmFsXSBTZWFyY2ggYnkgc3VwcG9ydGVkIHBheW1lbnQgbWV0aG9kcy5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5zb3J0X2J5IC0gW09wdGlvbmFsXSBIb3cgdGhlIHJlc3VsdHMgYXJlIHNvcnRlZDogYmVzdCByYXRlLCBvciBhZHZlcnRpc2VyIGNvbXBsZXRpb24gcmF0ZS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MudXNlX2NsaWVudF9saW1pdHMgLSBbT3B0aW9uYWxdIElmIHNldCB0byAxLCBhZHMgdGhhdCBleGNlZWQgdGhpcyBhY2NvdW50J3MgYmFsYW5jZSBvciB0dXJub3ZlciBsaW1pdHMgd2lsbCBub3QgYmUgc2hvd24uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJwMnBBZHZlcnRMaXN0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHAycEFkdmVydExpc3QoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBhZHZlcnRpc2VyX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgYWR2ZXJ0aXNlcl9uYW1lOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgYW1vdW50OiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGNvdW50ZXJwYXJ0eV90eXBlOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgZmF2b3VyaXRlc19vbmx5OiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGxpbWl0OiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGxvY2FsX2N1cnJlbmN5OiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgb2Zmc2V0OiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHAycF9hZHZlcnRfbGlzdDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcGF5bWVudF9tZXRob2Q6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHNvcnRfYnk6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICB1c2VfY2xpZW50X2xpbWl0czoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAncDJwX2FkdmVydF9saXN0JyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5kZWxldGUgLSBbT3B0aW9uYWxdIElmIHNldCB0byAxLCBwZXJtYW5lbnRseSBkZWxldGVzIHRoZSBhZHZlcnQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGFkdmVydC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuaXNfYWN0aXZlIC0gW09wdGlvbmFsXSBBY3RpdmF0ZSBvciBkZWFjdGl2YXRlIHRoZSBhZHZlcnQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnAycF9hZHZlcnRfdXBkYXRlIC0gTXVzdCBiZSAxXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MucGF5bWVudF9tZXRob2QgLSBbT3B0aW9uYWxdIFN1cHBvcnRlZCBwYXltZW50IG1ldGhvZHMuIFNlcGFyYXRlIG11bHRpcGxlIHZhbHVlcyB3aXRoIGEgY29tbWEsIG1heGltdW0gMy5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGF5bWVudF9tZXRob2RfaWRzIC0gW09wdGlvbmFsXSBJRHMgb2YgcGF5bWVudCBtZXRob2RzLCBvbmx5IGFwcGxpY2FibGUgZm9yIHNlbGwgYWRzLiBXaWxsIHJlcGxhY2UgZXhpc2l0aW5nIG1ldGhvZHMuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInAycEFkdmVydFVwZGF0ZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwMnBBZHZlcnRVcGRhdGUoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBcXFwiZGVsZXRlXFxcIjoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBpZDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBpc19hY3RpdmU6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcDJwX2FkdmVydF91cGRhdGU6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHBheW1lbnRfbWV0aG9kOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGF5bWVudF9tZXRob2RfaWRzOiB7fSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAncDJwX2FkdmVydF91cGRhdGUnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmxpbWl0IC0gW09wdGlvbmFsXSBVc2VkIGZvciBwYWdpbmcuIFRoaXMgdmFsdWUgd2lsbCBhbHNvIGFwcGx5IHRvIHN1YnNyaXB0aW9uIHJlc3BvbnNlcy5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3Mub2Zmc2V0IC0gW09wdGlvbmFsXSBVc2VkIGZvciBwYWdpbmcuIFRoaXMgdmFsdWUgd2lsbCBhbHNvIGFwcGx5IHRvIHN1YnNyaXB0aW9uIHJlc3BvbnNlcy5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucDJwX2FkdmVydGlzZXJfYWR2ZXJ0cyAtIE11c3QgYmUgMVxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInAycEFkdmVydGlzZXJBZHZlcnRzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHAycEFkdmVydGlzZXJBZHZlcnRzKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgbGltaXQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgb2Zmc2V0OiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHAycF9hZHZlcnRpc2VyX2FkdmVydHM6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAncDJwX2FkdmVydGlzZXJfYWR2ZXJ0cycsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuY29udGFjdF9pbmZvIC0gW09wdGlvbmFsXSBBZHZlcnRpc2VyJ3MgY29udGFjdCBpbmZvcm1hdGlvbiwgdG8gYmUgdXNlZCBhcyBhIGRlZmF1bHQgZm9yIG5ldyBzZWxsIGFkdmVydHMuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmRlZmF1bHRfYWR2ZXJ0X2Rlc2NyaXB0aW9uIC0gW09wdGlvbmFsXSBEZWZhdWx0IGRlc2NyaXB0aW9uIHRoYXQgY2FuIGJlIHVzZWQgZXZlcnkgdGltZSBhbiBhZHZlcnQgaXMgY3JlYXRlZC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MubmFtZSAtIFRoZSBhZHZlcnRpc2VyJ3MgZGlzcGxheWVkIG5hbWUuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnAycF9hZHZlcnRpc2VyX2NyZWF0ZSAtIE11c3QgYmUgMVxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnBheW1lbnRfaW5mbyAtIFtPcHRpb25hbF0gQWR2ZXJ0aXNlcidzIHBheW1lbnQgaW5mb3JtYXRpb24sIHRvIGJlIHVzZWQgYXMgYSBkZWZhdWx0IGZvciBuZXcgc2VsbCBhZHZlcnRzLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnN1YnNjcmliZSAtIFtPcHRpb25hbF0gSWYgc2V0IHRvIDEsIHdpbGwgc2VuZCB1cGRhdGVzIHdoZW5ldmVyIHRoZXJlIGlzIGFuIHVwZGF0ZSB0byBhZHZlcnRpc2VyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJwMnBBZHZlcnRpc2VyQ3JlYXRlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHAycEFkdmVydGlzZXJDcmVhdGUoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBjb250YWN0X2luZm86IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBkZWZhdWx0X2FkdmVydF9kZXNjcmlwdGlvbjoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIG5hbWU6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgcDJwX2FkdmVydGlzZXJfY3JlYXRlOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICBwYXltZW50X2luZm86IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgc3Vic2NyaWJlOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdwMnBfYWR2ZXJ0aXNlcl9jcmVhdGUnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmlkIC0gW09wdGlvbmFsXSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgYWR2ZXJ0aXNlci4gSWYgbm90IHByb3ZpZGVkLCByZXR1cm5zIGFkdmVydGlzZXIgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgYWNjb3VudC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucDJwX2FkdmVydGlzZXJfaW5mbyAtIE11c3QgYmUgMVxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3Muc3Vic2NyaWJlIC0gW09wdGlvbmFsXSBJZiBzZXQgdG8gMSwgd2lsbCBzZW5kIHVwZGF0ZXMgd2hlbmV2ZXIgdGhlcmUgaXMgYW4gdXBkYXRlIHRvIGFkdmVydGlzZXJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInAycEFkdmVydGlzZXJJbmZvXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHAycEFkdmVydGlzZXJJbmZvKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBwMnBfYWR2ZXJ0aXNlcl9pbmZvOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgc3Vic2NyaWJlOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdwMnBfYWR2ZXJ0aXNlcl9pbmZvJyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5jcmVhdGUgLSBDb250YWlucyBuZXcgcGF5bWVudCBtZXRob2QgZW50cmllcy5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MuZGVsZXRlIC0gQ29udGFpbnMgcGF5bWVudCBtZXRob2RzIHRvIGRlbGV0ZS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucDJwX2FkdmVydGlzZXJfcGF5bWVudF9tZXRob2RzIC0gTXVzdCBiZSAxXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy51cGRhdGUgLSBDb250YWlucyBwYXltZW50IG1ldGhvZHMgdG8gdXBkYXRlLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicDJwQWR2ZXJ0aXNlclBheW1lbnRNZXRob2RzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHAycEFkdmVydGlzZXJQYXltZW50TWV0aG9kcygpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGNyZWF0ZToge30sXFxuICAgICAgICBcXFwiZGVsZXRlXFxcIjoge30sXFxuICAgICAgICBwMnBfYWR2ZXJ0aXNlcl9wYXltZW50X21ldGhvZHM6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICB1cGRhdGU6IHt9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ3AycF9hZHZlcnRpc2VyX3BheW1lbnRfbWV0aG9kcycsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MuYWRkX2Jsb2NrZWQgLSBJRHMgb2YgYWR2ZXJ0aXNlcnMgdG8gYmxvY2suXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLmFkZF9mYXZvdXJpdGVzIC0gSURzIG9mIGFkdmVydGlzZXJzIHRvIGFkZCBhcyBmYXZvdXJpdGVzLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5wMnBfYWR2ZXJ0aXNlcl9yZWxhdGlvbnMgLSBNdXN0IGJlIDFcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5yZW1vdmVfYmxvY2tlZCAtIElEcyBvZiBhZHZlcnRpc2VycyB0byByZW1vdmUgZnJvbSBibG9ja2VkLlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5yZW1vdmVfZmF2b3VyaXRlcyAtIElEcyBvZiBhZHZlcnRpc2VycyB0byByZW1vdmUgZnJvbSBmYXZvdXJpdGVzLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJwMnBBZHZlcnRpc2VyUmVsYXRpb25zXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHAycEFkdmVydGlzZXJSZWxhdGlvbnMoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBhZGRfYmxvY2tlZDoge30sXFxuICAgICAgICBhZGRfZmF2b3VyaXRlczoge30sXFxuICAgICAgICBwMnBfYWR2ZXJ0aXNlcl9yZWxhdGlvbnM6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHJlbW92ZV9ibG9ja2VkOiB7fSxcXG4gICAgICAgIHJlbW92ZV9mYXZvdXJpdGVzOiB7fSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAncDJwX2FkdmVydGlzZXJfcmVsYXRpb25zJyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5jb250YWN0X2luZm8gLSBbT3B0aW9uYWxdIEFkdmVydGlzZXIncyBjb250YWN0IGluZm9ybWF0aW9uLCB0byBiZSB1c2VkIGFzIGEgZGVmYXVsdCBmb3IgbmV3IHNlbGwgYWR2ZXJ0cy5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuZGVmYXVsdF9hZHZlcnRfZGVzY3JpcHRpb24gLSBbT3B0aW9uYWxdIERlZmF1bHQgZGVzY3JpcHRpb24gdGhhdCBjYW4gYmUgdXNlZCBldmVyeSB0aW1lIGFuIGFkdmVydCBpcyBjcmVhdGVkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5pc19saXN0ZWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gc2V0IGlmIHRoZSBhZHZlcnRpc2VyJ3MgYWR2ZXJ0cyBjb3VsZCBiZSBsaXN0ZWQuIFdoZW4gYDBgLCBhZHZlcnRzIHdvbid0IGJlIGxpc3RlZCByZWdhcmRsZXNzIG9mIHRoZXkgYXJlIGFjdGl2ZSBvciBub3QuIFRoaXMgZG9lc24ndCBjaGFuZ2UgdGhlIGBpc19hY3RpdmVgIG9mIGVhY2ggaW5kaXZpZHVhbCBhZHZlcnQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnAycF9hZHZlcnRpc2VyX3VwZGF0ZSAtIE11c3QgYmUgMVxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnBheW1lbnRfaW5mbyAtIFtPcHRpb25hbF0gQWR2ZXJ0aXNlcidzIHBheW1lbnQgaW5mb3JtYXRpb24sIHRvIGJlIHVzZWQgYXMgYSBkZWZhdWx0IGZvciBuZXcgc2VsbCBhZHZlcnRzLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnNob3dfbmFtZSAtIFtPcHRpb25hbF0gV2hlbiBgMWAsIHRoZSBhZHZlcnRpc2VyJ3MgcmVhbCBuYW1lIHdpbGwgYmUgZGlzcGxheWVkIG9uIHRvIG90aGVyIHVzZXJzIG9uIGFkdmVydHMgYW5kIG9yZGVycy5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInAycEFkdmVydGlzZXJVcGRhdGVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcDJwQWR2ZXJ0aXNlclVwZGF0ZSgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGNvbnRhY3RfaW5mbzoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGRlZmF1bHRfYWR2ZXJ0X2Rlc2NyaXB0aW9uOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgaXNfbGlzdGVkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHAycF9hZHZlcnRpc2VyX3VwZGF0ZToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcGF5bWVudF9pbmZvOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHNob3dfbmFtZToge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAncDJwX2FkdmVydGlzZXJfdXBkYXRlJyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5vcmRlcl9pZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIG9yZGVyIHRvIGNyZWF0ZSB0aGUgY2hhdCBmb3IuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnAycF9jaGF0X2NyZWF0ZSAtIE11c3QgYmUgMVxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInAycENoYXRDcmVhdGVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcDJwQ2hhdENyZWF0ZSgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIG9yZGVyX2lkOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHAycF9jaGF0X2NyZWF0ZToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdwMnBfY2hhdF9jcmVhdGUnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIG9yZGVyLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5wMnBfb3JkZXJfY2FuY2VsIC0gTXVzdCBiZSAxXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicDJwT3JkZXJDYW5jZWxcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcDJwT3JkZXJDYW5jZWwoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBpZDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBwMnBfb3JkZXJfY2FuY2VsOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ3AycF9vcmRlcl9jYW5jZWwnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIG9yZGVyLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5wMnBfb3JkZXJfY29uZmlybSAtIE11c3QgYmUgMVxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInAycE9yZGVyQ29uZmlybVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwMnBPcmRlckNvbmZpcm0oKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBpZDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBwMnBfb3JkZXJfY29uZmlybToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdwMnBfb3JkZXJfY29uZmlybScsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuYWR2ZXJ0X2lkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgYWR2ZXJ0IHRvIGNyZWF0ZSBhbiBvcmRlciBhZ2FpbnN0LlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5hbW91bnQgLSBUaGUgYW1vdW50IG9mIGN1cnJlbmN5IHRvIGJlIGJvdWdodCBvciBzb2xkLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5jb250YWN0X2luZm8gLSBbT3B0aW9uYWxdIFNlbGxlciBjb250YWN0IGluZm9ybWF0aW9uLiBPbmx5IGFwcGxpY2FibGUgZm9yICdzZWxsIG9yZGVycycuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnAycF9vcmRlcl9jcmVhdGUgLSBNdXN0IGJlIDFcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5wYXltZW50X2luZm8gLSBbT3B0aW9uYWxdIFBheW1lbnQgaW5zdHJ1Y3Rpb25zLCBvbmx5IGFwcGxpY2FibGUgZm9yIHNlbGwgb3JkZXJzLlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXltZW50X21ldGhvZF9pZHMgLSBJRHMgb2YgcGF5bWVudCBtZXRob2RzLCBvbmx5IGFwcGxpY2FibGUgZm9yIHNlbGwgb3JkZXJzLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnN1YnNjcmliZSAtIFtPcHRpb25hbF0gSWYgc2V0IHRvIDEsIHdpbGwgc2VuZCB1cGRhdGVzIHdoZW5ldmVyIHRoZXJlIGlzIGFuIHVwZGF0ZSB0byB0aGUgb3JkZXIuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJwMnBPcmRlckNyZWF0ZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwMnBPcmRlckNyZWF0ZSgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGFkdmVydF9pZDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBhbW91bnQ6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGNvbnRhY3RfaW5mbzoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHAycF9vcmRlcl9jcmVhdGU6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHBheW1lbnRfaW5mbzoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBheW1lbnRfbWV0aG9kX2lkczoge30sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgc3Vic2NyaWJlOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdwMnBfb3JkZXJfY3JlYXRlJyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5kaXNwdXRlX3JlYXNvbiAtIFRoZSBwcmVkZWZpbmVkIGRpc3B1dGUgcmVhc29uXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIG9yZGVyLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5wMnBfb3JkZXJfZGlzcHV0ZSAtIE11c3QgYmUgMVxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInAycE9yZGVyRGlzcHV0ZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwMnBPcmRlckRpc3B1dGUoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBkaXNwdXRlX3JlYXNvbjoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBpZDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBwMnBfb3JkZXJfZGlzcHV0ZToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdwMnBfb3JkZXJfZGlzcHV0ZScsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuaWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBvcmRlci5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucDJwX29yZGVyX2luZm8gLSBNdXN0IGJlIDFcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnN1YnNjcmliZSAtIFtPcHRpb25hbF0gSWYgc2V0IHRvIDEsIHdpbGwgc2VuZCB1cGRhdGVzIHdoZW5ldmVyIHRoZXJlIGlzIGFuIHVwZGF0ZSB0byBvcmRlclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicDJwT3JkZXJJbmZvXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHAycE9yZGVySW5mbygpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGlkOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHAycF9vcmRlcl9pbmZvOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgc3Vic2NyaWJlOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdwMnBfb3JkZXJfaW5mbycsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuYWN0aXZlIC0gW09wdGlvbmFsXSBTaG91bGQgYmUgMSB0byBsaXN0IGFjdGl2ZSwgMCB0byBsaXN0IGluYWN0aXZlIChoaXN0b3JpY2FsKS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuYWR2ZXJ0X2lkIC0gW09wdGlvbmFsXSBJZiBwcmVzZW50LCBsaXN0cyBvcmRlcnMgYXBwbHlpbmcgdG8gYSBzcGVjaWZpYyBhZHZlcnQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmxpbWl0IC0gW09wdGlvbmFsXSBVc2VkIGZvciBwYWdpbmcuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLm9mZnNldCAtIFtPcHRpb25hbF0gVXNlZCBmb3IgcGFnaW5nLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5wMnBfb3JkZXJfbGlzdCAtIE11c3QgYmUgMVxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3Muc3Vic2NyaWJlIC0gW09wdGlvbmFsXSBJZiBzZXQgdG8gMSwgd2lsbCBzZW5kIHVwZGF0ZXMgd2hlbmV2ZXIgdGhlcmUgaXMgYSBjaGFuZ2UgdG8gYW55IG9yZGVyIGJlbG9uZ2luZyB0byB5b3UuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJwMnBPcmRlckxpc3RcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcDJwT3JkZXJMaXN0KCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgYWN0aXZlOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGFkdmVydF9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGxpbWl0OiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIG9mZnNldDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBwMnBfb3JkZXJfbGlzdDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHN1YnNjcmliZToge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAncDJwX29yZGVyX2xpc3QnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnAycF9wYXltZW50X21ldGhvZHMgLSBNdXN0IGJlIDFcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJwMnBQYXltZW50TWV0aG9kc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwMnBQYXltZW50TWV0aG9kcygpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIHAycF9wYXltZW50X21ldGhvZHM6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAncDJwX3BheW1lbnRfbWV0aG9kcycsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuY291bnRyeSAtIFtPcHRpb25hbF0gMi1sZXR0ZXIgY291bnRyeSBjb2RlIChJU08gc3RhbmRhcmQpLlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnBheW1lbnRfbWV0aG9kcyAtIE11c3QgYmUgYDFgXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInBheW1lbnRNZXRob2RzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBheW1lbnRNZXRob2RzKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgY291bnRyeToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHBheW1lbnRfbWV0aG9kczoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdwYXltZW50X21ldGhvZHMnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmFmZmlsaWF0ZV9pZCAtIFtPcHRpb25hbF0gQ2xpZW50J3MgTXkgQWZmaWxpYXRlIGlkLCBpZiBleGlzdHMuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmNvZGVfb2ZfY29uZHVjdF9hcHByb3ZhbCAtIEluZGljYXRlcyBjbGllbnQncyBhZ3JlZW1lbnQgd2l0aCB0aGUgQ29kZSBvZiBDb25kdWN0LlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5jb21taXNzaW9uX2RlcG9zaXQgLSBDb21taXNzaW9uICAoJSkgdGhlIGFnZW50IHdhbnRzIHRvIHRha2Ugb24gZGVwb3NpdHNcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuY29tbWlzc2lvbl93aXRoZHJhd2FsIC0gQ29tbWlzc2lvbiAgKCUpIHRoZSBhZ2VudCB3YW50cyB0byB0YWtlIG9uIHdpdGhkcmF3YWxzXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmVtYWlsIC0gUGF5bWVudCBhZ2VudCdzIGVtYWlsIGFkZHJlc3MuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmluZm9ybWF0aW9uIC0gW09wdGlvbmFsXSBJbmZvcm1hdGlvbiBhYm91dCBwYXltZW50IGFnZW50IGFuZCB0aGVpciBwcm9wb3NlZCBzZXJ2aWNlLlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnBheW1lbnRfYWdlbnRfbmFtZSAtIFRoZSBuYW1lIHdpdGggd2hpY2ggdGhlIHBheW1lbnQgYWdlbnQgaXMgZ29pbmcgdG8gYmUgaWRlbnRpZmllZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucGF5bWVudGFnZW50X2NyZWF0ZSAtIE11c3QgYmUgMVxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5waG9uZSAtIFBheW1lbnQgYWdlbnQncyBwaG9uZSBudW1iZXIgd2l0aCBjb3V0cnkgY29kZS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5zdXBwb3J0ZWRfcGF5bWVudF9tZXRob2RzIC0gQSBsaXN0IG9mIHN1cHBvcnRlZCBwYXltZW50IG1ldGhvZHMuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnVybCAtIFRoZSBVUkwgb2YgcGF5bWVudCBhZ2VudCdzIHdlYnNpdGUuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJwYXltZW50YWdlbnRDcmVhdGVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF5bWVudGFnZW50Q3JlYXRlKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgYWZmaWxpYXRlX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgY29kZV9vZl9jb25kdWN0X2FwcHJvdmFsOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBjb21taXNzaW9uX2RlcG9zaXQ6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGNvbW1pc3Npb25fd2l0aGRyYXdhbDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgZW1haWw6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgaW5mb3JtYXRpb246IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcGF5bWVudF9hZ2VudF9uYW1lOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBheW1lbnRhZ2VudF9jcmVhdGU6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBob25lOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHN1cHBvcnRlZF9wYXltZW50X21ldGhvZHM6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDFcXG4gICAgICAgIH0sXFxuICAgICAgICB1cmw6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ3BheW1lbnRhZ2VudF9jcmVhdGUnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucGF5bWVudGFnZW50X2RldGFpbHMgLSBNdXN0IGJlIDFcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicGF5bWVudGFnZW50RGV0YWlsc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXltZW50YWdlbnREZXRhaWxzKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcGF5bWVudGFnZW50X2RldGFpbHM6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAncGF5bWVudGFnZW50X2RldGFpbHMnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmN1cnJlbmN5IC0gW09wdGlvbmFsXSBJZiBzcGVjaWZpZWQsIG9ubHkgcGF5bWVudCBhZ2VudHMgdGhhdCBzdXBwb3J0cyB0aGF0IGN1cnJlbmN5IHdpbGwgYmUgcmV0dXJuZWQgKG9idGFpbmVkIGZyb20gYHBheW91dF9jdXJyZW5jaWVzYCBjYWxsKS5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5wYXltZW50YWdlbnRfbGlzdCAtIENsaWVudCdzIDItbGV0dGVyIGNvdW50cnkgY29kZSAob2J0YWluZWQgZnJvbSBgcmVzaWRlbmNlX2xpc3RgIGNhbGwpLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJwYXltZW50YWdlbnRMaXN0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBheW1lbnRhZ2VudExpc3QoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBjdXJyZW5jeToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHBheW1lbnRhZ2VudF9saXN0OiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAncGF5bWVudGFnZW50X2xpc3QnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmFtb3VudCAtIFRoZSBhbW91bnQgdG8gdHJhbnNmZXIuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmN1cnJlbmN5IC0gQ3VycmVuY3kgY29kZS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuZGVzY3JpcHRpb24gLSBbT3B0aW9uYWxdIFJlbWFya3MgYWJvdXQgdGhlIHRyYW5zZmVyLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5kcnlfcnVuIC0gW09wdGlvbmFsXSBJZiBzZXQgdG8gYDFgLCBqdXN0IGRvIHZhbGlkYXRpb24uXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucGF5bWVudGFnZW50X3RyYW5zZmVyIC0gTXVzdCBiZSBgMWBcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy50cmFuc2Zlcl90byAtIFRoZSBsb2dpbmlkIG9mIHRoZSByZWNpcGllbnQgYWNjb3VudC5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInBheW1lbnRhZ2VudFRyYW5zZmVyXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBheW1lbnRhZ2VudFRyYW5zZmVyKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgYW1vdW50OiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBjdXJyZW5jeToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBkZXNjcmlwdGlvbjoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGRyeV9ydW46IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcGF5bWVudGFnZW50X3RyYW5zZmVyOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgdHJhbnNmZXJfdG86IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ3BheW1lbnRhZ2VudF90cmFuc2ZlcicsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuYW1vdW50IC0gVGhlIGFtb3VudCB0byB3aXRoZHJhdyB0byB0aGUgcGF5bWVudCBhZ2VudC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuY3VycmVuY3kgLSBUaGUgY3VycmVuY3kgY29kZS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuZGVzY3JpcHRpb24gLSBbT3B0aW9uYWxdIFJlbWFya3MgYWJvdXQgdGhlIHdpdGhkcmF3LiBPbmx5IGxldHRlcnMsIG51bWJlcnMsIHNwYWNlLCBwZXJpb2QsIGNvbW1hLCAtICcgYXJlIGFsbG93ZWQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmRyeV9ydW4gLSBbT3B0aW9uYWxdIElmIHNldCB0byAxLCBqdXN0IGRvIHZhbGlkYXRpb24uXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MucGF5bWVudGFnZW50X2xvZ2luaWQgLSBUaGUgcGF5bWVudCBhZ2VudCBsb2dpbmlkIHJlY2VpdmVkIGZyb20gdGhlIGBwYXltZW50YWdlbnRfbGlzdGAgY2FsbC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucGF5bWVudGFnZW50X3dpdGhkcmF3IC0gTXVzdCBiZSBgMWBcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy52ZXJpZmljYXRpb25fY29kZSAtIEVtYWlsIHZlcmlmaWNhdGlvbiBjb2RlIChyZWNlaXZlZCBmcm9tIGEgYHZlcmlmeV9lbWFpbGAgY2FsbCwgd2hpY2ggbXVzdCBiZSBkb25lIGZpcnN0KVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicGF5bWVudGFnZW50V2l0aGRyYXdcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF5bWVudGFnZW50V2l0aGRyYXcoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBhbW91bnQ6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGN1cnJlbmN5OiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGRlc2NyaXB0aW9uOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgZHJ5X3J1bjoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICBwYXltZW50YWdlbnRfbG9naW5pZDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXltZW50YWdlbnRfd2l0aGRyYXc6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICB2ZXJpZmljYXRpb25fY29kZToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAncGF5bWVudGFnZW50X3dpdGhkcmF3JyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnBheW91dF9jdXJyZW5jaWVzIC0gTXVzdCBiZSBgMWBcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicGF5b3V0Q3VycmVuY2llc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXlvdXRDdXJyZW5jaWVzKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcGF5b3V0X2N1cnJlbmNpZXM6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAncGF5b3V0X2N1cnJlbmNpZXMnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucGluZyAtIE11c3QgYmUgYDFgXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInBpbmdcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGluZygpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHBpbmc6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAncGluZycsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MuY29udHJhY3RfdHlwZSAtIFJldHVybiBvbmx5IGNvbnRyYWN0cyBvZiB0aGUgc3BlY2lmaWVkIHR5cGVzXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucG9ydGZvbGlvIC0gTXVzdCBiZSBgMWBcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicG9ydGZvbGlvXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvcnRmb2xpbygpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGNvbnRyYWN0X3R5cGU6IHt9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcG9ydGZvbGlvOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ3BvcnRmb2xpbycsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MuY29udHJhY3RfdHlwZSAtIFJldHVybiBvbmx5IGNvbnRyYWN0cyBvZiB0aGUgc3BlY2lmaWVkIHR5cGVzXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmRhdGVfZnJvbSAtIFtPcHRpb25hbF0gU3RhcnQgZGF0ZSAoZXBvY2ggb3IgWVlZWS1NTS1ERClcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuZGF0ZV90byAtIFtPcHRpb25hbF0gRW5kIGRhdGUgKGVwb2NoIG9yIFlZWVktTU0tREQpXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmRlc2NyaXB0aW9uIC0gW09wdGlvbmFsXSBJZiBzZXQgdG8gMSwgd2lsbCByZXR1cm4gZnVsbCBjb250cmFjdHMgZGVzY3JpcHRpb24uXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmxpbWl0IC0gW09wdGlvbmFsXSBBcHBseSB1cHBlciBsaW1pdCB0byBjb3VudCBvZiB0cmFuc2FjdGlvbnMgcmVjZWl2ZWQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLm9mZnNldCAtIFtPcHRpb25hbF0gTnVtYmVyIG9mIHRyYW5zYWN0aW9ucyB0byBza2lwLlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnByb2ZpdF90YWJsZSAtIE11c3QgYmUgYDFgXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3Muc29ydCAtIFtPcHRpb25hbF0gU29ydCBkaXJlY3Rpb24uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJwcm9maXRUYWJsZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9maXRUYWJsZSgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGNvbnRyYWN0X3R5cGU6IHt9LFxcbiAgICAgICAgZGF0ZV9mcm9tOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgZGF0ZV90bzoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGRlc2NyaXB0aW9uOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGxpbWl0OiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIG9mZnNldDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICBwcm9maXRfdGFibGU6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBzb3J0OiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ3Byb2ZpdF90YWJsZScsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuYW1vdW50IC0gW09wdGlvbmFsXSBQcm9wb3NlZCBjb250cmFjdCBwYXlvdXQgb3Igc3Rha2UsIG9yIG11bHRpcGxpZXIgKGZvciBsb29rYmFja3MpLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5iYXJyaWVyIC0gW09wdGlvbmFsXSBCYXJyaWVyIGZvciB0aGUgY29udHJhY3QgKG9yIGxhc3QgZGlnaXQgcHJlZGljdGlvbiBmb3IgZGlnaXQgY29udHJhY3RzKS4gQ29udHJhY3RzIGxlc3MgdGhhbiAyNCBob3VycyBpbiBkdXJhdGlvbiB3b3VsZCBuZWVkIGEgcmVsYXRpdmUgYmFycmllciAoYmFycmllcnMgd2hpY2ggbmVlZCArLy0pLCB3aGVyZSBlbnRyeSBzcG90IHdvdWxkIGJlIGFkanVzdGVkIGFjY29yZGluZ2x5IHdpdGggdGhhdCBhbW91bnQgdG8gZGVmaW5lIGEgYmFycmllciwgZXhjZXB0IGZvciBTeW50aGV0aWMgSW5kaWNlcyBhcyB0aGV5IHN1cHBvcnQgYm90aCByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgYmFycmllcnMuIE5vdCBuZWVkZWQgZm9yIGxvb2tiYWNrcy5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuYmFycmllcjIgLSBbT3B0aW9uYWxdIExvdyBiYXJyaWVyIGZvciB0aGUgY29udHJhY3QgKGZvciBjb250cmFjdHMgd2l0aCB0d28gYmFycmllcnMpLiBDb250cmFjdHMgbGVzcyB0aGFuIDI0IGhvdXJzIGluIGR1cmF0aW9uIHdvdWxkIG5lZWQgYSByZWxhdGl2ZSBiYXJyaWVyIChiYXJyaWVycyB3aGljaCBuZWVkICsvLSksIHdoZXJlIGVudHJ5IHNwb3Qgd291bGQgYmUgYWRqdXN0ZWQgYWNjb3JkaW5nbHkgd2l0aCB0aGF0IGFtb3VudCB0byBkZWZpbmUgYSBiYXJyaWVyLCBleGNlcHQgZm9yIFN5bnRoZXRpYyBJbmRpY2VzIGFzIHRoZXkgc3VwcG9ydCBib3RoIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBiYXJyaWVycy4gTm90IG5lZWRlZCBmb3IgbG9va2JhY2tzLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5iYXNpcyAtIFtPcHRpb25hbF0gSW5kaWNhdGVzIHR5cGUgb2YgdGhlIGBhbW91bnRgLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5jYW5jZWxsYXRpb24gLSBDYW5jZWxsYXRpb24gZHVyYXRpb24gb3B0aW9uIChvbmx5IGZvciBgTVVMVFVQYCBhbmQgYE1VTFRET1dOYCBjb250cmFjdHMpLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5jb250cmFjdF90eXBlIC0gVGhlIHByb3Bvc2VkIGNvbnRyYWN0IHR5cGVcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuY3VycmVuY3kgLSBUaGlzIGNhbiBvbmx5IGJlIHRoZSBhY2NvdW50LWhvbGRlcidzIGN1cnJlbmN5IChvYnRhaW5lZCBmcm9tIGBwYXlvdXRfY3VycmVuY2llc2AgY2FsbCkuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmRhdGVfZXhwaXJ5IC0gW09wdGlvbmFsXSBFcG9jaCB2YWx1ZSBvZiB0aGUgZXhwaXJ5IHRpbWUgb2YgdGhlIGNvbnRyYWN0LiBFaXRoZXIgZGF0ZV9leHBpcnkgb3IgZHVyYXRpb24gaXMgcmVxdWlyZWQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmRhdGVfc3RhcnQgLSBbT3B0aW9uYWxdIEluZGljYXRlcyBlcG9jaCB2YWx1ZSBvZiB0aGUgc3RhcnRpbmcgdGltZSBvZiB0aGUgY29udHJhY3QuIElmIGxlZnQgZW1wdHksIHRoZSBzdGFydCB0aW1lIG9mIHRoZSBjb250cmFjdCBpcyBub3cuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmR1cmF0aW9uIC0gW09wdGlvbmFsXSBEdXJhdGlvbiBxdWFudGl0eS4gRWl0aGVyIGRhdGVfZXhwaXJ5IG9yIGR1cmF0aW9uIGlzIHJlcXVpcmVkLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5kdXJhdGlvbl91bml0IC0gW09wdGlvbmFsXSBEdXJhdGlvbiB1bml0IC0gYHNgOiBzZWNvbmRzLCBgbWA6IG1pbnV0ZXMsIGBoYDogaG91cnMsIGBkYDogZGF5cywgYHRgOiB0aWNrcy5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MubGltaXRfb3JkZXIgLVxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5tdWx0aXBsaWVyIC0gW09wdGlvbmFsXSBUaGUgbXVsdGlwbGllciBmb3Igbm9uLWJpbmFyeSBvcHRpb25zLiBFLmcuIGxvb2tiYWNrcy5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5wcm9kdWN0X3R5cGUgLSBbT3B0aW9uYWxdIFRoZSBwcm9kdWN0IHR5cGUuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnByb3Bvc2FsIC0gTXVzdCBiZSBgMWBcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5zZWxlY3RlZF90aWNrIC0gW09wdGlvbmFsXSBUaGUgdGljayB0aGF0IGlzIHByZWRpY3RlZCB0byBoYXZlIHRoZSBoaWdoZXN0L2xvd2VzdCB2YWx1ZSAtIGZvciBgVElDS0hJR0hgIGFuZCBgVElDS0xPV2AgY29udHJhY3RzLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5zdWJzY3JpYmUgLSBbT3B0aW9uYWxdIDEgLSB0byBpbml0aWF0ZSBhIHJlYWx0aW1lIHN0cmVhbSBvZiBwcmljZXMuIE5vdGUgdGhhdCB0aWNrIHRyYWRlcyAod2l0aG91dCBhIHVzZXItZGVmaW5lZCBiYXJyaWVyKSwgZGlnaXQgdHJhZGVzIGFuZCBsZXNzIHRoYW4gMjQgaG91cnMgYXQtdGhlLW1vbmV5IGNvbnRyYWN0cyBmb3IgdGhlIGZvbGxvd2luZyB1bmRlcmx5aW5nIHN5bWJvbHMgYXJlIG5vdCBzdHJlYW1lZDogYFJfMTBgLCBgUl8yNWAsIGBSXzUwYCwgYFJfNzVgLCBgUl8xMDBgLCBgUkRCVUxMYCwgYFJEQkVBUmAgKHRoaXMgaXMgYmVjYXVzZSB0aGVpciBwcmljZSBpcyBjb25zdGFudCkuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnN5bWJvbCAtIFRoZSBzaG9ydCBzeW1ib2wgbmFtZSAob2J0YWluZWQgZnJvbSBgYWN0aXZlX3N5bWJvbHNgIGNhbGwpLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy50cmFkaW5nX3BlcmlvZF9zdGFydCAtIFtPcHRpb25hbF0gUmVxdWlyZWQgb25seSBmb3IgbXVsdGktYmFycmllciB0cmFkaW5nLiBEZWZpbmVzIHRoZSBlcG9jaCB2YWx1ZSBvZiB0aGUgdHJhZGluZyBwZXJpb2Qgc3RhcnQgdGltZS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInByb3Bvc2FsXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb3Bvc2FsKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgYW1vdW50OiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGJhcnJpZXI6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBiYXJyaWVyMjoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGJhc2lzOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgY2FuY2VsbGF0aW9uOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgY29udHJhY3RfdHlwZToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBjdXJyZW5jeToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBkYXRlX2V4cGlyeToge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBkYXRlX3N0YXJ0OiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGR1cmF0aW9uOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGR1cmF0aW9uX3VuaXQ6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBsaW1pdF9vcmRlcjoge1xcbiAgICAgICAgICBzdG9wX2xvc3M6IHtcXG4gICAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgdGFrZV9wcm9maXQ6IHtcXG4gICAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIG11bHRpcGxpZXI6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcHJvZHVjdF90eXBlOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgcHJvcG9zYWw6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBzZWxlY3RlZF90aWNrOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHN1YnNjcmliZToge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBzeW1ib2w6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgdHJhZGluZ19wZXJpb2Rfc3RhcnQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ3Byb3Bvc2FsJyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5jb250cmFjdF9pZCAtIFtPcHRpb25hbF0gQ29udHJhY3QgSUQgcmVjZWl2ZWQgZnJvbSBhIGBwb3J0Zm9saW9gIHJlcXVlc3QuIElmIG5vdCBzZXQsIHlvdSB3aWxsIHJlY2VpdmUgc3RyZWFtIG9mIGFsbCBvcGVuIGNvbnRyYWN0cy5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5wcm9wb3NhbF9vcGVuX2NvbnRyYWN0IC0gTXVzdCBiZSBgMWBcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5zdWJzY3JpYmUgLSBbT3B0aW9uYWxdIGAxYCB0byBzdHJlYW0uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJwcm9wb3NhbE9wZW5Db250cmFjdFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9wb3NhbE9wZW5Db250cmFjdCgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGNvbnRyYWN0X2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHByb3Bvc2FsX29wZW5fY29udHJhY3Q6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBzdWJzY3JpYmU6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ3Byb3Bvc2FsX29wZW5fY29udHJhY3QnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVhbGl0eV9jaGVjayAtIE11c3QgYmUgYDFgXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInJlYWxpdHlDaGVja1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFsaXR5Q2hlY2soKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZWFsaXR5X2NoZWNrOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ3JlYWxpdHlfY2hlY2snLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmRhdGVfZnJvbSAtIFN0YXJ0IGRhdGUgb2YgdGhlIHJlcG9ydFxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5kYXRlX3RvIC0gRW5kIGRhdGUgb2YgdGhlIHJlcG9ydFxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnJlcG9ydF90eXBlIC0gVHlwZSBvZiByZXBvcnQgdG8gYmUgc2VudCB0byBjbGllbnQncyByZWdpc3RlcmVkIGUtbWFpbCBhZGRyZXNzXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxdWVzdF9yZXBvcnQgLSBNdXN0IGJlIGAxYFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicmVxdWVzdFJlcG9ydFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXF1ZXN0UmVwb3J0KCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgZGF0ZV9mcm9tOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBkYXRlX3RvOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZXBvcnRfdHlwZToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcmVxdWVzdF9yZXBvcnQ6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdyZXF1ZXN0X3JlcG9ydCcsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuZGF0ZV9vZl9iaXJ0aCAtIFtPcHRpb25hbF0gRGF0ZSBvZiBiaXJ0aCBmb3JtYXQ6IGB5eXl5LW1tLWRkYC4gT25seSByZXF1aXJlZCBmb3IgY2xpZW50cyB3aXRoIHJlYWwtbW9uZXkgYWNjb3VudHMuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLm5ld19wYXNzd29yZCAtIE5ldyBwYXNzd29yZC4gRm9yIHZhbGlkYXRpb24gKEFjY2VwdHMgYW55IHByaW50YWJsZSBBU0NJSSBjaGFyYWN0ZXIuIE11c3QgYmUgd2l0aGluIDgtMjUgY2hhcmFjdGVycywgYW5kIGluY2x1ZGUgbnVtYmVycywgbG93ZXJjYXNlIGFuZCB1cHBlcmNhc2UgbGV0dGVycy4gTXVzdCBub3QgYmUgdGhlIHNhbWUgYXMgdGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzKS5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlc2V0X3Bhc3N3b3JkIC0gTXVzdCBiZSBgMWBcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MudmVyaWZpY2F0aW9uX2NvZGUgLSBFbWFpbCB2ZXJpZmljYXRpb24gY29kZSAocmVjZWl2ZWQgZnJvbSBhIGB2ZXJpZnlfZW1haWxgIGNhbGwsIHdoaWNoIG11c3QgYmUgZG9uZSBmaXJzdClcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInJlc2V0UGFzc3dvcmRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRQYXNzd29yZCgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGRhdGVfb2ZfYmlydGg6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBuZXdfcGFzc3dvcmQ6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlc2V0X3Bhc3N3b3JkOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICB2ZXJpZmljYXRpb25fY29kZToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAncmVzZXRfcGFzc3dvcmQnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXNpZGVuY2VfbGlzdCAtIE11c3QgYmUgYDFgXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJyZXNpZGVuY2VMaXN0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2lkZW5jZUxpc3QoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcmVzaWRlbmNlX2xpc3Q6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdyZXNpZGVuY2VfbGlzdCcsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJldm9rZV9vYXV0aF9hcHAgLSBUaGUgYXBwbGljYXRpb24gSUQgdG8gcmV2b2tlLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicmV2b2tlT2F1dGhBcHBcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmV2b2tlT2F1dGhBcHAoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcmV2b2tlX29hdXRoX2FwcDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ3Jldm9rZV9vYXV0aF9hcHAnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucHJpY2UgLSBNaW5pbXVtIHByaWNlIGF0IHdoaWNoIHRvIHNlbGwgdGhlIGNvbnRyYWN0LCBvciBgMGAgZm9yICdzZWxsIGF0IG1hcmtldCcuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3Muc2VsbCAtIFBhc3MgY29udHJhY3RfaWQgcmVjZWl2ZWQgZnJvbSB0aGUgYHBvcnRmb2xpb2AgY2FsbC5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInNlbGxcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsbCgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHByaWNlOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgc2VsbDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ3NlbGwnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucHJpY2UgLSBNaW5pbXVtIHByaWNlIGF0IHdoaWNoIHRvIHNlbGwgdGhlIGNvbnRyYWN0LCBvciBgMGAgZm9yICdzZWxsIGF0IG1hcmtldCcuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3Muc2VsbF9jb250cmFjdF9mb3JfbXVsdGlwbGVfYWNjb3VudHMgLSBNdXN0IGJlIGAxYFxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5zaG9ydGNvZGUgLSBBbiBpbnRlcm5hbCBJRCB1c2VkIHRvIGlkZW50aWZ5IHRoZSBjb250cmFjdCB3aGljaCB3YXMgb3JpZ2luYWxseSBib3VnaHQuIFRoaXMgaXMgcmV0dXJuZWQgZnJvbSB0aGUgYGJ1eWAgYW5kIGBidXlfY29udHJhY3RfZm9yX211bHRpcGxlX2FjY291bnRzYCBjYWxscy5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MudG9rZW5zIC0gQXV0aG9yaXNhdGlvbiB0b2tlbnMgd2hpY2ggc2VsZWN0IHRoZSBhY2NvdW50cyB0byBzZWxsIHVzZSBmb3IgdGhlIGFmZmVjdGVkIGFjY291bnRzLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwic2VsbENvbnRyYWN0Rm9yTXVsdGlwbGVBY2NvdW50c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxsQ29udHJhY3RGb3JNdWx0aXBsZUFjY291bnRzKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcHJpY2U6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBzZWxsX2NvbnRyYWN0X2Zvcl9tdWx0aXBsZV9hY2NvdW50czoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgc2hvcnRjb2RlOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHRva2Vuczoge1xcbiAgICAgICAgICByZXF1aXJlZDogMVxcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdzZWxsX2NvbnRyYWN0X2Zvcl9tdWx0aXBsZV9hY2NvdW50cycsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnNlbGxfZXhwaXJlZCAtIE11c3QgYmUgYDFgXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJzZWxsRXhwaXJlZFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxsRXhwaXJlZCgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBzZWxsX2V4cGlyZWQ6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdzZWxsX2V4cGlyZWQnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmNvdW50cnkgLSBbT3B0aW9uYWxdIFRoZSAyLWxldHRlciBjb3VudHJ5IGNvZGUuXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MucmVmZXJyZXIgLSBbT3B0aW9uYWxdIFRoZSBVUkwgb2YgdGhlIHdlYiBwYWdlIHdoZXJlIHRoZSBXZWIgU0RLIHdpbGwgYmUgdXNlZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5zZXJ2ZXIgLSBTZXJ2ZXIgKGR4dHJhZGUgb25seSkuXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnNlcnZpY2UgLSBUaGUgc2VydmljZShzKSB0byByZXRyaWV2ZSB0b2tlbihzKSBmb3IuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnNlcnZpY2VfdG9rZW4gLSBNdXN0IGJlIGAxYFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwic2VydmljZVRva2VuXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcnZpY2VUb2tlbigpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGNvdW50cnk6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZWZlcnJlcjoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBzZXJ2ZXI6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBzZXJ2aWNlOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxXFxuICAgICAgICB9LFxcbiAgICAgICAgc2VydmljZV90b2tlbjoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ3NlcnZpY2VfdG9rZW4nLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5zZXRfYWNjb3VudF9jdXJyZW5jeSAtIEN1cnJlbmN5IG9mIHRoZSBhY2NvdW50LiBMaXN0IG9mIHN1cHBvcnRlZCBjdXJyZW5jaWVzIGNhbiBiZSBhY3F1aXJlZCB3aXRoIGBwYXlvdXRfY3VycmVuY2llc2AgY2FsbC5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInNldEFjY291bnRDdXJyZW5jeVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBY2NvdW50Q3VycmVuY3koKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgc2V0X2FjY291bnRfY3VycmVuY3k6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ3NldF9hY2NvdW50X2N1cnJlbmN5JyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5hY2NvdW50X3R1cm5vdmVyIC0gW09wdGlvbmFsXSBUaGUgYW50aWNpcGF0ZWQgYWNjb3VudCB0dXJub3Zlci5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuYmluYXJ5X29wdGlvbnNfdHJhZGluZ19leHBlcmllbmNlIC0gW09wdGlvbmFsXSBCaW5hcnkgb3B0aW9ucyB0cmFkaW5nIGV4cGVyaWVuY2UuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmJpbmFyeV9vcHRpb25zX3RyYWRpbmdfZnJlcXVlbmN5IC0gW09wdGlvbmFsXSBCaW5hcnkgb3B0aW9ucyB0cmFkaW5nIGZyZXF1ZW5jeS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuY2ZkX3RyYWRpbmdfZXhwZXJpZW5jZSAtIFtPcHRpb25hbF0gQ0ZEcyB0cmFkaW5nIGV4cGVyaWVuY2UuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmNmZF90cmFkaW5nX2ZyZXF1ZW5jeSAtIFtPcHRpb25hbF0gQ0ZEcyB0cmFkaW5nIGZyZXF1ZW5jeS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuZWR1Y2F0aW9uX2xldmVsIC0gTGV2ZWwgb2YgRWR1Y2F0aW9uLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5lbXBsb3ltZW50X2luZHVzdHJ5IC0gSW5kdXN0cnkgb2YgRW1wbG95bWVudC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuZW1wbG95bWVudF9zdGF0dXMgLSBbT3B0aW9uYWxdIEVtcGxveW1lbnQgU3RhdHVzLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5lc3RpbWF0ZWRfd29ydGggLSBFc3RpbWF0ZWQgTmV0IFdvcnRoLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5mb3JleF90cmFkaW5nX2V4cGVyaWVuY2UgLSBbT3B0aW9uYWxdIEZvcmV4IHRyYWRpbmcgZXhwZXJpZW5jZS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuZm9yZXhfdHJhZGluZ19mcmVxdWVuY3kgLSBbT3B0aW9uYWxdIEZvcmV4IHRyYWRpbmcgZnJlcXVlbmN5LlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5pbmNvbWVfc291cmNlIC0gSW5jb21lIFNvdXJjZS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MubmV0X2luY29tZSAtIE5ldCBBbm51YWwgSW5jb21lLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5vY2N1cGF0aW9uIC0gT2NjdXBhdGlvbi5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3Mub3RoZXJfaW5zdHJ1bWVudHNfdHJhZGluZ19leHBlcmllbmNlIC0gW09wdGlvbmFsXSBUcmFkaW5nIGV4cGVyaWVuY2UgaW4gb3RoZXIgZmluYW5jaWFsIGluc3RydW1lbnRzLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5vdGhlcl9pbnN0cnVtZW50c190cmFkaW5nX2ZyZXF1ZW5jeSAtIFtPcHRpb25hbF0gVHJhZGluZyBmcmVxdWVuY3kgaW4gb3RoZXIgZmluYW5jaWFsIGluc3RydW1lbnRzLlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3Muc2V0X2ZpbmFuY2lhbF9hc3Nlc3NtZW50IC0gTXVzdCBiZSBgMWBcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3Muc291cmNlX29mX3dlYWx0aCAtIFtPcHRpb25hbF0gU291cmNlIG9mIHdlYWx0aC5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInNldEZpbmFuY2lhbEFzc2Vzc21lbnRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RmluYW5jaWFsQXNzZXNzbWVudCgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGFjY291bnRfdHVybm92ZXI6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBiaW5hcnlfb3B0aW9uc190cmFkaW5nX2V4cGVyaWVuY2U6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBiaW5hcnlfb3B0aW9uc190cmFkaW5nX2ZyZXF1ZW5jeToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGNmZF90cmFkaW5nX2V4cGVyaWVuY2U6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBjZmRfdHJhZGluZ19mcmVxdWVuY3k6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBlZHVjYXRpb25fbGV2ZWw6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgZW1wbG95bWVudF9pbmR1c3RyeToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBlbXBsb3ltZW50X3N0YXR1czoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGVzdGltYXRlZF93b3J0aDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBmb3JleF90cmFkaW5nX2V4cGVyaWVuY2U6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBmb3JleF90cmFkaW5nX2ZyZXF1ZW5jeToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGluY29tZV9zb3VyY2U6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgbmV0X2luY29tZToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBvY2N1cGF0aW9uOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIG90aGVyX2luc3RydW1lbnRzX3RyYWRpbmdfZXhwZXJpZW5jZToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIG90aGVyX2luc3RydW1lbnRzX3RyYWRpbmdfZnJlcXVlbmN5OiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHNldF9maW5hbmNpYWxfYXNzZXNzbWVudDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgc291cmNlX29mX3dlYWx0aDoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdzZXRfZmluYW5jaWFsX2Fzc2Vzc21lbnQnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLmV4Y2x1ZGVfdW50aWwgLSBbT3B0aW9uYWxdIEV4Y2x1ZGUgbWUgZnJvbSB0aGUgd2Vic2l0ZSAoZm9yIGEgbWluaW11bSBvZiA2IG1vbnRocywgdXAgdG8gYSBtYXhpbXVtIG9mIDUgeWVhcnMpLiBOb3RlOiB1cGxpZnRpbmcgdGhpcyBzZWxmLWV4Y2x1c2lvbiBtYXkgcmVxdWlyZSBjb250YWN0aW5nIHRoZSBjb21wYW55LlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5tYXhfMzBkYXlfZGVwb3NpdCAtIFtPcHRpb25hbF0gNy1kYXkgbGltaXQgb24gZGVwb3NpdHMuXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLm1heF8zMGRheV9sb3NzZXMgLSBbT3B0aW9uYWxdIDMwLWRheSBsaW1pdCBvbiBsb3NzZXMuXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLm1heF8zMGRheV90dXJub3ZlciAtIFtPcHRpb25hbF0gMzAtZGF5IHR1cm5vdmVyIGxpbWl0LlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5tYXhfN2RheV9kZXBvc2l0IC0gW09wdGlvbmFsXSA3LWRheSBsaW1pdCBvbiBkZXBvc2l0cy5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MubWF4XzdkYXlfbG9zc2VzIC0gW09wdGlvbmFsXSA3LWRheSBsaW1pdCBvbiBsb3NzZXMuXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLm1heF83ZGF5X3R1cm5vdmVyIC0gW09wdGlvbmFsXSA3LWRheSB0dXJub3ZlciBsaW1pdC5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MubWF4X2JhbGFuY2UgLSBbT3B0aW9uYWxdIE1heGltdW0gYWNjb3VudCBjYXNoIGJhbGFuY2UuXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLm1heF9kZXBvc2l0IC0gW09wdGlvbmFsXSBEYWlseSBkZXBvc2l0IGxpbWl0LlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5tYXhfbG9zc2VzIC0gW09wdGlvbmFsXSBEYWlseSBsaW1pdCBvbiBsb3NzZXMuXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLm1heF9vcGVuX2JldHMgLSBbT3B0aW9uYWxdIE1heGltdW0gbnVtYmVyIG9mIG9wZW4gcG9zaXRpb25zLlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5tYXhfdHVybm92ZXIgLSBbT3B0aW9uYWxdIERhaWx5IHR1cm5vdmVyIGxpbWl0LlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3Muc2Vzc2lvbl9kdXJhdGlvbl9saW1pdCAtIFtPcHRpb25hbF0gU2Vzc2lvbiBkdXJhdGlvbiBsaW1pdCwgaW4gbWludXRlcy5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3Muc2V0X3NlbGZfZXhjbHVzaW9uIC0gTXVzdCBiZSBgMWBcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MudGltZW91dF91bnRpbCAtIFtPcHRpb25hbF0gRXhjbHVkZSBtZSBmcm9tIHRoZSB3ZWJzaXRlIChmb3IgdXAgdG8gNiB3ZWVrcykuIFJlcXVpcmVzIHRpbWUgaW4gZXBvY2ggZm9ybWF0LiBOb3RlOiB1bmxpa2UgYGV4Y2x1ZGVfdW50aWxgLCB0aGlzIHNlbGYtZXhjbHVzaW9uIHdpbGwgYmUgbGlmdGVkIGF1dG9tYXRpY2FsbHkgYXQgdGhlIGV4cGlyeSBvZiB0aGUgdGltZW91dCBwZXJpb2QuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJzZXRTZWxmRXhjbHVzaW9uXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNlbGZFeGNsdXNpb24oKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBleGNsdWRlX3VudGlsOiB7fSxcXG4gICAgICAgIG1heF8zMGRheV9kZXBvc2l0OiB7fSxcXG4gICAgICAgIG1heF8zMGRheV9sb3NzZXM6IHt9LFxcbiAgICAgICAgbWF4XzMwZGF5X3R1cm5vdmVyOiB7fSxcXG4gICAgICAgIG1heF83ZGF5X2RlcG9zaXQ6IHt9LFxcbiAgICAgICAgbWF4XzdkYXlfbG9zc2VzOiB7fSxcXG4gICAgICAgIG1heF83ZGF5X3R1cm5vdmVyOiB7fSxcXG4gICAgICAgIG1heF9iYWxhbmNlOiB7fSxcXG4gICAgICAgIG1heF9kZXBvc2l0OiB7fSxcXG4gICAgICAgIG1heF9sb3NzZXM6IHt9LFxcbiAgICAgICAgbWF4X29wZW5fYmV0czoge30sXFxuICAgICAgICBtYXhfdHVybm92ZXI6IHt9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHNlc3Npb25fZHVyYXRpb25fbGltaXQ6IHt9LFxcbiAgICAgICAgc2V0X3NlbGZfZXhjbHVzaW9uOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICB0aW1lb3V0X3VudGlsOiB7fVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdzZXRfc2VsZl9leGNsdXNpb24nLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmFjY291bnRfb3BlbmluZ19yZWFzb24gLSBbT3B0aW9uYWxdIFB1cnBvc2UgYW5kIHJlYXNvbiBmb3IgcmVxdWVzdGluZyB0aGUgYWNjb3VudCBvcGVuaW5nLiBPbmx5IGFwcGxpY2FibGUgZm9yIHJlYWwgbW9uZXkgYWNjb3VudC4gUmVxdWlyZWQgZm9yIGNsaWVudHMgdGhhdCBoYXZlIG5vdCBzZXQgaXQgeWV0LiBDYW4gb25seSBiZSBzZXQgb25jZS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuYWRkcmVzc19jaXR5IC0gW09wdGlvbmFsXSBOb3RlOiBub3QgYXBwbGljYWJsZSBmb3IgdmlydHVhbCBhY2NvdW50LiBSZXF1aXJlZCBmaWVsZCBmb3IgcmVhbCBtb25leSBhY2NvdW50LlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5hZGRyZXNzX2xpbmVfMSAtIFtPcHRpb25hbF0gTm90ZTogbm90IGFwcGxpY2FibGUgZm9yIHZpcnR1YWwgYWNjb3VudC4gUmVxdWlyZWQgZmllbGQgZm9yIHJlYWwgbW9uZXkgYWNjb3VudC5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MuYWRkcmVzc19saW5lXzIgLSBbT3B0aW9uYWxdIE5vdGU6IG5vdCBhcHBsaWNhYmxlIGZvciB2aXJ0dWFsIGFjY291bnQuIE9wdGlvbmFsIGZpZWxkIGZvciByZWFsIG1vbmV5IGFjY291bnQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmFkZHJlc3NfcG9zdGNvZGUgLSBbT3B0aW9uYWxdIE5vdGU6IG5vdCBhcHBsaWNhYmxlIGZvciB2aXJ0dWFsIGFjY291bnQuIE9wdGlvbmFsIGZpZWxkIGZvciByZWFsIG1vbmV5IGFjY291bnQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmFkZHJlc3Nfc3RhdGUgLSBbT3B0aW9uYWxdIE5vdGU6IG5vdCBhcHBsaWNhYmxlIGZvciB2aXJ0dWFsIGFjY291bnQuIE9wdGlvbmFsIGZpZWxkIGZvciByZWFsIG1vbmV5IGFjY291bnQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmFsbG93X2NvcGllcnMgLSBbT3B0aW9uYWxdIEJvb2xlYW4gdmFsdWUgMSBvciAwLCBpbmRpY2F0aW5nIHBlcm1pc3Npb24gdG8gYWxsb3cgb3RoZXJzIHRvIGZvbGxvdyB5b3VyIHRyYWRlcy4gTm90ZTogbm90IGFwcGxpY2FibGUgZm9yIFZpcnR1YWwgYWNjb3VudC4gT25seSBhbGxvdyBmb3IgcmVhbCBtb25leSBhY2NvdW50LlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5jaXRpemVuIC0gW09wdGlvbmFsXSBDb3VudHJ5IG9mIGxlZ2FsIGNpdGl6ZW5zaGlwLCAyLWxldHRlciBjb3VudHJ5IGNvZGUuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmRhdGVfb2ZfYmlydGggLSBbT3B0aW9uYWxdIERhdGUgb2YgYmlydGggZm9ybWF0OiB5eXl5LW1tLWRkIChjYW4gb25seSBiZSBjaGFuZ2VkIG9uIHVuYXV0aGVudGljYXRlZCBzdmcgYWNjb3VudHMpLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5lbWFpbF9jb25zZW50IC0gW09wdGlvbmFsXSBCb29sZWFuIHZhbHVlIDEgb3IgMCwgaW5kaWNhdGluZyBwZXJtaXNzaW9uIHRvIHVzZSBlbWFpbCBhZGRyZXNzIGZvciBhbnkgY29udGFjdCB3aGljaCBtYXkgaW5jbHVkZSBtYXJrZXRpbmdcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MuZmVhdHVyZV9mbGFnIC1cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuZmlyc3RfbmFtZSAtIFtPcHRpb25hbF0gV2l0aGluIDItNTAgY2hhcmFjdGVycywgdXNlIG9ubHkgbGV0dGVycywgc3BhY2VzLCBoeXBoZW5zLCBmdWxsLXN0b3BzIG9yIGFwb3N0cm9waGVzIChjYW4gb25seSBiZSBjaGFuZ2VkIG9uIHVuYXV0aGVudGljYXRlZCBzdmcgYWNjb3VudHMpLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5sYXN0X25hbWUgLSBbT3B0aW9uYWxdIFdpdGhpbiAyLTUwIGNoYXJhY3RlcnMsIHVzZSBvbmx5IGxldHRlcnMsIHNwYWNlcywgaHlwaGVucywgZnVsbC1zdG9wcyBvciBhcG9zdHJvcGhlcyAoY2FuIG9ubHkgYmUgY2hhbmdlZCBvbiB1bmF1dGhlbnRpY2F0ZWQgc3ZnIGFjY291bnRzKS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3Mubm9uX3BlcF9kZWNsYXJhdGlvbiAtIFtPcHRpb25hbF0gSW5kaWNhdGVzIGNsaWVudCdzIHNlbGYtZGVjbGFyYXRpb24gb2Ygbm90IGJlaW5nIGEgUEVQL1JDQSAoUG9saXRpY2FsbHkgRXhwb3NlZCBQZXJzb24vUmVsYXRpdmVzIGFuZCBDbG9zZSBBc3NvY2lhdGVzKS4gRWZmZWN0aXZlIGZvciByZWFsIGFjY291bnRzIG9ubHkuXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGhvbmUgLSBbT3B0aW9uYWxdIE5vdGU6IG5vdCBhcHBsaWNhYmxlIGZvciB2aXJ0dWFsIGFjY291bnQuIFN0YXJ0aW5nIHdpdGggYCtgIGZvbGxvd2VkIGJ5IDktMzUgZGlnaXRzLCBoeXBoZW5zIG9yIHNwYWNlLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5wbGFjZV9vZl9iaXJ0aCAtIFtPcHRpb25hbF0gUGxhY2Ugb2YgYmlydGgsIDItbGV0dGVyIGNvdW50cnkgY29kZS5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucHJlZmVycmVkX2xhbmd1YWdlIC0gW09wdGlvbmFsXSBVc2VyJ3MgcHJlZmVycmVkIGxhbmd1YWdlLCBJU08gc3RhbmRhcmQgbGFuZ3VhZ2UgY29kZVxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcXVlc3RfcHJvZmVzc2lvbmFsX3N0YXR1cyAtIFtPcHRpb25hbF0gUmVxdWlyZWQgd2hlbiBjbGllbnQgd2FudHMgdG8gYmUgdHJlYXRlZCBhcyBwcm9mZXNzaW9uYWwuIEFwcGxpY2FibGUgZm9yIGZpbmFuY2lhbCBhY2NvdW50cyBvbmx5LlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5yZXNpZGVuY2UgLSBbT3B0aW9uYWxdIDItbGV0dGVyIGNvdW50cnkgY29kZS4gTm90ZTogbm90IGFwcGxpY2FibGUgZm9yIHJlYWwgbW9uZXkgYWNjb3VudC4gT25seSBhbGxvdyBmb3IgVmlydHVhbCBhY2NvdW50IHdpdGhvdXQgcmVzaWRlbmNlIHNldC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3Muc2FsdXRhdGlvbiAtIFtPcHRpb25hbF0gQWNjZXB0IGFueSB2YWx1ZSBpbiBlbnVtIGxpc3QgKGNhbiBvbmx5IGJlIGNoYW5nZWQgb24gdW5hdXRoZW50aWNhdGVkIHN2ZyBhY2NvdW50cykuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnNlY3JldF9hbnN3ZXIgLSBbT3B0aW9uYWxdIEFuc3dlciB0byBzZWNyZXQgcXVlc3Rpb24sIHdpdGhpbiA0LTUwIGNoYXJhY3RlcnMuIFJlcXVpcmVkIGZvciBuZXcgYWNjb3VudCBhbmQgZXhpc3RpbmcgY2xpZW50IGRldGFpbHMgd2lsbCBiZSB1c2VkIGlmIGNsaWVudCBvcGVucyBhbm90aGVyIGFjY291bnQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnNlY3JldF9xdWVzdGlvbiAtIFtPcHRpb25hbF0gQWNjZXB0IGFueSB2YWx1ZSBpbiBlbnVtIGxpc3QuIFJlcXVpcmVkIGZvciBuZXcgYWNjb3VudCBhbmQgZXhpc3RpbmcgY2xpZW50IGRldGFpbHMgd2lsbCBiZSB1c2VkIGlmIGNsaWVudCBvcGVucyBhbm90aGVyIGFjY291bnQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnNldF9zZXR0aW5ncyAtIE11c3QgYmUgYDFgXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnRheF9pZGVudGlmaWNhdGlvbl9udW1iZXIgLSBbT3B0aW9uYWxdIFRheCBpZGVudGlmaWNhdGlvbiBudW1iZXIuIE9ubHkgYXBwbGljYWJsZSBmb3IgcmVhbCBtb25leSBhY2NvdW50LiBSZXF1aXJlZCBmb3IgbWFsdGFpbnZlc3QgbGFuZGluZyBjb21wYW55LlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy50YXhfcmVzaWRlbmNlIC0gW09wdGlvbmFsXSBSZXNpZGVuY2UgZm9yIHRheCBwdXJwb3NlLiBDb21tYSBzZXBhcmF0ZWQgaXNvIGNvdW50cnkgY29kZSBpZiBtdWx0aXBsZSBqdXJpc2RpY3Rpb25zLiBPbmx5IGFwcGxpY2FibGUgZm9yIHJlYWwgbW9uZXkgYWNjb3VudC4gUmVxdWlyZWQgZm9yIG1hbHRhaW52ZXN0IGxhbmRpbmcgY29tcGFueS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInNldFNldHRpbmdzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNldHRpbmdzKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgYWNjb3VudF9vcGVuaW5nX3JlYXNvbjoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGFkZHJlc3NfY2l0eToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGFkZHJlc3NfbGluZV8xOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgYWRkcmVzc19saW5lXzI6IHt9LFxcbiAgICAgICAgYWRkcmVzc19wb3N0Y29kZToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGFkZHJlc3Nfc3RhdGU6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBhbGxvd19jb3BpZXJzOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGNpdGl6ZW46IHt9LFxcbiAgICAgICAgZGF0ZV9vZl9iaXJ0aDoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGVtYWlsX2NvbnNlbnQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgZmVhdHVyZV9mbGFnOiB7XFxuICAgICAgICAgIHdhbGxldDoge1xcbiAgICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgZmlyc3RfbmFtZToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGxhc3RfbmFtZToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIG5vbl9wZXBfZGVjbGFyYXRpb246IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcGhvbmU6IHt9LFxcbiAgICAgICAgcGxhY2Vfb2ZfYmlydGg6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBwcmVmZXJyZWRfbGFuZ3VhZ2U6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlcXVlc3RfcHJvZmVzc2lvbmFsX3N0YXR1czoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICByZXNpZGVuY2U6IHt9LFxcbiAgICAgICAgc2FsdXRhdGlvbjoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHNlY3JldF9hbnN3ZXI6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBzZWNyZXRfcXVlc3Rpb246IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBzZXRfc2V0dGluZ3M6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHRheF9pZGVudGlmaWNhdGlvbl9udW1iZXI6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICB0YXhfcmVzaWRlbmNlOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ3NldF9zZXR0aW5ncycsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuYWN0aW9uX3R5cGUgLSBbT3B0aW9uYWxdIFRvIGZpbHRlciB0aGUgc3RhdGVtZW50IGFjY29yZGluZyB0byB0aGUgdHlwZSBvZiB0cmFuc2FjdGlvbi5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuZGF0ZV9mcm9tIC0gW09wdGlvbmFsXSBTdGFydCBkYXRlIChlcG9jaClcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuZGF0ZV90byAtIFtPcHRpb25hbF0gRW5kIGRhdGUgKGVwb2NoKVxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5kZXNjcmlwdGlvbiAtIFtPcHRpb25hbF0gSWYgc2V0IHRvIDEsIHdpbGwgcmV0dXJuIGZ1bGwgY29udHJhY3RzIGRlc2NyaXB0aW9uLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5saW1pdCAtIFtPcHRpb25hbF0gTWF4aW11bSBudW1iZXIgb2YgdHJhbnNhY3Rpb25zIHRvIHJlY2VpdmUuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLm9mZnNldCAtIFtPcHRpb25hbF0gTnVtYmVyIG9mIHRyYW5zYWN0aW9ucyB0byBza2lwLlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3Muc3RhdGVtZW50IC0gTXVzdCBiZSBgMWBcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInN0YXRlbWVudFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGF0ZW1lbnQoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBhY3Rpb25fdHlwZToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGRhdGVfZnJvbToge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBkYXRlX3RvOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGRlc2NyaXB0aW9uOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGxpbWl0OiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIG9mZnNldDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgc3RhdGVtZW50OiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAnc3RhdGVtZW50JyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3Muc3RhdGVzX2xpc3QgLSBDbGllbnQncyAyLWxldHRlciBjb3VudHJ5IGNvZGUgKG9idGFpbmVkIGZyb20gYHJlc2lkZW5jZV9saXN0YCBjYWxsKVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwic3RhdGVzTGlzdFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGF0ZXNMaXN0KCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHN0YXRlc19saXN0OiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICdzdGF0ZXNfbGlzdCcsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnN1YnNjcmliZSAtIFtPcHRpb25hbF0gSWYgc2V0IHRvIDEsIHdpbGwgc2VuZCB1cGRhdGVzIHdoZW5ldmVyIGEgbmV3IHRpY2sgaXMgcmVjZWl2ZWQuXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnRpY2tzIC0gVGhlIHNob3J0IHN5bWJvbCBuYW1lIG9yIGFycmF5IG9mIHN5bWJvbHMgKG9idGFpbmVkIGZyb20gYGFjdGl2ZV9zeW1ib2xzYCBjYWxsKS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInRpY2tzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRpY2tzKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHN1YnNjcmliZToge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICB0aWNrczoge1xcbiAgICAgICAgICByZXF1aXJlZDogMVxcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICd0aWNrcycsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuYWRqdXN0X3N0YXJ0X3RpbWUgLSBbT3B0aW9uYWxdIDEgLSBpZiB0aGUgbWFya2V0IGlzIGNsb3NlZCBhdCB0aGUgZW5kIHRpbWUsIG9yIGxpY2Vuc2UgbGltaXQgaXMgYmVmb3JlIGVuZCB0aW1lLCBhZGp1c3QgaW50ZXJ2YWwgYmFja3dhcmRzIHRvIGNvbXBlbnNhdGUuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmNvdW50IC0gW09wdGlvbmFsXSBBbiB1cHBlciBsaW1pdCBvbiB0aWNrcyB0byByZWNlaXZlLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5lbmQgLSBFcG9jaCB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIGxhdGVzdCBib3VuZGFyeSBvZiB0aGUgcmV0dXJuZWQgdGlja3MuIElmIGBsYXRlc3RgIGlzIHNwZWNpZmllZCwgdGhpcyB3aWxsIGJlIHRoZSBsYXRlc3QgYXZhaWxhYmxlIHRpbWVzdGFtcC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuZ3JhbnVsYXJpdHkgLSBbT3B0aW9uYWxdIE9ubHkgYXBwbGljYWJsZSBmb3Igc3R5bGU6IGBjYW5kbGVzYC4gQ2FuZGxlIHRpbWUtZGltZW5zaW9uIHdpZHRoIHNldHRpbmcuIChkZWZhdWx0OiBgNjBgKS5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnN0YXJ0IC0gW09wdGlvbmFsXSBFcG9jaCB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIGVhcmxpZXN0IGJvdW5kYXJ5IG9mIHRoZSByZXR1cm5lZCB0aWNrcy5cXG4gICAgLSBGb3IgYFxcXCJzdHlsZVxcXCI6IFxcXCJ0aWNrc1xcXCJgOiB0aGlzIHdpbGwgZGVmYXVsdCB0byAxIGRheSBhZ28uXFxuICAgIC0gRm9yIGBcXFwic3R5bGVcXFwiOiBcXFwiY2FuZGxlc1xcXCJgOiBpdCB3aWxsIGRlZmF1bHQgdG8gMSBkYXkgYWdvIGlmIGNvdW50IG9yIGdyYW51bGFyaXR5IGlzIHVuZGVmaW5lZC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3Muc3R5bGUgLSBbT3B0aW9uYWxdIFRoZSB0aWNrLW91dHB1dCBzdHlsZS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3Muc3Vic2NyaWJlIC0gW09wdGlvbmFsXSAxIC0gdG8gc2VuZCB1cGRhdGVzIHdoZW5ldmVyIGEgbmV3IHRpY2sgaXMgcmVjZWl2ZWQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnRpY2tzX2hpc3RvcnkgLSBTaG9ydCBzeW1ib2wgbmFtZSAob2J0YWluZWQgZnJvbSB0aGUgYGFjdGl2ZV9zeW1ib2xzYCBjYWxsKS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInRpY2tzSGlzdG9yeVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aWNrc0hpc3RvcnkoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBhZGp1c3Rfc3RhcnRfdGltZToge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBjb3VudDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBlbmQ6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgZ3JhbnVsYXJpdHk6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHN0YXJ0OiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHN0eWxlOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgc3Vic2NyaWJlOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHRpY2tzX2hpc3Rvcnk6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ3RpY2tzX2hpc3RvcnknLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy50aW1lIC0gTXVzdCBiZSBgMWBcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInRpbWVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGltZSgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICB0aW1lOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAndGltZScsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnRuY19hcHByb3ZhbCAtIE11c3QgYmUgYDFgXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnVrZ2NfZnVuZHNfcHJvdGVjdGlvbiAtIFtPcHRpb25hbF0gRm9yIGBBU0tfVUtfRlVORFNfUFJPVEVDVElPTmAgaW4gYGNhc2hpZXJgLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidG5jQXBwcm92YWxcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG5jQXBwcm92YWwoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgdG5jX2FwcHJvdmFsOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICB1a2djX2Z1bmRzX3Byb3RlY3Rpb246IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ3RuY19hcHByb3ZhbCcsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnRvcHVwX3ZpcnR1YWwgLSBNdXN0IGJlIGAxYFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidG9wdXBWaXJ0dWFsXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvcHVwVmlydHVhbCgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICB0b3B1cF92aXJ0dWFsOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAndG9wdXBfdmlydHVhbCcsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MubGFuZGluZ19jb21wYW55IC0gW09wdGlvbmFsXSBJZiBzcGVjaWZpZWQsIHdpbGwgcmV0dXJuIG9ubHkgdGhlIHVuZGVybHlpbmdzIGZvciB0aGUgc3BlY2lmaWVkIGxhbmRpbmcgY29tcGFueS5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnRyYWRpbmdfZHVyYXRpb25zIC0gTXVzdCBiZSBgMWBcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInRyYWRpbmdEdXJhdGlvbnNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhZGluZ0R1cmF0aW9ucygpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGxhbmRpbmdfY29tcGFueToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICB0cmFkaW5nX2R1cmF0aW9uczoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ3RyYWRpbmdfZHVyYXRpb25zJyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnBsYXRmb3JtIC0gVHJhZGluZyBwbGF0Zm9ybSBuYW1lXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MudHJhZGluZ19wbGF0Zm9ybV9hY2NvdW50cyAtIE11c3QgYmUgYDFgXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ0cmFkaW5nUGxhdGZvcm1BY2NvdW50c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFkaW5nUGxhdGZvcm1BY2NvdW50cygpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHBsYXRmb3JtOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICB0cmFkaW5nX3BsYXRmb3JtX2FjY291bnRzOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAndHJhZGluZ19wbGF0Zm9ybV9hY2NvdW50cycsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuYW1vdW50IC0gQW1vdW50IHRvIGRlcG9zaXQgKGluIHRoZSBjdXJyZW5jeSBvZiBmcm9tX3dhbGxldCkuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmZyb21fYWNjb3VudCAtIFdhbGxldCBhY2NvdW50IHRvIHRyYW5zZmVyIG1vbmV5IGZyb20uXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MucGxhdGZvcm0gLSBOYW1lIG9mIHRyYWRpbmcgcGxhdGZvcm0uXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MudG9fYWNjb3VudCAtIFRyYWRpbmcgYWNjb3VudCBsb2dpbiB0byBkZXBvc2l0IG1vbmV5IHRvLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy50cmFkaW5nX3BsYXRmb3JtX2RlcG9zaXQgLSBNdXN0IGJlIGAxYFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidHJhZGluZ1BsYXRmb3JtRGVwb3NpdFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFkaW5nUGxhdGZvcm1EZXBvc2l0KCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgYW1vdW50OiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGZyb21fYWNjb3VudDoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHBsYXRmb3JtOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICB0b19hY2NvdW50OiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHRyYWRpbmdfcGxhdGZvcm1fZGVwb3NpdDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ3RyYWRpbmdfcGxhdGZvcm1fZGVwb3NpdCcsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuYWNjb3VudF9pZCAtIFRyYWRpbmcgYWNjb3VudCBJRC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MubmV3X3Bhc3N3b3JkIC0gTmV3IGludmVzdG9yIHBhc3N3b3JkLiBBY2NlcHRzIGFueSBwcmludGFibGUgQVNDSUkgY2hhcmFjdGVyLiBNdXN0IGJlIHdpdGhpbiA4LTI1IGNoYXJhY3RlcnMsIGFuZCBpbmNsdWRlIG51bWJlcnMsIGxvd2VyY2FzZSBhbmQgdXBwZXJjYXNlIGxldHRlcnMuIE11c3Qgbm90IGJlIHRoZSBzYW1lIGFzIHRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3Mub2xkX3Bhc3N3b3JkIC0gT2xkIGludmVzdG9yIHBhc3N3b3JkIGZvciB2YWxpZGF0aW9uIChub24tZW1wdHkgc3RyaW5nLCBhY2NlcHRzIGFueSBwcmludGFibGUgQVNDSUkgY2hhcmFjdGVyKVxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnBsYXRmb3JtIC0gTmFtZSBvZiB0cmFkaW5nIHBsYXRmb3JtLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnRyYWRpbmdfcGxhdGZvcm1faW52ZXN0b3JfcGFzc3dvcmRfY2hhbmdlIC0gTXVzdCBiZSBgMWBcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInRyYWRpbmdQbGF0Zm9ybUludmVzdG9yUGFzc3dvcmRDaGFuZ2VcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhZGluZ1BsYXRmb3JtSW52ZXN0b3JQYXNzd29yZENoYW5nZSgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGFjY291bnRfaWQ6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgbmV3X3Bhc3N3b3JkOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIG9sZF9wYXNzd29yZDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICBwbGF0Zm9ybToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgdHJhZGluZ19wbGF0Zm9ybV9pbnZlc3Rvcl9wYXNzd29yZF9jaGFuZ2U6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICd0cmFkaW5nX3BsYXRmb3JtX2ludmVzdG9yX3Bhc3N3b3JkX2NoYW5nZScsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuYWNjb3VudF9pZCAtIFRyYWRpbmcgYWNjb3VudCBJRC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MubmV3X3Bhc3N3b3JkIC0gTmV3IHBhc3N3b3JkIG9mIHRoZSBhY2NvdW50LiBGb3IgdmFsaWRhdGlvbiAoQWNjZXB0cyBhbnkgcHJpbnRhYmxlIEFTQ0lJIGNoYXJhY3Rlci4gTXVzdCBiZSB3aXRoaW4gOC0yNSBjaGFyYWN0ZXJzLCBhbmQgaW5jbHVkZSBudW1iZXJzLCBsb3dlcmNhc2UgYW5kIHVwcGVyY2FzZSBsZXR0ZXJzLiBNdXN0IG5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgdXNlcidzIGVtYWlsIGFkZHJlc3MpLlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnBsYXRmb3JtIC0gTmFtZSBvZiB0cmFkaW5nIHBsYXRmb3JtLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnRyYWRpbmdfcGxhdGZvcm1faW52ZXN0b3JfcGFzc3dvcmRfcmVzZXQgLSBNdXN0IGJlIGAxYFxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy52ZXJpZmljYXRpb25fY29kZSAtIEVtYWlsIHZlcmlmaWNhdGlvbiBjb2RlIChyZWNlaXZlZCBmcm9tIGEgYHZlcmlmeV9lbWFpbGAgY2FsbCwgd2hpY2ggbXVzdCBiZSBkb25lIGZpcnN0KVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidHJhZGluZ1BsYXRmb3JtSW52ZXN0b3JQYXNzd29yZFJlc2V0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYWRpbmdQbGF0Zm9ybUludmVzdG9yUGFzc3dvcmRSZXNldCgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGFjY291bnRfaWQ6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgbmV3X3Bhc3N3b3JkOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHBsYXRmb3JtOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICB0cmFkaW5nX3BsYXRmb3JtX2ludmVzdG9yX3Bhc3N3b3JkX3Jlc2V0OiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICB2ZXJpZmljYXRpb25fY29kZToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAndHJhZGluZ19wbGF0Zm9ybV9pbnZlc3Rvcl9wYXNzd29yZF9yZXNldCcsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuYWNjb3VudF90eXBlIC0gQWNjb3VudCB0eXBlLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5jdXJyZW5jeSAtIFtPcHRpb25hbF0gVHJhZGluZyBhY2NvdW50IGN1cnJlbmN5LCB0aGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHRoZSBxdWFsaWZpZWQgYWNjb3VudCBjdXJyZW5jeS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuZHJ5X3J1biAtIFtPcHRpb25hbF0gSWYgc2V0IHRvIDEsIG9ubHkgdmFsaWRhdGlvbiBpcyBwZXJmb3JtZWQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLm1hcmtldF90eXBlIC0gTWFya2V0IHR5cGVcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5wYXNzd29yZCAtIFRoZSBtYXN0ZXIgcGFzc3dvcmQgb2YgdGhlIGFjY291bnQuIEZvciB2YWxpZGF0aW9uIChBY2NlcHRzIGFueSBwcmludGFibGUgQVNDSUkgY2hhcmFjdGVyLiBNdXN0IGJlIHdpdGhpbiA4LTI1IGNoYXJhY3RlcnMsIGFuZCBpbmNsdWRlIG51bWJlcnMsIGxvd2VyY2FzZSBhbmQgdXBwZXJjYXNlIGxldHRlcnMuIE11c3Qgbm90IGJlIHRoZSBzYW1lIGFzIHRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcykuIFRoaXMgZmllbGQgaXMgcmVxdWlyZWQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnBsYXRmb3JtIC0gTmFtZSBvZiB0cmFkaW5nIHBsYXRmb3JtLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnN1Yl9hY2NvdW50X3R5cGUgLSBbT3B0aW9uYWxdIFN1YiBhY2NvdW50IHR5cGUuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnRyYWRpbmdfcGxhdGZvcm1fbmV3X2FjY291bnQgLSBNdXN0IGJlIGAxYFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidHJhZGluZ1BsYXRmb3JtTmV3QWNjb3VudFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFkaW5nUGxhdGZvcm1OZXdBY2NvdW50KCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgYWNjb3VudF90eXBlOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGN1cnJlbmN5OiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgZHJ5X3J1bjoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBtYXJrZXRfdHlwZToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICBwYXNzd29yZDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBwbGF0Zm9ybToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgc3ViX2FjY291bnRfdHlwZToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHRyYWRpbmdfcGxhdGZvcm1fbmV3X2FjY291bnQ6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICd0cmFkaW5nX3BsYXRmb3JtX25ld19hY2NvdW50JyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5uZXdfcGFzc3dvcmQgLSBOZXcgdHJhZGluZyBwYXNzd29yZC4gQWNjZXB0cyBhbnkgcHJpbnRhYmxlIEFTQ0lJIGNoYXJhY3Rlci4gTXVzdCBiZSB3aXRoaW4gOC0yNSBjaGFyYWN0ZXJzLCBhbmQgaW5jbHVkZSBudW1iZXJzLCBsb3dlcmNhc2UgYW5kIHVwcGVyY2FzZSBsZXR0ZXJzLiBNdXN0IG5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgdXNlcidzIGVtYWlsIGFkZHJlc3MuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLm9sZF9wYXNzd29yZCAtIE9sZCBwYXNzd29yZCBmb3IgdmFsaWRhdGlvbi4gTXVzdCBiZSBlbXB0eSBpZiBhIHBhc3N3b3JkIGhhcyBub3QgYmVlbiBzZXQgeWV0LlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnBsYXRmb3JtIC0gTmFtZSBvZiB0cmFkaW5nIHBsYXRmb3JtLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnRyYWRpbmdfcGxhdGZvcm1fcGFzc3dvcmRfY2hhbmdlIC0gTXVzdCBiZSBgMWBcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInRyYWRpbmdQbGF0Zm9ybVBhc3N3b3JkQ2hhbmdlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYWRpbmdQbGF0Zm9ybVBhc3N3b3JkQ2hhbmdlKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgbmV3X3Bhc3N3b3JkOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIG9sZF9wYXNzd29yZDoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHBsYXRmb3JtOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICB0cmFkaW5nX3BsYXRmb3JtX3Bhc3N3b3JkX2NoYW5nZToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ3RyYWRpbmdfcGxhdGZvcm1fcGFzc3dvcmRfY2hhbmdlJyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5uZXdfcGFzc3dvcmQgLSBOZXcgcGFzc3dvcmQgb2YgdGhlIGFjY291bnQuIEZvciB2YWxpZGF0aW9uIChBY2NlcHRzIGFueSBwcmludGFibGUgQVNDSUkgY2hhcmFjdGVyLiBNdXN0IGJlIHdpdGhpbiA4LTI1IGNoYXJhY3RlcnMsIGFuZCBpbmNsdWRlIG51bWJlcnMsIGxvd2VyY2FzZSBhbmQgdXBwZXJjYXNlIGxldHRlcnMuIE11c3Qgbm90IGJlIHRoZSBzYW1lIGFzIHRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcykuXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MucGxhdGZvcm0gLSBOYW1lIG9mIHRyYWRpbmcgcGxhdGZvcm0uXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MudHJhZGluZ19wbGF0Zm9ybV9wYXNzd29yZF9yZXNldCAtIE11c3QgYmUgYDFgXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnZlcmlmaWNhdGlvbl9jb2RlIC0gRW1haWwgdmVyaWZpY2F0aW9uIGNvZGUgKHJlY2VpdmVkIGZyb20gYSBgdmVyaWZ5X2VtYWlsYCBjYWxsLCB3aGljaCBtdXN0IGJlIGRvbmUgZmlyc3QpXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ0cmFkaW5nUGxhdGZvcm1QYXNzd29yZFJlc2V0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYWRpbmdQbGF0Zm9ybVBhc3N3b3JkUmVzZXQoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBuZXdfcGFzc3dvcmQ6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcGxhdGZvcm06IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHRyYWRpbmdfcGxhdGZvcm1fcGFzc3dvcmRfcmVzZXQ6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHZlcmlmaWNhdGlvbl9jb2RlOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICd0cmFkaW5nX3BsYXRmb3JtX3Bhc3N3b3JkX3Jlc2V0JyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5hbW91bnQgLSBBbW91bnQgdG8gd2l0aGRyYXcgKGluIHRoZSBjdXJyZW5jeSBvZiB0aGUgVHJhZGluZyBhY2NvdW50KS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuZnJvbV9hY2NvdW50IC0gVHJhZGluZyBhY2NvdW50IGxvZ2luIHRvIHdpdGhkcmF3IG1vbmV5IGZyb20uXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MucGxhdGZvcm0gLSBOYW1lIG9mIHRyYWRpbmcgcGxhdGZvcm0uXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MudG9fYWNjb3VudCAtIFdhbGxldCBhY2NvdW50IGxvZ2luaWQgdG8gdHJhbnNmZXIgbW9uZXkgdG8uXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnRyYWRpbmdfcGxhdGZvcm1fd2l0aGRyYXdhbCAtIE11c3QgYmUgYDFgXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ0cmFkaW5nUGxhdGZvcm1XaXRoZHJhd2FsXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYWRpbmdQbGF0Zm9ybVdpdGhkcmF3YWwoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBhbW91bnQ6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGZyb21fYWNjb3VudDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICBwbGF0Zm9ybToge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgdG9fYWNjb3VudDoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICB0cmFkaW5nX3BsYXRmb3JtX3dpdGhkcmF3YWw6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICd0cmFkaW5nX3BsYXRmb3JtX3dpdGhkcmF3YWwnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmFjY291bnRfdHlwZSAtIFtPcHRpb25hbF0gVHJhZGluZyBhY2NvdW50IHR5cGUuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmVudmlyb25tZW50IC0gW09wdGlvbmFsXSBQYXNzIHRoZSBlbnZpcm9ubWVudCAoaW5zdGFsbGF0aW9uKSBpbnN0YW5jZS4gQ3VycmVudGx5LCB0aGVyZSBhcmUgb25lIGRlbW8gYW5kIHR3byByZWFsIGVudmlyb25tZW50cy4gRGVmYXVsdHMgdG8gJ2FsbCcuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLm1hcmtldF90eXBlIC0gW09wdGlvbmFsXSBNYXJrZXQgdHlwZS5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5wbGF0Zm9ybSAtIFtPcHRpb25hbF0gUGFzcyB0aGUgdHJhZGluZyBwbGF0Zm9ybSBuYW1lLCBkZWZhdWx0IHRvIG10NVxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnRyYWRpbmdfc2VydmVycyAtIE11c3QgYmUgYDFgXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ0cmFkaW5nU2VydmVyc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFkaW5nU2VydmVycygpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIGFjY291bnRfdHlwZToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGVudmlyb25tZW50OiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgbWFya2V0X3R5cGU6IHtcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICBwbGF0Zm9ybToge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICB0cmFkaW5nX3NlcnZlcnM6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICd0cmFkaW5nX3NlcnZlcnMnLFxcbiAgICAgICAgbmVlZHNNZXRob2RBcmc6ICcxJyxcXG4gICAgICAgIGFyZ3M6IGFyZ3MsXFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3QoYWxsQXJncyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXFxuICAgICAqIEBwYXJhbSB7QW55fSBhcmdzLnBhc3N0aHJvdWdoIC0gW09wdGlvbmFsXSBVc2VkIHRvIHBhc3MgZGF0YSB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQsIHdoaWNoIG1heSBiZSByZXRyaWV2ZWQgdmlhIHRoZSBgZWNob19yZXFgIG91dHB1dCBmaWVsZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MucmVxX2lkIC0gW09wdGlvbmFsXSBVc2VkIHRvIG1hcCByZXF1ZXN0IHRvIHJlc3BvbnNlLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy50cmFkaW5nX3RpbWVzIC0gRGF0ZSB0byByZWNlaXZlIG1hcmtldCBvcGVuaW5nIHRpbWVzIGZvci4gKGB5eXl5LW1tLWRkYCBmb3JtYXQuIGB0b2RheWAgY2FuIGFsc28gYmUgc3BlY2lmaWVkKS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInRyYWRpbmdUaW1lc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFkaW5nVGltZXMoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgdHJhZGluZ190aW1lczoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHZhciBhbGxBcmdzID0ge1xcbiAgICAgICAgbWV0aG9kOiAndHJhZGluZ190aW1lcycsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnN1YnNjcmliZSAtIElmIHNldCB0byAxLCB3aWxsIHNlbmQgdXBkYXRlcyB3aGVuZXZlciB0aGVyZSBpcyBhbiB1cGRhdGUgdG8gdHJhbnNhY3Rpb25zLiBJZiBub3QgdG8gMSB0aGVuIGl0IHdpbGwgbm90IHJldHVybiBhbnkgcmVjb3Jkcy5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MudHJhbnNhY3Rpb24gLSBNdXN0IGJlIGAxYFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidHJhbnNhY3Rpb25cXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNhY3Rpb24oKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgICAgIHZhciBjb25maWcgPSB7XFxuICAgICAgICBwYXNzdGhyb3VnaDoge30sXFxuICAgICAgICByZXFfaWQ6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgc3Vic2NyaWJlOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICB0cmFuc2FjdGlvbjoge1xcbiAgICAgICAgICByZXF1aXJlZDogMSxcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ3RyYW5zYWN0aW9uJyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5hY2NvdW50X2Zyb20gLSBbT3B0aW9uYWxdIFRoZSBsb2dpbmlkIG9mIHRoZSBhY2NvdW50IHRvIHRyYW5zZmVyIGZ1bmRzIGZyb20uXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLmFjY291bnRfdG8gLSBbT3B0aW9uYWxdIFRoZSBsb2dpbmlkIG9mIHRoZSBhY2NvdW50IHRvIHRyYW5zZmVyIGZ1bmRzIHRvLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5hY2NvdW50cyAtIFtPcHRpb25hbF0gVG8gY29udHJvbCB0aGUgbGlzdCBvZiBhY2NvdW50cyByZXR1cm5lZCB3aGVuIGBhY2NvdW50X2Zyb21gIG9yIGBhY2NvdW50X3RvYCBpcyBub3QgcHJvdmlkZWQuIGBicmllZmAgKGRlZmF1bHQgdmFsdWUpIG1lYW5zIHRoYXQgYWNjb3VudHMgd2l0aCBgbXQ1YCBhY2NvdW50X3R5cGUgd2lsbCBiZSBleGNsdWRlZDsgaXQgd2lsbCBydW4gZmFzdGVyLiBgYWxsYCBtZWFucyB0aGF0IGFsbCBhY2NvdW50cyB3aXRoIGFueSBhY2NvdW50X3R5cGUgKGluY2x1ZGluZyBgbXQ1YCkgd2lsbCBiZSByZXR1cm5lZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MuYW1vdW50IC0gW09wdGlvbmFsXSBUaGUgYW1vdW50IHRvIHRyYW5zZmVyLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy5jdXJyZW5jeSAtIFtPcHRpb25hbF0gQ3VycmVuY3kgY29kZS5cXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnRyYW5zZmVyX2JldHdlZW5fYWNjb3VudHMgLSBJZiBgYWNjb3VudF9mcm9tYCBvciBgYWNjb3VudF90b2AgaXMgbm90IHByb3ZpZGVkLCBpdCBqdXN0IHJldHVybnMgdGhlIGF2YWlsYWJsZSBhY2NvdW50cy5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInRyYW5zZmVyQmV0d2VlbkFjY291bnRzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5zZmVyQmV0d2VlbkFjY291bnRzKCkge1xcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG4gICAgICB2YXIgY29uZmlnID0ge1xcbiAgICAgICAgYWNjb3VudF9mcm9tOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgYWNjb3VudF90bzoge1xcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGFjY291bnRzOiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgYW1vdW50OiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGN1cnJlbmN5OiB7XFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFzc3Rocm91Z2g6IHt9LFxcbiAgICAgICAgcmVxX2lkOiB7XFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHRyYW5zZmVyX2JldHdlZW5fYWNjb3VudHM6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICd0cmFuc2Zlcl9iZXR3ZWVuX2FjY291bnRzJyxcXG4gICAgICAgIG5lZWRzTWV0aG9kQXJnOiAnMScsXFxuICAgICAgICBhcmdzOiBhcmdzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWdcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KGFsbEFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy5wYXNzdGhyb3VnaCAtIFtPcHRpb25hbF0gVXNlZCB0byBwYXNzIGRhdGEgdGhyb3VnaCB0aGUgd2Vic29ja2V0LCB3aGljaCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGUgYGVjaG9fcmVxYCBvdXRwdXQgZmllbGQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnJlcV9pZCAtIFtPcHRpb25hbF0gVXNlZCB0byBtYXAgcmVxdWVzdCB0byByZXNwb25zZS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MudHlwZSAtIFB1cnBvc2Ugb2YgdGhlIGVtYWlsIHZlcmlmaWNhdGlvbiBjYWxsLlxcbiAgICAgKiBAcGFyYW0ge0FueX0gYXJncy51cmxfcGFyYW1ldGVycyAtXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmdzLnZlcmlmeV9lbWFpbCAtIEVtYWlsIGFkZHJlc3MgdG8gYmUgdmVyaWZpZWQuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ2ZXJpZnlFbWFpbFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2ZXJpZnlFbWFpbCgpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICB0eXBlOiB7XFxuICAgICAgICAgIHJlcXVpcmVkOiAxLFxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIHVybF9wYXJhbWV0ZXJzOiB7XFxuICAgICAgICAgIGFmZmlsaWF0ZV90b2tlbjoge1xcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIGRhdGVfZmlyc3RfY29udGFjdDoge1xcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIGdjbGlkX3VybDoge1xcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIHBhX2Ftb3VudDoge1xcbiAgICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBwYV9jdXJyZW5jeToge1xcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIHBhX2xvZ2luaWQ6IHtcXG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBwYV9yZW1hcmtzOiB7XFxuICAgICAgICAgICAgdHlwZTogJ3N0cmluZydcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgcmVkaXJlY3RfdG86IHtcXG4gICAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgc2lnbnVwX2RldmljZToge1xcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIHV0bV9hZF9pZDoge30sXFxuICAgICAgICAgIHV0bV9hZGdyb3VwX2lkOiB7fSxcXG4gICAgICAgICAgdXRtX2Fkcm9sbGNsa19pZDoge30sXFxuICAgICAgICAgIHV0bV9jYW1wYWlnbjoge30sXFxuICAgICAgICAgIHV0bV9jYW1wYWlnbl9pZDoge30sXFxuICAgICAgICAgIHV0bV9jb250ZW50OiB7fSxcXG4gICAgICAgICAgdXRtX2ZiY2xfaWQ6IHt9LFxcbiAgICAgICAgICB1dG1fZ2xfY2xpZW50X2lkOiB7fSxcXG4gICAgICAgICAgdXRtX21lZGl1bToge30sXFxuICAgICAgICAgIHV0bV9tc2Nsa19pZDoge30sXFxuICAgICAgICAgIHV0bV9zb3VyY2U6IHt9LFxcbiAgICAgICAgICB1dG1fdGVybToge31cXG4gICAgICAgIH0sXFxuICAgICAgICB2ZXJpZnlfZW1haWw6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB2YXIgYWxsQXJncyA9IHtcXG4gICAgICAgIG1ldGhvZDogJ3ZlcmlmeV9lbWFpbCcsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcXG4gICAgICogQHBhcmFtIHtBbnl9IGFyZ3MucGFzc3Rocm91Z2ggLSBbT3B0aW9uYWxdIFVzZWQgdG8gcGFzcyBkYXRhIHRocm91Z2ggdGhlIHdlYnNvY2tldCwgd2hpY2ggbWF5IGJlIHJldHJpZXZlZCB2aWEgdGhlIGBlY2hvX3JlcWAgb3V0cHV0IGZpZWxkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJncy5yZXFfaWQgLSBbT3B0aW9uYWxdIFVzZWQgdG8gbWFwIHJlcXVlc3QgdG8gcmVzcG9uc2UuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLnN1YnNjcmliZSAtIFtPcHRpb25hbF0gYDFgIHRvIHN0cmVhbSB0aGUgc2VydmVyL3dlYnNpdGUgc3RhdHVzIHVwZGF0ZXMuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLndlYnNpdGVfc3RhdHVzIC0gTXVzdCBiZSBgMWBcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIndlYnNpdGVTdGF0dXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2Vic2l0ZVN0YXR1cygpIHtcXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuICAgICAgdmFyIGNvbmZpZyA9IHtcXG4gICAgICAgIHBhc3N0aHJvdWdoOiB7fSxcXG4gICAgICAgIHJlcV9pZDoge1xcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYydcXG4gICAgICAgIH0sXFxuICAgICAgICBzdWJzY3JpYmU6IHtcXG4gICAgICAgICAgdHlwZTogJ251bWVyaWMnXFxuICAgICAgICB9LFxcbiAgICAgICAgd2Vic2l0ZV9zdGF0dXM6IHtcXG4gICAgICAgICAgcmVxdWlyZWQ6IDEsXFxuICAgICAgICAgIHR5cGU6ICdudW1lcmljJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgdmFyIGFsbEFyZ3MgPSB7XFxuICAgICAgICBtZXRob2Q6ICd3ZWJzaXRlX3N0YXR1cycsXFxuICAgICAgICBuZWVkc01ldGhvZEFyZzogJzEnLFxcbiAgICAgICAgYXJnczogYXJncyxcXG4gICAgICAgIGNvbmZpZzogY29uZmlnXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdChhbGxBcmdzKTtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJwcm9jZXNzUmVxdWVzdFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzUmVxdWVzdChhbGxBcmdzKSB7XFxuICAgICAgdmFyIGNvbmZpZyA9IGFsbEFyZ3MuY29uZmlnO1xcbiAgICAgIHZhciBwYXJzZWRBcmdzID0gcGFyc2VBcmdzKGFsbEFyZ3MpO1xcbiAgICAgIHZhciBlcnJvciA9IHZhbGlkYXRlQXJncyh7XFxuICAgICAgICBjb25maWc6IGNvbmZpZyxcXG4gICAgICAgIGFyZ3M6IHBhcnNlZEFyZ3NcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAoZXJyb3IpIHtcXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzLnNlbmQocGFyc2VkQXJncyk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBEZXJpdkFQSUNhbGxzO1xcbn0oKTsgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4vLyAtLS0tLSBIZWxwZXIgTWV0aG9kcyAtLS0tLVxcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09XFxuXFxuXFxuXFxuXFxudmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcXG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdDtcXG59O1xcblxcbnZhciB0eXBlQ2hlY2tlcnMgPSB7XFxuICBvYmplY3Q6IGlzT2JqZWN0LFxcbiAgbnVtZXJpYzogZnVuY3Rpb24gbnVtZXJpYyh2YWx1ZSkge1xcbiAgICByZXR1cm4gIU51bWJlci5pc05hTih2YWx1ZSAqIDEpO1xcbiAgfSxcXG4gIHN0cmluZzogZnVuY3Rpb24gc3RyaW5nKHZhbHVlKSB7XFxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xcbiAgfSxcXG4gIFxcXCJib29sZWFuXFxcIjogZnVuY3Rpb24gYm9vbGVhbih2YWx1ZSkge1xcbiAgICByZXR1cm4gW3RydWUsIGZhbHNlLCAwLCAxXS5pbmNsdWRlcyh2YWx1ZSk7XFxuICB9XFxufTtcXG5cXG5mdW5jdGlvbiBwYXJzZUFyZ3MoX3JlZikge1xcbiAgdmFyIGNvbmZpZyA9IF9yZWYuY29uZmlnLFxcbiAgICAgIGFyZ3MgPSBfcmVmLmFyZ3MsXFxuICAgICAgbWV0aG9kID0gX3JlZi5tZXRob2QsXFxuICAgICAgbmVlZHNNZXRob2RBcmcgPSBfcmVmLm5lZWRzTWV0aG9kQXJnO1xcbiAgdmFyIHBhcnNlZEFyZ3MgPSBhcmdzO1xcblxcbiAgaWYgKG5lZWRzTWV0aG9kQXJnICYmICFpc09iamVjdChwYXJzZWRBcmdzKSkge1xcbiAgICBwYXJzZWRBcmdzID0gKDAsX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmRlZmF1bHQpKHt9LCBtZXRob2QsIHBhcnNlZEFyZ3MpO1xcbiAgfVxcblxcbiAgcGFyc2VkQXJnc1ttZXRob2RdID0gcGFyc2VkQXJnc1ttZXRob2RdIHx8IDE7XFxuICBPYmplY3Qua2V5cyhwYXJzZWRBcmdzKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xcbiAgICB2YXIgdmFsdWUgPSBwYXJzZWRBcmdzW3BhcmFtXTtcXG4gICAgaWYgKCEocGFyYW0gaW4gY29uZmlnKSkgcmV0dXJuO1xcblxcbiAgICBpZiAoY29uZmlnW3BhcmFtXS50eXBlID09PSAnc3RyaW5nJykge1xcbiAgICAgIHBhcnNlZEFyZ3NbcGFyYW1dID0gXFxcIlxcXCIuY29uY2F0KHZhbHVlKTtcXG4gICAgfSBlbHNlIGlmIChjb25maWdbcGFyYW1dLnR5cGUgPT09ICdudW1lcmljJykge1xcbiAgICAgIHBhcnNlZEFyZ3NbcGFyYW1dID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcXG4gICAgfSBlbHNlIGlmIChjb25maWdbcGFyYW1dLnR5cGUgPT09ICdib29sZWFuJykge1xcbiAgICAgIHBhcnNlZEFyZ3NbcGFyYW1dID0gK3ZhbHVlO1xcbiAgICB9XFxuICB9KTtcXG4gIHJldHVybiBwYXJzZWRBcmdzO1xcbn1cXG5cXG5mdW5jdGlvbiB2YWxpZGF0ZUFyZ3MoX3JlZjIpIHtcXG4gIHZhciBjb25maWcgPSBfcmVmMi5jb25maWcsXFxuICAgICAgYXJncyA9IF9yZWYyLmFyZ3M7XFxuXFxuICBpZiAoIWlzT2JqZWN0KGFyZ3MpKSB7XFxuICAgIHJldHVybiBcXFwiUmVxdWlyZXMgYW4gb2JqZWN0IGJ1dCBhIFxcXCIuY29uY2F0KCgwLF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfdHlwZW9mX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZGVmYXVsdCkoYXJncyksIFxcXCIgaXMgcGFzc2VkLlxcXCIpO1xcbiAgfVxcblxcbiAgdmFyIGVycm9yTWVzc2FnZXMgPSBbXTtcXG4gIHZhciBtaXNzaW5nID0gT2JqZWN0LmtleXMoY29uZmlnKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xcbiAgICByZXR1cm4gKGNvbmZpZ1trZXldIHx8IHt9KS5yZXF1aXJlZCAmJiAhKGtleSBpbiBhcmdzKTtcXG4gIH0pO1xcblxcbiAgaWYgKG1pc3NpbmcubGVuZ3RoKSB7XFxuICAgIGVycm9yTWVzc2FnZXMucHVzaChcXFwiUmVxdWlyZWQgcGFyYW1ldGVycyBtaXNzaW5nOiBcXFwiLmNvbmNhdChtaXNzaW5nLmpvaW4oJywgJykpKTtcXG4gIH1cXG5cXG4gIE9iamVjdC5rZXlzKGFyZ3MpLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XFxuICAgIHZhciB2YWx1ZSA9IGFyZ3NbcGFyYW1dO1xcbiAgICBpZiAoIShwYXJhbSBpbiBjb25maWcpKSByZXR1cm47XFxuICAgIHZhciBleHBlY3RlZFR5cGUgPSBjb25maWdbcGFyYW1dLnR5cGU7XFxuICAgIGlmICghZXhwZWN0ZWRUeXBlKSByZXR1cm47XFxuXFxuICAgIGlmICghdHlwZUNoZWNrZXJzW2V4cGVjdGVkVHlwZV0odmFsdWUpKSB7XFxuICAgICAgZXJyb3JNZXNzYWdlcy5wdXNoKFxcXCJcXFwiLmNvbmNhdChleHBlY3RlZFR5cGUsIFxcXCIgdmFsdWUgZXhwZWN0ZWQgYnV0IGZvdW5kIFxcXCIpLmNvbmNhdCgoMCxfYmFiZWxfcnVudGltZV9oZWxwZXJzX3R5cGVvZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmRlZmF1bHQpKHZhbHVlKSwgXFxcIjogXFxcIikuY29uY2F0KHBhcmFtKSk7XFxuICAgIH1cXG4gIH0pO1xcbiAgcmV0dXJuIGVycm9yTWVzc2FnZXMubGVuZ3RoID8gZXJyb3JNZXNzYWdlcy5qb2luKCcgLSAnKSA6ICcnO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9EZXJpdkFQSUJhc2ljLy4vc3JjL2Rlcml2X2FwaS9EZXJpdkFQSUNhbGxzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVyaXZfYXBpL0luTWVtb3J5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kZXJpdl9hcGkvSW5NZW1vcnkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5NZW1vcnkpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfY2xhc3NDYWxsQ2hlY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2sgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfY3JlYXRlQ2xhc3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzLmpzXFxcIik7XFxuXFxuXFxuXFxuLyoqXFxuICogQW4gaW4gbWVtb3J5IHN0b3JhZ2Ugd2hpY2ggY2FuIGJlIHVzZWQgZm9yIGNhY2hpbmdcXG4gKi9cXG52YXIgSW5NZW1vcnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gSW5NZW1vcnkoKSB7XFxuICAgICgwLF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfY2xhc3NDYWxsQ2hlY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5kZWZhdWx0KSh0aGlzLCBJbk1lbW9yeSk7XFxuXFxuICAgIHRoaXMuc3RvcmUgPSB7XFxuICAgICAgYnlfbXNnX3R5cGU6IHt9XFxuICAgIH07XFxuICB9XFxuXFxuICAoMCxfYmFiZWxfcnVudGltZV9oZWxwZXJzX2NyZWF0ZUNsYXNzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uZGVmYXVsdCkoSW5NZW1vcnksIFt7XFxuICAgIGtleTogXFxcImhhc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXMoa2V5KSB7XFxuICAgICAgcmV0dXJuIGtleSBpbiB0aGlzLnN0b3JlO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcImdldFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoa2V5KSB7XFxuICAgICAgcmV0dXJuIHRoaXMuc3RvcmVba2V5XTtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJnZXRCeU1zZ1R5cGVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QnlNc2dUeXBlKHR5cGUpIHtcXG4gICAgICByZXR1cm4gdGhpcy5zdG9yZS5ieV9tc2dfdHlwZVt0eXBlXTtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJzZXRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcXG4gICAgICB0aGlzLnN0b3JlLmJ5X21zZ190eXBlW3ZhbHVlLm1zZ190eXBlXSA9IHZhbHVlO1xcbiAgICAgIHRoaXMuc3RvcmVba2V5XSA9IHZhbHVlO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gSW5NZW1vcnk7XFxufSgpO1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9zcmMvZGVyaXZfYXBpL0luTWVtb3J5LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVyaXZfYXBpL1N1YnNjcmlwdGlvbk1hbmFnZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVyaXZfYXBpL1N1YnNjcmlwdGlvbk1hbmFnZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBTdWJzY3JpcHRpb25NYW5hZ2VyKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmFiZWxfcnVudGltZV9oZWxwZXJzX2RlZmluZVByb3BlcnR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmFiZWxfcnVudGltZV9oZWxwZXJzX2NsYXNzQ2FsbENoZWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjay5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmFiZWxfcnVudGltZV9oZWxwZXJzX2NyZWF0ZUNsYXNzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciByeGpzX29wZXJhdG9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcnhqcy9vcGVyYXRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29wZXJhdG9ycy9maW5hbGl6ZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciByeGpzX29wZXJhdG9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcnhqcy9vcGVyYXRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29wZXJhdG9ycy9zaGFyZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciByeGpzX29wZXJhdG9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcnhqcy9vcGVyYXRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29wZXJhdG9ycy9maXJzdC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Vycm9ycyAqLyBcXFwiLi9zcmMvZGVyaXZfYXBpL2Vycm9ycy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMgKi8gXFxcIi4vc3JjL2Rlcml2X2FwaS91dGlscy5qc1xcXCIpO1xcblxcblxcblxcblxcbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxcblxcbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5kZWZhdWx0KSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxcblxcblxcblxcblxcbi8qKlxcbiAqIFN1YnNjcmlwdGlvbiBNYW5hZ2VyIC0gbWFuYWdlIHN1YnNjcmlwdGlvbiBjaGFubmVsc1xcbiAqXFxuICogTWFrZXMgc3VyZSB0aGVyZSBpcyBhbHdheXMgb25seSBvbmUgc3Vic2NyaXB0aW9uIGNoYW5uZWwgZm9yIGFsbCByZXF1ZXN0cyBvZlxcbiAqIHN1YnNjcmlwdGlvbnMsIGtlZXBzIGEgaGlzdG9yeSBvZiByZWNlaXZlZCB2YWx1ZXMgZm9yIHRoZSBzdWJzY3JpcHRpb24gb2YgdGlja3NcXG4gKiBhbmQgZm9yZ2V0cyBjaGFubmVscyB0aGF0IGRvIG5vdCBoYXZlIHN1YnNjcmliZXJzLiBJdCBhbHNvIGVuc3VyZXMgdGhhdFxcbiAqIHN1YnNjcmlwdGlvbnMgYXJlIHJldml2ZWQgYWZ0ZXIgY29ubmVjdGlvbiBkcm9wL2FjY291bnQgY2hhbmdlZC5cXG4gKlxcbiAqXFxuICogQGV4YW1wbGVcXG4gKiAvLyBUaGlzIG9uZSBjcmVhdGVzIGEgbmV3IHN1YnNjcmlwdGlvbiBhc3N1bWluZyBpdCBpcyB0aGUgZmlyc3Qgb25lIGZvciBSXzEwMFxcbiAqIGNvbnN0IHN1YnNjcmliZXIxID0gYXBpLnN1YnNjcmliZSh7IHRpY2tzOiAnUl8xMDAnIH0sIGNvbnNvbGUubG9nKTtcXG4gKlxcbiAqIC8vIFRoaXMgb25lIHVzZXMgdGhlIGV4aXN0aW5nIHN1YnNjcmlwdGlvbiB0byBSXzEwMFxcbiAqIGNvbnN0IHN1YnNjcmliZXIyID0gYXBpLnN1YnNjcmliZSh7IHRpY2tzOiAnUl8xMDAnIH0sIGNvbnNvbGUubG9nKTtcXG4gKlxcbiAqIHN1YnNjcmliZXIxLnVuc3Vic2NyaWJlKCk7IC8vIG5vIEFQSSBmb3JnZXQgeWV0XFxuICogc3Vic2NyaWJlcjIudW5zdWJzY3JpYmUoKTsgLy8gSXNzdWVzIEFQSSBmb3JnZXRcXG4gKlxcbiAqL1xcblxcbnZhciBTdWJzY3JpcHRpb25NYW5hZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcXG4gIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbk1hbmFnZXIoYXBpKSB7XFxuICAgICgwLF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfY2xhc3NDYWxsQ2hlY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5kZWZhdWx0KSh0aGlzLCBTdWJzY3JpcHRpb25NYW5hZ2VyKTtcXG5cXG4gICAgdGhpcy5hcGkgPSBhcGk7XFxuICAgIHRoaXMuc291cmNlcyA9IHt9O1xcbiAgICB0aGlzLnN1YnNfaWRfdG9fa2V5ID0ge307XFxuICAgIHRoaXMua2V5X3RvX3N1YnNfaWQgPSB7fTtcXG4gICAgdGhpcy5idXlfa2V5X3RvX2NvbnRyYWN0X2lkID0ge307XFxuICAgIHRoaXMuc3Vic19wZXJfbXNnX3R5cGUgPSBbXTsgLy8gc3RyZWFtc19saXN0IGlzIHRoZSBsaXN0IG9mIHN1YnNjcmlwdGlvbnMgbXNnX3R5cGVzIGF2YWlsYWJsZS5cXG4gICAgLy8gUGxlYXNlIGFkZC9yZW1vdmUgYmFzZWQgb24gY3VycmVudCBhdmFpbGFibGUgc3RyZWFtcyBpbiBhcGkuXFxuICAgIC8vIFJlZmVyIGh0dHBzOi8vZGV2ZWxvcGVycy5iaW5hcnkuY29tL1xcblxcbiAgICB0aGlzLnN0cmVhbXNfbGlzdCA9IFsnYmFsYW5jZScsICdjYW5kbGVzJywgJ3AycF9hZHZlcnRpc2VyJywgJ3AycF9vcmRlcicsICdwcm9wb3NhbCcsICdwcm9wb3NhbF9hcnJheScsICdwcm9wb3NhbF9vcGVuX2NvbnRyYWN0JywgJ3RpY2tzJywgJ3RpY2tzX2hpc3RvcnknLCAndHJhbnNhY3Rpb24nLCAnd2Vic2l0ZV9zdGF0dXMnXTtcXG4gIH1cXG4gIC8qKlxcbiAgICogU3Vic2NyaWJlIHRvIGEgZ2l2ZW4gcmVxdWVzdCwgcmV0dXJucyBhIHN0cmVhbSBvZiBuZXcgcmVzcG9uc2VzLFxcbiAgICogRXJyb3JzIHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoZSB1c2VyIG9mIHRoZSBzdHJlYW1cXG4gICAqXFxuICAgKiBAZXhhbXBsZVxcbiAgICogY29uc3QgdGlja3MgPSBhcGkuc3Vic2NyaWJlKHsgdGlja3M6ICdSXzEwMCcgfSk7XFxuICAgKiB0aWNrcy5zdWJzY3JpYmUoY29uc29sZS5sb2cpIC8vIFByaW50IGV2ZXJ5IG5ldyB0aWNrXFxuICAgKlxcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3QgLSBBIHJlcXVlc3Qgb2JqZWN0IGFjY2VwdGFibGUgYnkgdGhlIEFQSVxcbiAgICpcXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSAtIEFuIFJ4SlMgT2JzZXJ2YWJsZVxcbiAgICovXFxuXFxuXFxuICAoMCxfYmFiZWxfcnVudGltZV9oZWxwZXJzX2NyZWF0ZUNsYXNzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uZGVmYXVsdCkoU3Vic2NyaXB0aW9uTWFuYWdlciwgW3tcXG4gICAga2V5OiBcXFwic3Vic2NyaWJlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnNjcmliZShyZXF1ZXN0KSB7XFxuICAgICAgaWYgKHRoaXMuc291cmNlRXhpc3RzKHJlcXVlc3QpKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTb3VyY2UocmVxdWVzdCk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU5ld1NvdXJjZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJlcXVlc3QpLCB7fSwge1xcbiAgICAgICAgc3Vic2NyaWJlOiAxXFxuICAgICAgfSkpO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcImdldFNvdXJjZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTb3VyY2UocmVxdWVzdCkge1xcbiAgICAgIHZhciBrZXkgPSB0b0tleShyZXF1ZXN0KTtcXG4gICAgICBpZiAoa2V5IGluIHRoaXMuc291cmNlcykgcmV0dXJuIHRoaXMuc291cmNlc1trZXldOyAvLyBJZiB3ZSBoYXZlIGEgYnV5IHN1YnNjcmlwdGlvbiByZXVzZSB0aGF0IGZvciBwb2NcXG5cXG4gICAgICBpZiAocmVxdWVzdC5wcm9wb3NhbF9vcGVuX2NvbnRyYWN0ICYmIHJlcXVlc3QuY29udHJhY3RfaWQpIHtcXG4gICAgICAgIHZhciBwb2Nfc291cmNlID0gT2JqZWN0LnZhbHVlcyh0aGlzLmJ1eV9rZXlfdG9fY29udHJhY3RfaWQpLmZpbmQoZnVuY3Rpb24gKGMpIHtcXG4gICAgICAgICAgcmV0dXJuIGMuY29udHJhY3RfaWQgPT09IHJlcXVlc3QuY29udHJhY3RfaWQ7XFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIGlmIChwb2Nfc291cmNlKSB7XFxuICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNbcG9jX3NvdXJjZS5idXlfa2V5XTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcXG4gICAgfSAvLyBKdXN0IGFuIGFsaWFzIHRvIGdldFNvdXJjZVxcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJzb3VyY2VFeGlzdHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc291cmNlRXhpc3RzKHJlcXVlc3QpIHtcXG4gICAgICByZXR1cm4gdGhpcy5nZXRTb3VyY2UocmVxdWVzdCk7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiY3JlYXRlTmV3U291cmNlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZU5ld1NvdXJjZShyZXF1ZXN0KSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB2YXIga2V5ID0gdG9LZXkocmVxdWVzdCk7XFxuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuYXBpLnNlbmRBbmRHZXRTb3VyY2UocmVxdWVzdCkucGlwZSgoMCxyeGpzX29wZXJhdG9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLmZpbmFsaXplKShmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAoIShrZXkgaW4gX3RoaXMua2V5X3RvX3N1YnNfaWQpKSByZXR1cm47IC8vIEZvcmdldCBzdWJzY3JpcHRpb25zLCBidXQgZG9uJ3QgY29tcGxhaW4gaWYgZmFpbGVkXFxuXFxuICAgICAgICBfdGhpcy5mb3JnZXQoX3RoaXMua2V5X3RvX3N1YnNfaWRba2V5XSkudGhlbihmdW5jdGlvbiAoKSB7fSwgZnVuY3Rpb24gKCkge30pO1xcbiAgICAgIH0pLCAoMCxyeGpzX29wZXJhdG9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLnNoYXJlKSgpKTtcXG4gICAgICB0aGlzLnNvdXJjZXNba2V5XSA9IHNvdXJjZTtcXG4gICAgICB0aGlzLnNhdmVTdWJzUGVyTXNnVHlwZShyZXF1ZXN0LCBrZXkpO1xcbiAgICAgIHNvdXJjZS5waXBlKCgwLHJ4anNfb3BlcmF0b3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18uZmlyc3QpKCkpLnRvUHJvbWlzZSgpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XFxuICAgICAgICBpZiAocmVxdWVzdC5idXkpIHtcXG4gICAgICAgICAgX3RoaXMuYnV5X2tleV90b19jb250cmFjdF9pZFtrZXldID0ge1xcbiAgICAgICAgICAgIGNvbnRyYWN0X2lkOiByZXNwb25zZS5idXkuY29udHJhY3RfaWQsXFxuICAgICAgICAgICAgYnV5X2tleToga2V5XFxuICAgICAgICAgIH07XFxuICAgICAgICB9XFxuXFxuICAgICAgICBfdGhpcy5zYXZlU3Vic0lkKGtleSwgcmVzcG9uc2UpO1xcbiAgICAgIH0sIHRoaXMucmVtb3ZlS2V5T25FcnJvcihrZXkpKTtcXG4gICAgICByZXR1cm4gc291cmNlO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcImZvcmdldFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JnZXQoaWQpIHtcXG4gICAgICB0aGlzLmNvbXBsZXRlU3Vic0J5SWRzKGlkKTtcXG4gICAgICByZXR1cm4gdGhpcy5hcGkuc2VuZCh7XFxuICAgICAgICBmb3JnZXQ6IGlkXFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZm9yZ2V0QWxsXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcmdldEFsbCgpIHtcXG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcXG5cXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XFxuICAgICAgICB0eXBlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcXG4gICAgICB9XFxuXFxuICAgICAgLy8gVG8gaW5jbHVkZSBzdWJzY3JpcHRpb25zIHRoYXQgd2VyZSBhdXRvbWF0aWNhbGx5IHVuc3Vic2NyaWJlZFxcbiAgICAgIC8vIGZvciBleGFtcGxlIGEgcHJvcG9zYWwgc3Vic2NyaXB0aW9uIGlzIGF1dG8tdW5zdWJzY3JpYmVkIGFmdGVyIGJ1eVxcbiAgICAgIHR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcXG4gICAgICAgIChfdGhpczIuc3Vic19wZXJfbXNnX3R5cGVbdHlwZV0gfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLmNvbXBsZXRlU3Vic0J5S2V5KGtleSk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIF90aGlzMi5zdWJzX3Blcl9tc2dfdHlwZVt0eXBlXSA9IFtdO1xcbiAgICAgIH0pO1xcbiAgICAgIHJldHVybiB0aGlzLmFwaS5zZW5kKHtcXG4gICAgICAgIGZvcmdldF9hbGw6IHR5cGVzXFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiY29tcGxldGVTdWJzQnlJZHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGxldGVTdWJzQnlJZHMoKSB7XFxuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XFxuXFxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBzdWJzX2lkcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xcbiAgICAgICAgc3Vic19pZHNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcXG4gICAgICB9XFxuXFxuICAgICAgc3Vic19pZHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcXG4gICAgICAgIHZhciBrZXkgPSBfdGhpczMuc3Vic19pZF90b19rZXlbaWRdO1xcbiAgICAgICAgZGVsZXRlIF90aGlzMy5zdWJzX2lkX3RvX2tleVtpZF07XFxuXFxuICAgICAgICBfdGhpczMuY29tcGxldGVTdWJzQnlLZXkoa2V5KTtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJzYXZlU3Vic0lkXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNhdmVTdWJzSWQoa2V5LCBfcmVmKSB7XFxuICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IF9yZWYuc3Vic2NyaXB0aW9uO1xcbiAgICAgIC8vIElmIHRoZSByZXNwb25zZSBkb2Vzbid0IGhhdmUgYSBzdWJzIGlkLCBpdCdzIG5vdCBhIHN1YnNjcmlwdGlvbiwgc28gY29tcGxldGUgc291cmNlXFxuICAgICAgLy8gVXNlZnVsIGZvciBwb2MgZm9yIHNvbGQgY29udHJhY3Qgd2hpY2ggbmV2ZXIgcmV0dXJucyBzdWJzY3JpcHRpb25cXG4gICAgICBpZiAoIXN1YnNjcmlwdGlvbikgcmV0dXJuIHRoaXMuY29tcGxldGVTdWJzQnlLZXkoa2V5KTtcXG4gICAgICB2YXIgaWQgPSBzdWJzY3JpcHRpb24uaWQ7XFxuXFxuICAgICAgaWYgKCEoaWQgaW4gdGhpcy5zdWJzX2lkX3RvX2tleSkpIHtcXG4gICAgICAgIHRoaXMuc3Vic19pZF90b19rZXlbaWRdID0ga2V5O1xcbiAgICAgICAgdGhpcy5rZXlfdG9fc3Vic19pZFtrZXldID0gaWQ7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwic2F2ZVN1YnNQZXJNc2dUeXBlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNhdmVTdWJzUGVyTXNnVHlwZShyZXF1ZXN0LCBrZXkpIHtcXG4gICAgICB2YXIgbXNnX3R5cGUgPSB0aGlzLmdldE1zZ1R5cGUocmVxdWVzdCk7XFxuXFxuICAgICAgaWYgKG1zZ190eXBlKSB7XFxuICAgICAgICB0aGlzLnN1YnNfcGVyX21zZ190eXBlW21zZ190eXBlXSA9IHRoaXMuc3Vic19wZXJfbXNnX3R5cGVbbXNnX3R5cGVdIHx8IFtdO1xcbiAgICAgICAgdGhpcy5zdWJzX3Blcl9tc2dfdHlwZVttc2dfdHlwZV0ucHVzaChrZXkpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLmFwaS5zYW5pdHlFcnJvcnMubmV4dChuZXcgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLkFQSUVycm9yKCdTdWJzY3JpcHRpb24gdHlwZSBpcyBub3QgZm91bmQgaW4gZGVyaXYtYXBpJykpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJyZW1vdmVLZXlPbkVycm9yXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUtleU9uRXJyb3Ioa2V5KSB7XFxuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XFxuXFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiBfdGhpczQuY29tcGxldGVTdWJzQnlLZXkoa2V5KTtcXG4gICAgICB9O1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcImNvbXBsZXRlU3Vic0J5S2V5XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBsZXRlU3Vic0J5S2V5KGtleSkge1xcbiAgICAgIGlmICgha2V5IHx8ICF0aGlzLnNvdXJjZXNba2V5XSkgcmV0dXJuOyAvLyBEZWxldGUgdGhlIHNvdXJjZVxcblxcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZXNba2V5XTtcXG4gICAgICBkZWxldGUgdGhpcy5zb3VyY2VzW2tleV07IC8vIERlbGV0ZSB0aGUgc3VicyBpZCBpZiBleGlzdHNcXG5cXG4gICAgICB2YXIgc3Vic19pZCA9IHRoaXMua2V5X3RvX3N1YnNfaWRba2V5XTtcXG4gICAgICBkZWxldGUgdGhpcy5zdWJzX2lkX3RvX2tleVtzdWJzX2lkXTsgLy8gRGVsZXRlIHRoZSBrZXlcXG5cXG4gICAgICBkZWxldGUgdGhpcy5rZXlfdG9fc3Vic19pZFtrZXldOyAvLyBEZWxldGUgdGhlIGJ1eSBrZXkgdG8gY29udHJhY3RfaWQgbWFwcGluZ1xcblxcbiAgICAgIGRlbGV0ZSB0aGlzLmJ1eV9rZXlfdG9fY29udHJhY3RfaWRba2V5XTsgLy8gTWFyayB0aGUgc291cmNlIGNvbXBsZXRlZFxcblxcbiAgICAgIHNvdXJjZS5jb21wbGV0ZSgpO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcImdldE1zZ1R5cGVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TXNnVHlwZShyZXF1ZXN0KSB7XFxuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtc19saXN0LmZpbmQoZnVuY3Rpb24gKHN0cmVhbV9rZXkpIHtcXG4gICAgICAgIHJldHVybiBzdHJlYW1fa2V5IGluIHJlcXVlc3Q7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBTdWJzY3JpcHRpb25NYW5hZ2VyO1xcbn0oKTtcXG5cXG5cXG5cXG5mdW5jdGlvbiB0b0tleShyZXF1ZXN0KSB7XFxuICByZXR1cm4gKDAsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18ub2JqZWN0VG9DYWNoZUtleSkocmVxdWVzdCk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9zcmMvZGVyaXZfYXBpL1N1YnNjcmlwdGlvbk1hbmFnZXIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZXJpdl9hcGkvZXJyb3JzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVyaXZfYXBpL2Vycm9ycy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJlcnJvckZhY3RvcnlcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBlcnJvckZhY3RvcnkpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIkFQSUVycm9yXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQVBJRXJyb3IpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIkNvbnN0cnVjdGlvbkVycm9yXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29uc3RydWN0aW9uRXJyb3IpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfY2xhc3NDYWxsQ2hlY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2sgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfY3JlYXRlQ2xhc3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfaW5oZXJpdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZ2V0UHJvdG90eXBlT2ZfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfd3JhcE5hdGl2ZVN1cGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBOYXRpdmVTdXBlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vd3JhcE5hdGl2ZVN1cGVyLmpzXFxcIik7XFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gKDAsX2JhYmVsX3J1bnRpbWVfaGVscGVyc19nZXRQcm90b3R5cGVPZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLmRlZmF1bHQpKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCxfYmFiZWxfcnVudGltZV9oZWxwZXJzX2dldFByb3RvdHlwZU9mX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uZGVmYXVsdCkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLmRlZmF1bHQpKHRoaXMsIHJlc3VsdCk7IH07IH1cXG5cXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFxcXCJ1bmRlZmluZWRcXFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcXFwiZnVuY3Rpb25cXFwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxcblxcbmZ1bmN0aW9uIGVycm9yRmFjdG9yeSh0eXBlKSB7XFxuICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcXG4gICAgKDAsX2JhYmVsX3J1bnRpbWVfaGVscGVyc19pbmhlcml0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmRlZmF1bHQpKEdlbmVyaWNFcnJvciwgX0Vycm9yKTtcXG5cXG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihHZW5lcmljRXJyb3IpO1xcblxcbiAgICBmdW5jdGlvbiBHZW5lcmljRXJyb3IobWVzc2FnZSkge1xcbiAgICAgIHZhciBfdGhpcztcXG5cXG4gICAgICAoMCxfYmFiZWxfcnVudGltZV9oZWxwZXJzX2NsYXNzQ2FsbENoZWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZGVmYXVsdCkodGhpcywgR2VuZXJpY0Vycm9yKTtcXG5cXG4gICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xcbiAgICAgIF90aGlzLnR5cGUgPSB0eXBlO1xcbiAgICAgIF90aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xcbiAgICAgIHJldHVybiBfdGhpcztcXG4gICAgfVxcblxcbiAgICAoMCxfYmFiZWxfcnVudGltZV9oZWxwZXJzX2NyZWF0ZUNsYXNzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uZGVmYXVsdCkoR2VuZXJpY0Vycm9yLCBbe1xcbiAgICAgIGtleTogXFxcInRvU3RyaW5nXFxcIixcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XFxuICAgICAgICByZXR1cm4gXFxcIlxcXCIuY29uY2F0KHRoaXMudHlwZSwgXFxcIjogXFxcIikuY29uY2F0KHRoaXMubWVzc2FnZSk7XFxuICAgICAgfVxcbiAgICB9XSk7XFxuXFxuICAgIHJldHVybiBHZW5lcmljRXJyb3I7XFxuICB9KCAvKiNfX1BVUkVfXyovKDAsX2JhYmVsX3J1bnRpbWVfaGVscGVyc193cmFwTmF0aXZlU3VwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5kZWZhdWx0KShFcnJvcikpO1xcbn1cXG52YXIgQVBJRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9lcnJvckZhY3RvcnkpIHtcXG4gICgwLF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfaW5oZXJpdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5kZWZhdWx0KShBUElFcnJvciwgX2Vycm9yRmFjdG9yeSk7XFxuXFxuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihBUElFcnJvcik7XFxuXFxuICBmdW5jdGlvbiBBUElFcnJvcigpIHtcXG4gICAgKDAsX2JhYmVsX3J1bnRpbWVfaGVscGVyc19jbGFzc0NhbGxDaGVja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmRlZmF1bHQpKHRoaXMsIEFQSUVycm9yKTtcXG5cXG4gICAgcmV0dXJuIF9zdXBlcjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gIH1cXG5cXG4gIHJldHVybiBBUElFcnJvcjtcXG59KGVycm9yRmFjdG9yeSgnQVBJRXJyb3InKSk7XFxudmFyIENvbnN0cnVjdGlvbkVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfZXJyb3JGYWN0b3J5Mikge1xcbiAgKDAsX2JhYmVsX3J1bnRpbWVfaGVscGVyc19pbmhlcml0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmRlZmF1bHQpKENvbnN0cnVjdGlvbkVycm9yLCBfZXJyb3JGYWN0b3J5Mik7XFxuXFxuICB2YXIgX3N1cGVyMyA9IF9jcmVhdGVTdXBlcihDb25zdHJ1Y3Rpb25FcnJvcik7XFxuXFxuICBmdW5jdGlvbiBDb25zdHJ1Y3Rpb25FcnJvcigpIHtcXG4gICAgKDAsX2JhYmVsX3J1bnRpbWVfaGVscGVyc19jbGFzc0NhbGxDaGVja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmRlZmF1bHQpKHRoaXMsIENvbnN0cnVjdGlvbkVycm9yKTtcXG5cXG4gICAgcmV0dXJuIF9zdXBlcjMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gIH1cXG5cXG4gIHJldHVybiBDb25zdHJ1Y3Rpb25FcnJvcjtcXG59KGVycm9yRmFjdG9yeSgnQ29uc3RydWN0aW9uRXJyb3InKSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL3NyYy9kZXJpdl9hcGkvZXJyb3JzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVyaXZfYXBpL3V0aWxzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kZXJpdl9hcGkvdXRpbHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJvYmplY3RUb0NhY2hlS2V5XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gb2JqZWN0VG9DYWNoZUtleSlcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHkuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganNvbl9zdGFibGVfc3RyaW5naWZ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBqc29uLXN0YWJsZS1zdHJpbmdpZnkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2pzb24tc3RhYmxlLXN0cmluZ2lmeS9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqc29uX3N0YWJsZV9zdHJpbmdpZnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqc29uX3N0YWJsZV9zdHJpbmdpZnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XFxuXFxuXFxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XFxuXFxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XFxuXFxuIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvcHJlZmVyLWRlZmF1bHQtZXhwb3J0XFxuXFxuZnVuY3Rpb24gb2JqZWN0VG9DYWNoZUtleShvYmopIHtcXG4gIHZhciBjbG9uZWRfb2JqZWN0ID0gX29iamVjdFNwcmVhZCh7fSwgb2JqKTtcXG5cXG4gIGRlbGV0ZSBjbG9uZWRfb2JqZWN0LnJlcV9pZDtcXG4gIGRlbGV0ZSBjbG9uZWRfb2JqZWN0LnBhc3N0aHJvdWdoO1xcbiAgZGVsZXRlIGNsb25lZF9vYmplY3Quc3Vic2NyaWJlO1xcbiAgcmV0dXJuIGpzb25fc3RhYmxlX3N0cmluZ2lmeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQoKShjbG9uZWRfb2JqZWN0KTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL3NyYy9kZXJpdl9hcGkvdXRpbHMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9qc29uLXN0YWJsZS1zdHJpbmdpZnkvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2pzb24tc3RhYmxlLXN0cmluZ2lmeS9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJ2YXIganNvbiA9IHR5cGVvZiBKU09OICE9PSAndW5kZWZpbmVkJyA/IEpTT04gOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBqc29uaWZ5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9qc29uaWZ5L2luZGV4LmpzXFxcIik7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBvcHRzKSB7XFxuICAgIGlmICghb3B0cykgb3B0cyA9IHt9O1xcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIG9wdHMgPSB7IGNtcDogb3B0cyB9O1xcbiAgICB2YXIgc3BhY2UgPSBvcHRzLnNwYWNlIHx8ICcnO1xcbiAgICBpZiAodHlwZW9mIHNwYWNlID09PSAnbnVtYmVyJykgc3BhY2UgPSBBcnJheShzcGFjZSsxKS5qb2luKCcgJyk7XFxuICAgIHZhciBjeWNsZXMgPSAodHlwZW9mIG9wdHMuY3ljbGVzID09PSAnYm9vbGVhbicpID8gb3B0cy5jeWNsZXMgOiBmYWxzZTtcXG4gICAgdmFyIHJlcGxhY2VyID0gb3B0cy5yZXBsYWNlciB8fCBmdW5jdGlvbihrZXksIHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcXG5cXG4gICAgdmFyIGNtcCA9IG9wdHMuY21wICYmIChmdW5jdGlvbiAoZikge1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICAgICAgICAgIHZhciBhb2JqID0geyBrZXk6IGEsIHZhbHVlOiBub2RlW2FdIH07XFxuICAgICAgICAgICAgICAgIHZhciBib2JqID0geyBrZXk6IGIsIHZhbHVlOiBub2RlW2JdIH07XFxuICAgICAgICAgICAgICAgIHJldHVybiBmKGFvYmosIGJvYmopO1xcbiAgICAgICAgICAgIH07XFxuICAgICAgICB9O1xcbiAgICB9KShvcHRzLmNtcCk7XFxuXFxuICAgIHZhciBzZWVuID0gW107XFxuICAgIHJldHVybiAoZnVuY3Rpb24gc3RyaW5naWZ5IChwYXJlbnQsIGtleSwgbm9kZSwgbGV2ZWwpIHtcXG4gICAgICAgIHZhciBpbmRlbnQgPSBzcGFjZSA/ICgnXFxcXG4nICsgbmV3IEFycmF5KGxldmVsICsgMSkuam9pbihzcGFjZSkpIDogJyc7XFxuICAgICAgICB2YXIgY29sb25TZXBhcmF0b3IgPSBzcGFjZSA/ICc6ICcgOiAnOic7XFxuXFxuICAgICAgICBpZiAobm9kZSAmJiBub2RlLnRvSlNPTiAmJiB0eXBlb2Ygbm9kZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgICBub2RlID0gbm9kZS50b0pTT04oKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIG5vZGUgPSByZXBsYWNlci5jYWxsKHBhcmVudCwga2V5LCBub2RlKTtcXG5cXG4gICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8IG5vZGUgPT09IG51bGwpIHtcXG4gICAgICAgICAgICByZXR1cm4ganNvbi5zdHJpbmdpZnkobm9kZSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoaXNBcnJheShub2RlKSkge1xcbiAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBzdHJpbmdpZnkobm9kZSwgaSwgbm9kZVtpXSwgbGV2ZWwrMSkgfHwganNvbi5zdHJpbmdpZnkobnVsbCk7XFxuICAgICAgICAgICAgICAgIG91dC5wdXNoKGluZGVudCArIHNwYWNlICsgaXRlbSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiAnWycgKyBvdXQuam9pbignLCcpICsgaW5kZW50ICsgJ10nO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgaWYgKHNlZW4uaW5kZXhPZihub2RlKSAhPT0gLTEpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGN5Y2xlcykgcmV0dXJuIGpzb24uc3RyaW5naWZ5KCdfX2N5Y2xlX18nKTtcXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29udmVydGluZyBjaXJjdWxhciBzdHJ1Y3R1cmUgdG8gSlNPTicpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHNlZW4ucHVzaChub2RlKTtcXG5cXG4gICAgICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMobm9kZSkuc29ydChjbXAgJiYgY21wKG5vZGUpKTtcXG4gICAgICAgICAgICB2YXIgb3V0ID0gW107XFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHJpbmdpZnkobm9kZSwga2V5LCBub2RlW2tleV0sIGxldmVsKzEpO1xcblxcbiAgICAgICAgICAgICAgICBpZighdmFsdWUpIGNvbnRpbnVlO1xcblxcbiAgICAgICAgICAgICAgICB2YXIga2V5VmFsdWUgPSBqc29uLnN0cmluZ2lmeShrZXkpXFxuICAgICAgICAgICAgICAgICAgICArIGNvbG9uU2VwYXJhdG9yXFxuICAgICAgICAgICAgICAgICAgICArIHZhbHVlO1xcbiAgICAgICAgICAgICAgICA7XFxuICAgICAgICAgICAgICAgIG91dC5wdXNoKGluZGVudCArIHNwYWNlICsga2V5VmFsdWUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBzZWVuLnNwbGljZShzZWVuLmluZGV4T2Yobm9kZSksIDEpO1xcbiAgICAgICAgICAgIHJldHVybiAneycgKyBvdXQuam9pbignLCcpICsgaW5kZW50ICsgJ30nO1xcbiAgICAgICAgfVxcbiAgICB9KSh7ICcnOiBvYmogfSwgJycsIG9iaiwgMCk7XFxufTtcXG5cXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHgpIHtcXG4gICAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XFxufTtcXG5cXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcXG4gICAgdmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZSB9O1xcbiAgICB2YXIga2V5cyA9IFtdO1xcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XFxuICAgICAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcXG4gICAgfVxcbiAgICByZXR1cm4ga2V5cztcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9ub2RlX21vZHVsZXMvanNvbi1zdGFibGUtc3RyaW5naWZ5L2luZGV4LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvanNvbmlmeS9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2pzb25pZnkvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcImV4cG9ydHMucGFyc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xpYi9wYXJzZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvanNvbmlmeS9saWIvcGFyc2UuanNcXFwiKTtcXG5leHBvcnRzLnN0cmluZ2lmeSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGliL3N0cmluZ2lmeSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvanNvbmlmeS9saWIvc3RyaW5naWZ5LmpzXFxcIik7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9qc29uaWZ5L2luZGV4LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvanNvbmlmeS9saWIvcGFyc2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvanNvbmlmeS9saWIvcGFyc2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5ldmFsKFwidmFyIGF0LCAvLyBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgY2hhcmFjdGVyXFxuICAgIGNoLCAvLyBUaGUgY3VycmVudCBjaGFyYWN0ZXJcXG4gICAgZXNjYXBlZSA9IHtcXG4gICAgICAgICdcXFwiJzogICdcXFwiJyxcXG4gICAgICAgICdcXFxcXFxcXCc6ICdcXFxcXFxcXCcsXFxuICAgICAgICAnLyc6ICAnLycsXFxuICAgICAgICBiOiAgICAnXFxcXGInLFxcbiAgICAgICAgZjogICAgJ1xcXFxmJyxcXG4gICAgICAgIG46ICAgICdcXFxcbicsXFxuICAgICAgICByOiAgICAnXFxcXHInLFxcbiAgICAgICAgdDogICAgJ1xcXFx0J1xcbiAgICB9LFxcbiAgICB0ZXh0LFxcblxcbiAgICBlcnJvciA9IGZ1bmN0aW9uIChtKSB7XFxuICAgICAgICAvLyBDYWxsIGVycm9yIHdoZW4gc29tZXRoaW5nIGlzIHdyb25nLlxcbiAgICAgICAgdGhyb3cge1xcbiAgICAgICAgICAgIG5hbWU6ICAgICdTeW50YXhFcnJvcicsXFxuICAgICAgICAgICAgbWVzc2FnZTogbSxcXG4gICAgICAgICAgICBhdDogICAgICBhdCxcXG4gICAgICAgICAgICB0ZXh0OiAgICB0ZXh0XFxuICAgICAgICB9O1xcbiAgICB9LFxcbiAgICBcXG4gICAgbmV4dCA9IGZ1bmN0aW9uIChjKSB7XFxuICAgICAgICAvLyBJZiBhIGMgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCB2ZXJpZnkgdGhhdCBpdCBtYXRjaGVzIHRoZSBjdXJyZW50IGNoYXJhY3Rlci5cXG4gICAgICAgIGlmIChjICYmIGMgIT09IGNoKSB7XFxuICAgICAgICAgICAgZXJyb3IoXFxcIkV4cGVjdGVkICdcXFwiICsgYyArIFxcXCInIGluc3RlYWQgb2YgJ1xcXCIgKyBjaCArIFxcXCInXFxcIik7XFxuICAgICAgICB9XFxuICAgICAgICBcXG4gICAgICAgIC8vIEdldCB0aGUgbmV4dCBjaGFyYWN0ZXIuIFdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgY2hhcmFjdGVycyxcXG4gICAgICAgIC8vIHJldHVybiB0aGUgZW1wdHkgc3RyaW5nLlxcbiAgICAgICAgXFxuICAgICAgICBjaCA9IHRleHQuY2hhckF0KGF0KTtcXG4gICAgICAgIGF0ICs9IDE7XFxuICAgICAgICByZXR1cm4gY2g7XFxuICAgIH0sXFxuICAgIFxcbiAgICBudW1iZXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAvLyBQYXJzZSBhIG51bWJlciB2YWx1ZS5cXG4gICAgICAgIHZhciBudW1iZXIsXFxuICAgICAgICAgICAgc3RyaW5nID0gJyc7XFxuICAgICAgICBcXG4gICAgICAgIGlmIChjaCA9PT0gJy0nKSB7XFxuICAgICAgICAgICAgc3RyaW5nID0gJy0nO1xcbiAgICAgICAgICAgIG5leHQoJy0nKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHdoaWxlIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XFxuICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xcbiAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChjaCA9PT0gJy4nKSB7XFxuICAgICAgICAgICAgc3RyaW5nICs9ICcuJztcXG4gICAgICAgICAgICB3aGlsZSAobmV4dCgpICYmIGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcXG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcXG4gICAgICAgICAgICBzdHJpbmcgKz0gY2g7XFxuICAgICAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcXG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xcbiAgICAgICAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHdoaWxlIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XFxuICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcXG4gICAgICAgICAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIG51bWJlciA9ICtzdHJpbmc7XFxuICAgICAgICBpZiAoIWlzRmluaXRlKG51bWJlcikpIHtcXG4gICAgICAgICAgICBlcnJvcihcXFwiQmFkIG51bWJlclxcXCIpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBcXG4gICAgc3RyaW5nID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgLy8gUGFyc2UgYSBzdHJpbmcgdmFsdWUuXFxuICAgICAgICB2YXIgaGV4LFxcbiAgICAgICAgICAgIGksXFxuICAgICAgICAgICAgc3RyaW5nID0gJycsXFxuICAgICAgICAgICAgdWZmZmY7XFxuICAgICAgICBcXG4gICAgICAgIC8vIFdoZW4gcGFyc2luZyBmb3Igc3RyaW5nIHZhbHVlcywgd2UgbXVzdCBsb29rIGZvciBcXFwiIGFuZCBcXFxcIGNoYXJhY3RlcnMuXFxuICAgICAgICBpZiAoY2ggPT09ICdcXFwiJykge1xcbiAgICAgICAgICAgIHdoaWxlIChuZXh0KCkpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxcIicpIHtcXG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcXFxcXCcpIHtcXG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3UnKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdWZmZmYgPSAwO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGV4ID0gcGFyc2VJbnQobmV4dCgpLCAxNik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoaGV4KSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWZmZmYgPSB1ZmZmZiAqIDE2ICsgaGV4O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1ZmZmZik7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlc2NhcGVlW2NoXSA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gZXNjYXBlZVtjaF07XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgZXJyb3IoXFxcIkJhZCBzdHJpbmdcXFwiKTtcXG4gICAgfSxcXG5cXG4gICAgd2hpdGUgPSBmdW5jdGlvbiAoKSB7XFxuXFxuLy8gU2tpcCB3aGl0ZXNwYWNlLlxcblxcbiAgICAgICAgd2hpbGUgKGNoICYmIGNoIDw9ICcgJykge1xcbiAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgd29yZCA9IGZ1bmN0aW9uICgpIHtcXG5cXG4vLyB0cnVlLCBmYWxzZSwgb3IgbnVsbC5cXG5cXG4gICAgICAgIHN3aXRjaCAoY2gpIHtcXG4gICAgICAgIGNhc2UgJ3QnOlxcbiAgICAgICAgICAgIG5leHQoJ3QnKTtcXG4gICAgICAgICAgICBuZXh0KCdyJyk7XFxuICAgICAgICAgICAgbmV4dCgndScpO1xcbiAgICAgICAgICAgIG5leHQoJ2UnKTtcXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIGNhc2UgJ2YnOlxcbiAgICAgICAgICAgIG5leHQoJ2YnKTtcXG4gICAgICAgICAgICBuZXh0KCdhJyk7XFxuICAgICAgICAgICAgbmV4dCgnbCcpO1xcbiAgICAgICAgICAgIG5leHQoJ3MnKTtcXG4gICAgICAgICAgICBuZXh0KCdlJyk7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgY2FzZSAnbic6XFxuICAgICAgICAgICAgbmV4dCgnbicpO1xcbiAgICAgICAgICAgIG5leHQoJ3UnKTtcXG4gICAgICAgICAgICBuZXh0KCdsJyk7XFxuICAgICAgICAgICAgbmV4dCgnbCcpO1xcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgICAgZXJyb3IoXFxcIlVuZXhwZWN0ZWQgJ1xcXCIgKyBjaCArIFxcXCInXFxcIik7XFxuICAgIH0sXFxuXFxuICAgIHZhbHVlLCAgLy8gUGxhY2UgaG9sZGVyIGZvciB0aGUgdmFsdWUgZnVuY3Rpb24uXFxuXFxuICAgIGFycmF5ID0gZnVuY3Rpb24gKCkge1xcblxcbi8vIFBhcnNlIGFuIGFycmF5IHZhbHVlLlxcblxcbiAgICAgICAgdmFyIGFycmF5ID0gW107XFxuXFxuICAgICAgICBpZiAoY2ggPT09ICdbJykge1xcbiAgICAgICAgICAgIG5leHQoJ1snKTtcXG4gICAgICAgICAgICB3aGl0ZSgpO1xcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XFxuICAgICAgICAgICAgICAgIG5leHQoJ10nKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5OyAgIC8vIGVtcHR5IGFycmF5XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHdoaWxlIChjaCkge1xcbiAgICAgICAgICAgICAgICBhcnJheS5wdXNoKHZhbHVlKCkpO1xcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnXScpO1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIG5leHQoJywnKTtcXG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBlcnJvcihcXFwiQmFkIGFycmF5XFxcIik7XFxuICAgIH0sXFxuXFxuICAgIG9iamVjdCA9IGZ1bmN0aW9uICgpIHtcXG5cXG4vLyBQYXJzZSBhbiBvYmplY3QgdmFsdWUuXFxuXFxuICAgICAgICB2YXIga2V5LFxcbiAgICAgICAgICAgIG9iamVjdCA9IHt9O1xcblxcbiAgICAgICAgaWYgKGNoID09PSAneycpIHtcXG4gICAgICAgICAgICBuZXh0KCd7Jyk7XFxuICAgICAgICAgICAgd2hpdGUoKTtcXG4gICAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xcbiAgICAgICAgICAgICAgICBuZXh0KCd9Jyk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7ICAgLy8gZW1wdHkgb2JqZWN0XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHdoaWxlIChjaCkge1xcbiAgICAgICAgICAgICAgICBrZXkgPSBzdHJpbmcoKTtcXG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcXG4gICAgICAgICAgICAgICAgbmV4dCgnOicpO1xcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XFxuICAgICAgICAgICAgICAgICAgICBlcnJvcignRHVwbGljYXRlIGtleSBcXFwiJyArIGtleSArICdcXFwiJyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZSgpO1xcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnfScpO1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBuZXh0KCcsJyk7XFxuICAgICAgICAgICAgICAgIHdoaXRlKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgZXJyb3IoXFxcIkJhZCBvYmplY3RcXFwiKTtcXG4gICAgfTtcXG5cXG52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcXG5cXG4vLyBQYXJzZSBhIEpTT04gdmFsdWUuIEl0IGNvdWxkIGJlIGFuIG9iamVjdCwgYW4gYXJyYXksIGEgc3RyaW5nLCBhIG51bWJlcixcXG4vLyBvciBhIHdvcmQuXFxuXFxuICAgIHdoaXRlKCk7XFxuICAgIHN3aXRjaCAoY2gpIHtcXG4gICAgY2FzZSAneyc6XFxuICAgICAgICByZXR1cm4gb2JqZWN0KCk7XFxuICAgIGNhc2UgJ1snOlxcbiAgICAgICAgcmV0dXJuIGFycmF5KCk7XFxuICAgIGNhc2UgJ1xcXCInOlxcbiAgICAgICAgcmV0dXJuIHN0cmluZygpO1xcbiAgICBjYXNlICctJzpcXG4gICAgICAgIHJldHVybiBudW1iZXIoKTtcXG4gICAgZGVmYXVsdDpcXG4gICAgICAgIHJldHVybiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknID8gbnVtYmVyKCkgOiB3b3JkKCk7XFxuICAgIH1cXG59O1xcblxcbi8vIFJldHVybiB0aGUganNvbl9wYXJzZSBmdW5jdGlvbi4gSXQgd2lsbCBoYXZlIGFjY2VzcyB0byBhbGwgb2YgdGhlIGFib3ZlXFxuLy8gZnVuY3Rpb25zIGFuZCB2YXJpYWJsZXMuXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc291cmNlLCByZXZpdmVyKSB7XFxuICAgIHZhciByZXN1bHQ7XFxuICAgIFxcbiAgICB0ZXh0ID0gc291cmNlO1xcbiAgICBhdCA9IDA7XFxuICAgIGNoID0gJyAnO1xcbiAgICByZXN1bHQgPSB2YWx1ZSgpO1xcbiAgICB3aGl0ZSgpO1xcbiAgICBpZiAoY2gpIHtcXG4gICAgICAgIGVycm9yKFxcXCJTeW50YXggZXJyb3JcXFwiKTtcXG4gICAgfVxcblxcbiAgICAvLyBJZiB0aGVyZSBpcyBhIHJldml2ZXIgZnVuY3Rpb24sIHdlIHJlY3Vyc2l2ZWx5IHdhbGsgdGhlIG5ldyBzdHJ1Y3R1cmUsXFxuICAgIC8vIHBhc3NpbmcgZWFjaCBuYW1lL3ZhbHVlIHBhaXIgdG8gdGhlIHJldml2ZXIgZnVuY3Rpb24gZm9yIHBvc3NpYmxlXFxuICAgIC8vIHRyYW5zZm9ybWF0aW9uLCBzdGFydGluZyB3aXRoIGEgdGVtcG9yYXJ5IHJvb3Qgb2JqZWN0IHRoYXQgaG9sZHMgdGhlIHJlc3VsdFxcbiAgICAvLyBpbiBhbiBlbXB0eSBrZXkuIElmIHRoZXJlIGlzIG5vdCBhIHJldml2ZXIgZnVuY3Rpb24sIHdlIHNpbXBseSByZXR1cm4gdGhlXFxuICAgIC8vIHJlc3VsdC5cXG5cXG4gICAgcmV0dXJuIHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nID8gKGZ1bmN0aW9uIHdhbGsoaG9sZGVyLCBrZXkpIHtcXG4gICAgICAgIHZhciBrLCB2LCB2YWx1ZSA9IGhvbGRlcltrZXldO1xcbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcXG4gICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcXG4gICAgICAgICAgICAgICAgICAgIHYgPSB3YWxrKHZhbHVlLCBrKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IHY7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrXTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiByZXZpdmVyLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcXG4gICAgfSh7Jyc6IHJlc3VsdH0sICcnKSkgOiByZXN1bHQ7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9EZXJpdkFQSUJhc2ljLy4vbm9kZV9tb2R1bGVzL2pzb25pZnkvbGliL3BhcnNlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvanNvbmlmeS9saWIvc3RyaW5naWZ5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9qc29uaWZ5L2xpYi9zdHJpbmdpZnkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuZXZhbChcInZhciBjeCA9IC9bXFxcXHUwMDAwXFxcXHUwMGFkXFxcXHUwNjAwLVxcXFx1MDYwNFxcXFx1MDcwZlxcXFx1MTdiNFxcXFx1MTdiNVxcXFx1MjAwYy1cXFxcdTIwMGZcXFxcdTIwMjgtXFxcXHUyMDJmXFxcXHUyMDYwLVxcXFx1MjA2ZlxcXFx1ZmVmZlxcXFx1ZmZmMC1cXFxcdWZmZmZdL2csXFxuICAgIGVzY2FwYWJsZSA9IC9bXFxcXFxcXFxcXFxcXFxcIlxcXFx4MDAtXFxcXHgxZlxcXFx4N2YtXFxcXHg5ZlxcXFx1MDBhZFxcXFx1MDYwMC1cXFxcdTA2MDRcXFxcdTA3MGZcXFxcdTE3YjRcXFxcdTE3YjVcXFxcdTIwMGMtXFxcXHUyMDBmXFxcXHUyMDI4LVxcXFx1MjAyZlxcXFx1MjA2MC1cXFxcdTIwNmZcXFxcdWZlZmZcXFxcdWZmZjAtXFxcXHVmZmZmXS9nLFxcbiAgICBnYXAsXFxuICAgIGluZGVudCxcXG4gICAgbWV0YSA9IHsgICAgLy8gdGFibGUgb2YgY2hhcmFjdGVyIHN1YnN0aXR1dGlvbnNcXG4gICAgICAgICdcXFxcYic6ICdcXFxcXFxcXGInLFxcbiAgICAgICAgJ1xcXFx0JzogJ1xcXFxcXFxcdCcsXFxuICAgICAgICAnXFxcXG4nOiAnXFxcXFxcXFxuJyxcXG4gICAgICAgICdcXFxcZic6ICdcXFxcXFxcXGYnLFxcbiAgICAgICAgJ1xcXFxyJzogJ1xcXFxcXFxccicsXFxuICAgICAgICAnXFxcIicgOiAnXFxcXFxcXFxcXFwiJyxcXG4gICAgICAgICdcXFxcXFxcXCc6ICdcXFxcXFxcXFxcXFxcXFxcJ1xcbiAgICB9LFxcbiAgICByZXA7XFxuXFxuZnVuY3Rpb24gcXVvdGUoc3RyaW5nKSB7XFxuICAgIC8vIElmIHRoZSBzdHJpbmcgY29udGFpbnMgbm8gY29udHJvbCBjaGFyYWN0ZXJzLCBubyBxdW90ZSBjaGFyYWN0ZXJzLCBhbmQgbm9cXG4gICAgLy8gYmFja3NsYXNoIGNoYXJhY3RlcnMsIHRoZW4gd2UgY2FuIHNhZmVseSBzbGFwIHNvbWUgcXVvdGVzIGFyb3VuZCBpdC5cXG4gICAgLy8gT3RoZXJ3aXNlIHdlIG11c3QgYWxzbyByZXBsYWNlIHRoZSBvZmZlbmRpbmcgY2hhcmFjdGVycyB3aXRoIHNhZmUgZXNjYXBlXFxuICAgIC8vIHNlcXVlbmNlcy5cXG4gICAgXFxuICAgIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xcbiAgICByZXR1cm4gZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKSA/ICdcXFwiJyArIHN0cmluZy5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHZhciBjID0gbWV0YVthXTtcXG4gICAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gJ3N0cmluZycgPyBjIDpcXG4gICAgICAgICAgICAnXFxcXFxcXFx1JyArICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XFxuICAgIH0pICsgJ1xcXCInIDogJ1xcXCInICsgc3RyaW5nICsgJ1xcXCInO1xcbn1cXG5cXG5mdW5jdGlvbiBzdHIoa2V5LCBob2xkZXIpIHtcXG4gICAgLy8gUHJvZHVjZSBhIHN0cmluZyBmcm9tIGhvbGRlcltrZXldLlxcbiAgICB2YXIgaSwgICAgICAgICAgLy8gVGhlIGxvb3AgY291bnRlci5cXG4gICAgICAgIGssICAgICAgICAgIC8vIFRoZSBtZW1iZXIga2V5LlxcbiAgICAgICAgdiwgICAgICAgICAgLy8gVGhlIG1lbWJlciB2YWx1ZS5cXG4gICAgICAgIGxlbmd0aCxcXG4gICAgICAgIG1pbmQgPSBnYXAsXFxuICAgICAgICBwYXJ0aWFsLFxcbiAgICAgICAgdmFsdWUgPSBob2xkZXJba2V5XTtcXG4gICAgXFxuICAgIC8vIElmIHRoZSB2YWx1ZSBoYXMgYSB0b0pTT04gbWV0aG9kLCBjYWxsIGl0IHRvIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XFxuICAgIH1cXG4gICAgXFxuICAgIC8vIElmIHdlIHdlcmUgY2FsbGVkIHdpdGggYSByZXBsYWNlciBmdW5jdGlvbiwgdGhlbiBjYWxsIHRoZSByZXBsYWNlciB0b1xcbiAgICAvLyBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cXG4gICAgaWYgKHR5cGVvZiByZXAgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIHZhbHVlID0gcmVwLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcXG4gICAgfVxcbiAgICBcXG4gICAgLy8gV2hhdCBoYXBwZW5zIG5leHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUncyB0eXBlLlxcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcXG4gICAgICAgICAgICByZXR1cm4gcXVvdGUodmFsdWUpO1xcbiAgICAgICAgXFxuICAgICAgICBjYXNlICdudW1iZXInOlxcbiAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gRW5jb2RlIG5vbi1maW5pdGUgbnVtYmVycyBhcyBudWxsLlxcbiAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogJ251bGwnO1xcbiAgICAgICAgXFxuICAgICAgICBjYXNlICdib29sZWFuJzpcXG4gICAgICAgIGNhc2UgJ251bGwnOlxcbiAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBhIGJvb2xlYW4gb3IgbnVsbCwgY29udmVydCBpdCB0byBhIHN0cmluZy4gTm90ZTpcXG4gICAgICAgICAgICAvLyB0eXBlb2YgbnVsbCBkb2VzIG5vdCBwcm9kdWNlICdudWxsJy4gVGhlIGNhc2UgaXMgaW5jbHVkZWQgaGVyZSBpblxcbiAgICAgICAgICAgIC8vIHRoZSByZW1vdGUgY2hhbmNlIHRoYXQgdGhpcyBnZXRzIGZpeGVkIHNvbWVkYXkuXFxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XFxuICAgICAgICAgICAgXFxuICAgICAgICBjYXNlICdvYmplY3QnOlxcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHJldHVybiAnbnVsbCc7XFxuICAgICAgICAgICAgZ2FwICs9IGluZGVudDtcXG4gICAgICAgICAgICBwYXJ0aWFsID0gW107XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgLy8gQXJyYXkuaXNBcnJheVxcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xcbiAgICAgICAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XFxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbFtpXSA9IHN0cihpLCB2YWx1ZSkgfHwgJ251bGwnO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAvLyBKb2luIGFsbCBvZiB0aGUgZWxlbWVudHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcywgYW5kXFxuICAgICAgICAgICAgICAgIC8vIHdyYXAgdGhlbSBpbiBicmFja2V0cy5cXG4gICAgICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gJ1tdJyA6IGdhcCA/XFxuICAgICAgICAgICAgICAgICAgICAnW1xcXFxuJyArIGdhcCArIHBhcnRpYWwuam9pbignLFxcXFxuJyArIGdhcCkgKyAnXFxcXG4nICsgbWluZCArICddJyA6XFxuICAgICAgICAgICAgICAgICAgICAnWycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICddJztcXG4gICAgICAgICAgICAgICAgZ2FwID0gbWluZDtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIC8vIElmIHRoZSByZXBsYWNlciBpcyBhbiBhcnJheSwgdXNlIGl0IHRvIHNlbGVjdCB0aGUgbWVtYmVycyB0byBiZVxcbiAgICAgICAgICAgIC8vIHN0cmluZ2lmaWVkLlxcbiAgICAgICAgICAgIGlmIChyZXAgJiYgdHlwZW9mIHJlcCA9PT0gJ29iamVjdCcpIHtcXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gcmVwLmxlbmd0aDtcXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgICAgICAgICAgICAgICBrID0gcmVwW2ldO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBrZXlzIGluIHRoZSBvYmplY3QuXFxuICAgICAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoZ2FwID8gJzogJyA6ICc6JykgKyB2KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgXFxuICAgICAgICAvLyBKb2luIGFsbCBvZiB0aGUgbWVtYmVyIHRleHRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsXFxuICAgICAgICAvLyBhbmQgd3JhcCB0aGVtIGluIGJyYWNlcy5cXG5cXG4gICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICd7fScgOiBnYXAgP1xcbiAgICAgICAgICAgICd7XFxcXG4nICsgZ2FwICsgcGFydGlhbC5qb2luKCcsXFxcXG4nICsgZ2FwKSArICdcXFxcbicgKyBtaW5kICsgJ30nIDpcXG4gICAgICAgICAgICAneycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICd9JztcXG4gICAgICAgIGdhcCA9IG1pbmQ7XFxuICAgICAgICByZXR1cm4gdjtcXG4gICAgfVxcbn1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKSB7XFxuICAgIHZhciBpO1xcbiAgICBnYXAgPSAnJztcXG4gICAgaW5kZW50ID0gJyc7XFxuICAgIFxcbiAgICAvLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbnVtYmVyLCBtYWtlIGFuIGluZGVudCBzdHJpbmcgY29udGFpbmluZyB0aGF0XFxuICAgIC8vIG1hbnkgc3BhY2VzLlxcbiAgICBpZiAodHlwZW9mIHNwYWNlID09PSAnbnVtYmVyJykge1xcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYWNlOyBpICs9IDEpIHtcXG4gICAgICAgICAgICBpbmRlbnQgKz0gJyAnO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIC8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcsIGl0IHdpbGwgYmUgdXNlZCBhcyB0aGUgaW5kZW50IHN0cmluZy5cXG4gICAgZWxzZSBpZiAodHlwZW9mIHNwYWNlID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgaW5kZW50ID0gc3BhY2U7XFxuICAgIH1cXG5cXG4gICAgLy8gSWYgdGhlcmUgaXMgYSByZXBsYWNlciwgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIGFycmF5LlxcbiAgICAvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yLlxcbiAgICByZXAgPSByZXBsYWNlcjtcXG4gICAgaWYgKHJlcGxhY2VyICYmIHR5cGVvZiByZXBsYWNlciAhPT0gJ2Z1bmN0aW9uJ1xcbiAgICAmJiAodHlwZW9mIHJlcGxhY2VyICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgcmVwbGFjZXIubGVuZ3RoICE9PSAnbnVtYmVyJykpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSlNPTi5zdHJpbmdpZnknKTtcXG4gICAgfVxcbiAgICBcXG4gICAgLy8gTWFrZSBhIGZha2Ugcm9vdCBvYmplY3QgY29udGFpbmluZyBvdXIgdmFsdWUgdW5kZXIgdGhlIGtleSBvZiAnJy5cXG4gICAgLy8gUmV0dXJuIHRoZSByZXN1bHQgb2Ygc3RyaW5naWZ5aW5nIHRoZSB2YWx1ZS5cXG4gICAgcmV0dXJuIHN0cignJywgeycnOiB2YWx1ZX0pO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9qc29uaWZ5L2xpYi9zdHJpbmdpZnkuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5ldmFsKFwiLyoqXFxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXFxuICpcXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXFxuICovXFxuXFxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcXG4gIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XFxuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XFxuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiA/IFN5bWJvbCA6IHt9O1xcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcXFwiQEBpdGVyYXRvclxcXCI7XFxuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcXFwiQEBhc3luY0l0ZXJhdG9yXFxcIjtcXG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXFxcIkBAdG9TdHJpbmdUYWdcXFwiO1xcblxcbiAgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkge1xcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcXG4gICAgICB2YWx1ZTogdmFsdWUsXFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgd3JpdGFibGU6IHRydWVcXG4gICAgfSk7XFxuICAgIHJldHVybiBvYmpba2V5XTtcXG4gIH1cXG4gIHRyeSB7XFxuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXFxuICAgIGRlZmluZSh7fSwgXFxcIlxcXCIpO1xcbiAgfSBjYXRjaCAoZXJyKSB7XFxuICAgIGRlZmluZSA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xcbiAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xcbiAgICB9O1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XFxuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XFxuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xcblxcbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xcblxcbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xcbiAgfVxcbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcXG5cXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxcbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXFxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xcbiAgICB0cnkge1xcbiAgICAgIHJldHVybiB7IHR5cGU6IFxcXCJub3JtYWxcXFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XFxuICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgIHJldHVybiB7IHR5cGU6IFxcXCJ0aHJvd1xcXCIsIGFyZzogZXJyIH07XFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXFxcInN1c3BlbmRlZFN0YXJ0XFxcIjtcXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXFxcInN1c3BlbmRlZFlpZWxkXFxcIjtcXG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFxcXCJleGVjdXRpbmdcXFwiO1xcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXFxcImNvbXBsZXRlZFxcXCI7XFxuXFxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXFxuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXFxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xcblxcbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXFxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxcbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cXG5cXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcXG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXFxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcXG4gIGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9KTtcXG5cXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcXG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcXG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcXG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xcbiAgfVxcblxcbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cXG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XFxuICBkZWZpbmUoR3AsIFxcXCJjb25zdHJ1Y3RvclxcXCIsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcXG4gIGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgXFxcImNvbnN0cnVjdG9yXFxcIiwgR2VuZXJhdG9yRnVuY3Rpb24pO1xcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoXFxuICAgIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLFxcbiAgICB0b1N0cmluZ1RhZ1N5bWJvbCxcXG4gICAgXFxcIkdlbmVyYXRvckZ1bmN0aW9uXFxcIlxcbiAgKTtcXG5cXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXFxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxcbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xcbiAgICBbXFxcIm5leHRcXFwiLCBcXFwidGhyb3dcXFwiLCBcXFwicmV0dXJuXFxcIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcXG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uKGFyZykge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XFxuICAgICAgfSk7XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XFxuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XFxuICAgIHJldHVybiBjdG9yXFxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxcbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxcbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXFxcIkdlbmVyYXRvckZ1bmN0aW9uXFxcIlxcbiAgICAgIDogZmFsc2U7XFxuICB9O1xcblxcbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XFxuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcXG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xcbiAgICAgIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcXFwiR2VuZXJhdG9yRnVuY3Rpb25cXFwiKTtcXG4gICAgfVxcbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XFxuICAgIHJldHVybiBnZW5GdW47XFxuICB9O1xcblxcbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXFxuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcXFwiX19hd2FpdFxcXCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXFxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XFxuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xcbiAgfTtcXG5cXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcXG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcXG4gICAgICAgIGlmICh2YWx1ZSAmJlxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXFxcIm9iamVjdFxcXCIgJiZcXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXFxcIl9fYXdhaXRcXFwiKSkge1xcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgICAgICAgICAgaW52b2tlKFxcXCJuZXh0XFxcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XFxuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xcbiAgICAgICAgICAgIGludm9rZShcXFwidGhyb3dcXFwiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XFxuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXFxuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XFxuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXFxuICAgICAgICAgIHJldHVybiBpbnZva2UoXFxcInRocm93XFxcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcXG5cXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcXG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxcbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXFxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xcbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xcbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XFxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcXG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XFxuICAgIH1cXG5cXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXFxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XFxuICB9XFxuXFxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xcbiAgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBhc3luY0l0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfSk7XFxuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xcblxcbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXFxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcXG4gICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApIFByb21pc2VJbXBsID0gUHJvbWlzZTtcXG5cXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSxcXG4gICAgICBQcm9taXNlSW1wbFxcbiAgICApO1xcblxcbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXFxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XFxuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xcbiAgICAgICAgfSk7XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XFxuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XFxuXFxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgICB0aHJvdyBhcmc7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcXG4gICAgICB9XFxuXFxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XFxuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XFxuXFxuICAgICAgd2hpbGUgKHRydWUpIHtcXG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XFxuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcXG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XFxuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XFxuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFxcXCJuZXh0XFxcIikge1xcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xcblxcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcXG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xcblxcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXFxcInJldHVyblxcXCIpIHtcXG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXFxcInJldHVyblxcXCIsIGNvbnRleHQuYXJnKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XFxuXFxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XFxuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJub3JtYWxcXFwiKSB7XFxuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cXG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxcbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XFxuXFxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcXG4gICAgICAgICAgfTtcXG5cXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcXG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxcbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFxcXCJ0aHJvd1xcXCI7XFxuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXFxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XFxuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XFxuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXFxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XFxuXFxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICAvLyBOb3RlOiBbXFxcInJldHVyblxcXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcXFwicmV0dXJuXFxcIl0pIHtcXG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXFxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXFxcInJldHVyblxcXCI7XFxuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcXG5cXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cXG4gICAgICAgICAgICAvLyBcXFwicmV0dXJuXFxcIiB0byBcXFwidGhyb3dcXFwiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxcbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFxcXCJ0aHJvd1xcXCI7XFxuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXFxuICAgICAgICAgIFxcXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICB9XFxuXFxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XFxuXFxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXFxcInRocm93XFxcIjtcXG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XFxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XFxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICAgIH1cXG5cXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xcblxcbiAgICBpZiAoISBpbmZvKSB7XFxuICAgICAgY29udGV4dC5tZXRob2QgPSBcXFwidGhyb3dcXFwiO1xcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcXFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcXFwiKTtcXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgfVxcblxcbiAgICBpZiAoaW5mby5kb25lKSB7XFxuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcXG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxcbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xcblxcbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xcblxcbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcXFwidGhyb3dcXFwiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXFxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFxcXCJuZXh0XFxcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXFxuICAgICAgLy8gXFxcImNvbnN1bWVkXFxcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xcbiAgICAgIC8vIFxcXCJyZXR1cm5cXFwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFxcXCJyZXR1cm5cXFwiKSB7XFxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFxcXCJuZXh0XFxcIjtcXG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xcbiAgICAgIH1cXG5cXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXFxuICAgICAgcmV0dXJuIGluZm87XFxuICAgIH1cXG5cXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XFxuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgfVxcblxcbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XFxuXFxuICBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcXFwiR2VuZXJhdG9yXFxcIik7XFxuXFxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXFxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxcbiAgZGVmaW5lKEdwLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfSk7XFxuXFxuICBkZWZpbmUoR3AsIFxcXCJ0b1N0cmluZ1xcXCIsIGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gXFxcIltvYmplY3QgR2VuZXJhdG9yXVxcXCI7XFxuICB9KTtcXG5cXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XFxuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XFxuXFxuICAgIGlmICgxIGluIGxvY3MpIHtcXG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XFxuICAgIH1cXG5cXG4gICAgaWYgKDIgaW4gbG9jcykge1xcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcXG4gICAgfVxcblxcbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XFxuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xcbiAgICByZWNvcmQudHlwZSA9IFxcXCJub3JtYWxcXFwiO1xcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcXG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcXG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxcbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFxcXCJyb290XFxcIiB9XTtcXG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xcbiAgfVxcblxcbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XFxuICAgIHZhciBrZXlzID0gW107XFxuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcXG4gICAgICBrZXlzLnB1c2goa2V5KTtcXG4gICAgfVxcbiAgICBrZXlzLnJldmVyc2UoKTtcXG5cXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XFxuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XFxuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcXG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XFxuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XFxuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xcbiAgICAgICAgICByZXR1cm4gbmV4dDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXFxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xcbiAgICAgIHJldHVybiBuZXh0O1xcbiAgICB9O1xcbiAgfTtcXG5cXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xcbiAgICBpZiAoaXRlcmFibGUpIHtcXG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XFxuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XFxuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXFxcImZ1bmN0aW9uXFxcIikge1xcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcXG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XFxuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XFxuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcXG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcXG5cXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xcbiAgfVxcbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XFxuXFxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XFxuICB9XFxuXFxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcXG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXFxuXFxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XFxuICAgICAgdGhpcy5wcmV2ID0gMDtcXG4gICAgICB0aGlzLm5leHQgPSAwO1xcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXFxuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xcblxcbiAgICAgIHRoaXMubWV0aG9kID0gXFxcIm5leHRcXFwiO1xcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xcblxcbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xcblxcbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XFxuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XFxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXFxcInRcXFwiICYmXFxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XFxuXFxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcXG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xcbiAgICB9LFxcblxcbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XFxuICAgICAgaWYgKHRoaXMuZG9uZSkge1xcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XFxuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XFxuICAgICAgICByZWNvcmQudHlwZSA9IFxcXCJ0aHJvd1xcXCI7XFxuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xcblxcbiAgICAgICAgaWYgKGNhdWdodCkge1xcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxcbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFxcXCJuZXh0XFxcIjtcXG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xcbiAgICAgIH1cXG5cXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XFxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XFxuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcXG5cXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFxcXCJyb290XFxcIikge1xcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcXFwiZW5kXFxcIik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXFxcImNhdGNoTG9jXFxcIik7XFxuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFxcXCJmaW5hbGx5TG9jXFxcIik7XFxuXFxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XFxuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XFxuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XFxcIik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XFxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXFxcImZpbmFsbHlMb2NcXFwiKSAmJlxcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcXG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxcbiAgICAgICAgICAodHlwZSA9PT0gXFxcImJyZWFrXFxcIiB8fFxcbiAgICAgICAgICAgdHlwZSA9PT0gXFxcImNvbnRpbnVlXFxcIikgJiZcXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XFxuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXFxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXFxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcXG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XFxuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcXG5cXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XFxuICAgICAgICB0aGlzLm1ldGhvZCA9IFxcXCJuZXh0XFxcIjtcXG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XFxuICAgIH0sXFxuXFxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XFxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJicmVha1xcXCIgfHxcXG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFxcXCJjb250aW51ZVxcXCIpIHtcXG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XFxuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcInJldHVyblxcXCIpIHtcXG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcXG4gICAgICAgIHRoaXMubWV0aG9kID0gXFxcInJldHVyblxcXCI7XFxuICAgICAgICB0aGlzLm5leHQgPSBcXFwiZW5kXFxcIjtcXG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcXFwibm9ybWFsXFxcIiAmJiBhZnRlckxvYykge1xcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICB9LFxcblxcbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XFxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XFxuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcXG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XFxuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgXFxcImNhdGNoXFxcIjogZnVuY3Rpb24odHJ5TG9jKSB7XFxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XFxuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcXG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcXFwiKTtcXG4gICAgfSxcXG5cXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcXG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xcbiAgICAgIH07XFxuXFxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcXFwibmV4dFxcXCIpIHtcXG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXFxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICAgIH1cXG4gIH07XFxuXFxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXFxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcXG4gIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cXG4gIHJldHVybiBleHBvcnRzO1xcblxcbn0oXFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcXG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXFxuICAgdHJ1ZSA/IG1vZHVsZS5leHBvcnRzIDogMFxcbikpO1xcblxcbnRyeSB7XFxuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XFxuICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIGluIG1vZGVybiBlbmdpbmVzXFxuICAvLyB3ZSBjYW4gZXhwbGljaXRseSBhY2Nlc3MgZ2xvYmFsVGhpcy4gSW4gb2xkZXIgZW5naW5lcyB3ZSBjYW4gZXNjYXBlXFxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxcbiAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXFxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcXG4gIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSBcXFwib2JqZWN0XFxcIikge1xcbiAgICBnbG9iYWxUaGlzLnJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XFxuICB9IGVsc2Uge1xcbiAgICBGdW5jdGlvbihcXFwiclxcXCIsIFxcXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXFxcIikocnVudGltZSk7XFxuICB9XFxufVxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvTm90aWZpY2F0aW9uRmFjdG9yaWVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9Ob3RpZmljYXRpb25GYWN0b3JpZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJDT01QTEVURV9OT1RJRklDQVRJT05cXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBDT01QTEVURV9OT1RJRklDQVRJT04pLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImVycm9yTm90aWZpY2F0aW9uXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZXJyb3JOb3RpZmljYXRpb24pLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIm5leHROb3RpZmljYXRpb25cXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBuZXh0Tm90aWZpY2F0aW9uKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJjcmVhdGVOb3RpZmljYXRpb25cXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBjcmVhdGVOb3RpZmljYXRpb24pXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxudmFyIENPTVBMRVRFX05PVElGSUNBVElPTiA9IChmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVOb3RpZmljYXRpb24oJ0MnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7IH0pKCk7XFxuZnVuY3Rpb24gZXJyb3JOb3RpZmljYXRpb24oZXJyb3IpIHtcXG4gICAgcmV0dXJuIGNyZWF0ZU5vdGlmaWNhdGlvbignRScsIHVuZGVmaW5lZCwgZXJyb3IpO1xcbn1cXG5mdW5jdGlvbiBuZXh0Tm90aWZpY2F0aW9uKHZhbHVlKSB7XFxuICAgIHJldHVybiBjcmVhdGVOb3RpZmljYXRpb24oJ04nLCB2YWx1ZSwgdW5kZWZpbmVkKTtcXG59XFxuZnVuY3Rpb24gY3JlYXRlTm90aWZpY2F0aW9uKGtpbmQsIHZhbHVlLCBlcnJvcikge1xcbiAgICByZXR1cm4ge1xcbiAgICAgICAga2luZDoga2luZCxcXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcXG4gICAgICAgIGVycm9yOiBlcnJvcixcXG4gICAgfTtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tm90aWZpY2F0aW9uRmFjdG9yaWVzLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvTm90aWZpY2F0aW9uRmFjdG9yaWVzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvT2JzZXJ2YWJsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL09ic2VydmFibGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiT2JzZXJ2YWJsZVxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIE9ic2VydmFibGUpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9TdWJzY3JpYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1N1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL1N1YnNjcmliZXIuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1N1YnNjcmlwdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9TdWJzY3JpcHRpb24gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL1N1YnNjcmlwdGlvbi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3ltYm9sX29ic2VydmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3ltYm9sL29ic2VydmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3N5bWJvbC9vYnNlcnZhYmxlLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX3BpcGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbC9waXBlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL3BpcGUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbmZpZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb25maWcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL2NvbmZpZy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9pc0Z1bmN0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWwvaXNGdW5jdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pc0Z1bmN0aW9uLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2Vycm9yQ29udGV4dF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsL2Vycm9yQ29udGV4dCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9lcnJvckNvbnRleHQuanNcXFwiKTtcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG52YXIgT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoKSB7XFxuICAgIGZ1bmN0aW9uIE9ic2VydmFibGUoc3Vic2NyaWJlKSB7XFxuICAgICAgICBpZiAoc3Vic2NyaWJlKSB7XFxuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlID0gc3Vic2NyaWJlO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcXG4gICAgICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcXG4gICAgICAgIG9ic2VydmFibGUuc291cmNlID0gdGhpcztcXG4gICAgICAgIG9ic2VydmFibGUub3BlcmF0b3IgPSBvcGVyYXRvcjtcXG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xcbiAgICB9O1xcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAob2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICAgIHZhciBzdWJzY3JpYmVyID0gaXNTdWJzY3JpYmVyKG9ic2VydmVyT3JOZXh0KSA/IG9ic2VydmVyT3JOZXh0IDogbmV3IF9TdWJzY3JpYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uU2FmZVN1YnNjcmliZXIob2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSk7XFxuICAgICAgICAoMCxfdXRpbF9lcnJvckNvbnRleHRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5lcnJvckNvbnRleHQpKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcywgb3BlcmF0b3IgPSBfYS5vcGVyYXRvciwgc291cmNlID0gX2Euc291cmNlO1xcbiAgICAgICAgICAgIHN1YnNjcmliZXIuYWRkKG9wZXJhdG9yXFxuICAgICAgICAgICAgICAgID9cXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yLmNhbGwoc3Vic2NyaWJlciwgc291cmNlKVxcbiAgICAgICAgICAgICAgICA6IHNvdXJjZVxcbiAgICAgICAgICAgICAgICAgICAgP1xcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zdWJzY3JpYmUoc3Vic2NyaWJlcilcXG4gICAgICAgICAgICAgICAgICAgIDpcXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdHJ5U3Vic2NyaWJlKHN1YnNjcmliZXIpKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZXI7XFxuICAgIH07XFxuICAgIE9ic2VydmFibGUucHJvdG90eXBlLl90cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiAoc2luaykge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaWJlKHNpbmspO1xcbiAgICAgICAgfVxcbiAgICAgICAgY2F0Y2ggKGVycikge1xcbiAgICAgICAgICAgIHNpbmsuZXJyb3IoZXJyKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChuZXh0LCBwcm9taXNlQ3Rvcikge1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICAgIHByb21pc2VDdG9yID0gZ2V0UHJvbWlzZUN0b3IocHJvbWlzZUN0b3IpO1xcbiAgICAgICAgcmV0dXJuIG5ldyBwcm9taXNlQ3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XFxuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbjtcXG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBfdGhpcy5zdWJzY3JpYmUoZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICBuZXh0KHZhbHVlKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcXG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9PT0gbnVsbCB8fCBzdWJzY3JpcHRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSwgcmVqZWN0LCByZXNvbHZlKTtcXG4gICAgICAgIH0pO1xcbiAgICB9O1xcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHZhciBfYTtcXG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLnNvdXJjZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcXG4gICAgfTtcXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGVbX3N5bWJvbF9vYnNlcnZhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18ub2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgfTtcXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBvcGVyYXRpb25zID0gW107XFxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xcbiAgICAgICAgICAgIG9wZXJhdGlvbnNbX2ldID0gYXJndW1lbnRzW19pXTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiAoMCxfdXRpbF9waXBlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18ucGlwZUZyb21BcnJheSkob3BlcmF0aW9ucykodGhpcyk7XFxuICAgIH07XFxuICAgIE9ic2VydmFibGUucHJvdG90eXBlLnRvUHJvbWlzZSA9IGZ1bmN0aW9uIChwcm9taXNlQ3Rvcikge1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICAgIHByb21pc2VDdG9yID0gZ2V0UHJvbWlzZUN0b3IocHJvbWlzZUN0b3IpO1xcbiAgICAgICAgcmV0dXJuIG5ldyBwcm9taXNlQ3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XFxuICAgICAgICAgICAgdmFyIHZhbHVlO1xcbiAgICAgICAgICAgIF90aGlzLnN1YnNjcmliZShmdW5jdGlvbiAoeCkgeyByZXR1cm4gKHZhbHVlID0geCk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHJlamVjdChlcnIpOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKHZhbHVlKTsgfSk7XFxuICAgICAgICB9KTtcXG4gICAgfTtcXG4gICAgT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlKSB7XFxuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoc3Vic2NyaWJlKTtcXG4gICAgfTtcXG4gICAgcmV0dXJuIE9ic2VydmFibGU7XFxufSgpKTtcXG5cXG5mdW5jdGlvbiBnZXRQcm9taXNlQ3Rvcihwcm9taXNlQ3Rvcikge1xcbiAgICB2YXIgX2E7XFxuICAgIHJldHVybiAoX2EgPSBwcm9taXNlQ3RvciAhPT0gbnVsbCAmJiBwcm9taXNlQ3RvciAhPT0gdm9pZCAwID8gcHJvbWlzZUN0b3IgOiBfY29uZmlnX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uY29uZmlnLlByb21pc2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFByb21pc2U7XFxufVxcbmZ1bmN0aW9uIGlzT2JzZXJ2ZXIodmFsdWUpIHtcXG4gICAgcmV0dXJuIHZhbHVlICYmICgwLF91dGlsX2lzRnVuY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5pc0Z1bmN0aW9uKSh2YWx1ZS5uZXh0KSAmJiAoMCxfdXRpbF9pc0Z1bmN0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uaXNGdW5jdGlvbikodmFsdWUuZXJyb3IpICYmICgwLF91dGlsX2lzRnVuY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5pc0Z1bmN0aW9uKSh2YWx1ZS5jb21wbGV0ZSk7XFxufVxcbmZ1bmN0aW9uIGlzU3Vic2NyaWJlcih2YWx1ZSkge1xcbiAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgX1N1YnNjcmliZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5TdWJzY3JpYmVyKSB8fCAoaXNPYnNlcnZlcih2YWx1ZSkgJiYgKDAsX1N1YnNjcmlwdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLmlzU3Vic2NyaXB0aW9uKSh2YWx1ZSkpO1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYnNlcnZhYmxlLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvT2JzZXJ2YWJsZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL1N1YmplY3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9TdWJqZWN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIlN1YmplY3RcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBTdWJqZWN0KSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJBbm9ueW1vdXNTdWJqZWN0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQW5vbnltb3VzU3ViamVjdClcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX09ic2VydmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vT2JzZXJ2YWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvT2JzZXJ2YWJsZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfU3Vic2NyaXB0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1N1YnNjcmlwdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvU3Vic2NyaXB0aW9uLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX09iamVjdFVuc3Vic2NyaWJlZEVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWwvT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfYXJyUmVtb3ZlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWwvYXJyUmVtb3ZlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2FyclJlbW92ZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9lcnJvckNvbnRleHRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbC9lcnJvckNvbnRleHQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvZXJyb3JDb250ZXh0LmpzXFxcIik7XFxuXFxuXFxuXFxuXFxuXFxuXFxudmFyIFN1YmplY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xcbiAgICAoMCx0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLl9fZXh0ZW5kcykoU3ViamVjdCwgX3N1cGVyKTtcXG4gICAgZnVuY3Rpb24gU3ViamVjdCgpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XFxuICAgICAgICBfdGhpcy5jbG9zZWQgPSBmYWxzZTtcXG4gICAgICAgIF90aGlzLm9ic2VydmVycyA9IFtdO1xcbiAgICAgICAgX3RoaXMuaXNTdG9wcGVkID0gZmFsc2U7XFxuICAgICAgICBfdGhpcy5oYXNFcnJvciA9IGZhbHNlO1xcbiAgICAgICAgX3RoaXMudGhyb3duRXJyb3IgPSBudWxsO1xcbiAgICAgICAgcmV0dXJuIF90aGlzO1xcbiAgICB9XFxuICAgIFN1YmplY3QucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcXG4gICAgICAgIHZhciBzdWJqZWN0ID0gbmV3IEFub255bW91c1N1YmplY3QodGhpcywgdGhpcyk7XFxuICAgICAgICBzdWJqZWN0Lm9wZXJhdG9yID0gb3BlcmF0b3I7XFxuICAgICAgICByZXR1cm4gc3ViamVjdDtcXG4gICAgfTtcXG4gICAgU3ViamVjdC5wcm90b3R5cGUuX3Rocm93SWZDbG9zZWQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgX3V0aWxfT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5PYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgKDAsX3V0aWxfZXJyb3JDb250ZXh0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uZXJyb3JDb250ZXh0KShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgdmFyIGVfMSwgX2E7XFxuICAgICAgICAgICAgX3RoaXMuX3Rocm93SWZDbG9zZWQoKTtcXG4gICAgICAgICAgICBpZiAoIV90aGlzLmlzU3RvcHBlZCkge1xcbiAgICAgICAgICAgICAgICB2YXIgY29weSA9IF90aGlzLm9ic2VydmVycy5zbGljZSgpO1xcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY29weV8xID0gKDAsdHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5fX3ZhbHVlcykoY29weSksIGNvcHlfMV8xID0gY29weV8xLm5leHQoKTsgIWNvcHlfMV8xLmRvbmU7IGNvcHlfMV8xID0gY29weV8xLm5leHQoKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYnNlcnZlciA9IGNvcHlfMV8xLnZhbHVlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQodmFsdWUpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XFxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29weV8xXzEgJiYgIWNvcHlfMV8xLmRvbmUgJiYgKF9hID0gY29weV8xLnJldHVybikpIF9hLmNhbGwoY29weV8xKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICB9O1xcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuICAgICAgICAoMCxfdXRpbF9lcnJvckNvbnRleHRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5lcnJvckNvbnRleHQpKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBfdGhpcy5fdGhyb3dJZkNsb3NlZCgpO1xcbiAgICAgICAgICAgIGlmICghX3RoaXMuaXNTdG9wcGVkKSB7XFxuICAgICAgICAgICAgICAgIF90aGlzLmhhc0Vycm9yID0gX3RoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgX3RoaXMudGhyb3duRXJyb3IgPSBlcnI7XFxuICAgICAgICAgICAgICAgIHZhciBvYnNlcnZlcnMgPSBfdGhpcy5vYnNlcnZlcnM7XFxuICAgICAgICAgICAgICAgIHdoaWxlIChvYnNlcnZlcnMubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlcnMuc2hpZnQoKS5lcnJvcihlcnIpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgIH07XFxuICAgIFN1YmplY3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICAgICgwLF91dGlsX2Vycm9yQ29udGV4dF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmVycm9yQ29udGV4dCkoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIF90aGlzLl90aHJvd0lmQ2xvc2VkKCk7XFxuICAgICAgICAgICAgaWYgKCFfdGhpcy5pc1N0b3BwZWQpIHtcXG4gICAgICAgICAgICAgICAgX3RoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgdmFyIG9ic2VydmVycyA9IF90aGlzLm9ic2VydmVycztcXG4gICAgICAgICAgICAgICAgd2hpbGUgKG9ic2VydmVycy5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVycy5zaGlmdCgpLmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgfTtcXG4gICAgU3ViamVjdC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRoaXMuY2xvc2VkID0gdHJ1ZTtcXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gbnVsbDtcXG4gICAgfTtcXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN1YmplY3QucHJvdG90eXBlLCBcXFwib2JzZXJ2ZWRcXFwiLCB7XFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB2YXIgX2E7XFxuICAgICAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLm9ic2VydmVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPiAwO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXFxuICAgIH0pO1xcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5fdHJ5U3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHRoaXMuX3Rocm93SWZDbG9zZWQoKTtcXG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLl90cnlTdWJzY3JpYmUuY2FsbCh0aGlzLCBzdWJzY3JpYmVyKTtcXG4gICAgfTtcXG4gICAgU3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XFxuICAgICAgICB0aGlzLl90aHJvd0lmQ2xvc2VkKCk7XFxuICAgICAgICB0aGlzLl9jaGVja0ZpbmFsaXplZFN0YXR1c2VzKHN1YnNjcmliZXIpO1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyU3Vic2NyaWJlKHN1YnNjcmliZXIpO1xcbiAgICB9O1xcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5faW5uZXJTdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIF9hID0gdGhpcywgaGFzRXJyb3IgPSBfYS5oYXNFcnJvciwgaXNTdG9wcGVkID0gX2EuaXNTdG9wcGVkLCBvYnNlcnZlcnMgPSBfYS5vYnNlcnZlcnM7XFxuICAgICAgICByZXR1cm4gaGFzRXJyb3IgfHwgaXNTdG9wcGVkXFxuICAgICAgICAgICAgPyBfU3Vic2NyaXB0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRU1QVFlfU1VCU0NSSVBUSU9OXFxuICAgICAgICAgICAgOiAob2JzZXJ2ZXJzLnB1c2goc3Vic2NyaWJlciksIG5ldyBfU3Vic2NyaXB0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uU3Vic2NyaXB0aW9uKGZ1bmN0aW9uICgpIHsgcmV0dXJuICgwLF91dGlsX2FyclJlbW92ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLmFyclJlbW92ZSkob2JzZXJ2ZXJzLCBzdWJzY3JpYmVyKTsgfSkpO1xcbiAgICB9O1xcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5fY2hlY2tGaW5hbGl6ZWRTdGF0dXNlcyA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XFxuICAgICAgICB2YXIgX2EgPSB0aGlzLCBoYXNFcnJvciA9IF9hLmhhc0Vycm9yLCB0aHJvd25FcnJvciA9IF9hLnRocm93bkVycm9yLCBpc1N0b3BwZWQgPSBfYS5pc1N0b3BwZWQ7XFxuICAgICAgICBpZiAoaGFzRXJyb3IpIHtcXG4gICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKHRocm93bkVycm9yKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKGlzU3RvcHBlZCkge1xcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgU3ViamVjdC5wcm90b3R5cGUuYXNPYnNlcnZhYmxlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgX09ic2VydmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5PYnNlcnZhYmxlKCk7XFxuICAgICAgICBvYnNlcnZhYmxlLnNvdXJjZSA9IHRoaXM7XFxuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcXG4gICAgfTtcXG4gICAgU3ViamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAoZGVzdGluYXRpb24sIHNvdXJjZSkge1xcbiAgICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNTdWJqZWN0KGRlc3RpbmF0aW9uLCBzb3VyY2UpO1xcbiAgICB9O1xcbiAgICByZXR1cm4gU3ViamVjdDtcXG59KF9PYnNlcnZhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uT2JzZXJ2YWJsZSkpO1xcblxcbnZhciBBbm9ueW1vdXNTdWJqZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcXG4gICAgKDAsdHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5fX2V4dGVuZHMpKEFub255bW91c1N1YmplY3QsIF9zdXBlcik7XFxuICAgIGZ1bmN0aW9uIEFub255bW91c1N1YmplY3QoZGVzdGluYXRpb24sIHNvdXJjZSkge1xcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcXG4gICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XFxuICAgICAgICBfdGhpcy5zb3VyY2UgPSBzb3VyY2U7XFxuICAgICAgICByZXR1cm4gX3RoaXM7XFxuICAgIH1cXG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgdmFyIF9hLCBfYjtcXG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuZGVzdGluYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uZXh0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdmFsdWUpO1xcbiAgICB9O1xcbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgICAgIHZhciBfYSwgX2I7XFxuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmRlc3RpbmF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXJyb3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBlcnIpO1xcbiAgICB9O1xcbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBfYSwgX2I7XFxuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmRlc3RpbmF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29tcGxldGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcXG4gICAgfTtcXG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XFxuICAgICAgICB2YXIgX2EsIF9iO1xcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuc291cmNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3Vic2NyaWJlKHN1YnNjcmliZXIpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBfU3Vic2NyaXB0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uRU1QVFlfU1VCU0NSSVBUSU9OO1xcbiAgICB9O1xcbiAgICByZXR1cm4gQW5vbnltb3VzU3ViamVjdDtcXG59KFN1YmplY3QpKTtcXG5cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJqZWN0LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvU3ViamVjdC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL1N1YnNjcmliZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9TdWJzY3JpYmVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIlN1YnNjcmliZXJcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBTdWJzY3JpYmVyKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJTYWZlU3Vic2NyaWJlclxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIFNhZmVTdWJzY3JpYmVyKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJFTVBUWV9PQlNFUlZFUlxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIEVNUFRZX09CU0VSVkVSKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9pc0Z1bmN0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWwvaXNGdW5jdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pc0Z1bmN0aW9uLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9TdWJzY3JpcHRpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vU3Vic2NyaXB0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9TdWJzY3JpcHRpb24uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbmZpZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb25maWcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL2NvbmZpZy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9yZXBvcnRVbmhhbmRsZWRFcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsL3JlcG9ydFVuaGFuZGxlZEVycm9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL3JlcG9ydFVuaGFuZGxlZEVycm9yLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX25vb3BfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbC9ub29wICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL25vb3AuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX05vdGlmaWNhdGlvbkZhY3Rvcmllc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9Ob3RpZmljYXRpb25GYWN0b3JpZXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL05vdGlmaWNhdGlvbkZhY3Rvcmllcy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2NoZWR1bGVyX3RpbWVvdXRQcm92aWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zY2hlZHVsZXIvdGltZW91dFByb3ZpZGVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9zY2hlZHVsZXIvdGltZW91dFByb3ZpZGVyLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2Vycm9yQ29udGV4dF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsL2Vycm9yQ29udGV4dCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9lcnJvckNvbnRleHQuanNcXFwiKTtcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG52YXIgU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XFxuICAgICgwLHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uX19leHRlbmRzKShTdWJzY3JpYmVyLCBfc3VwZXIpO1xcbiAgICBmdW5jdGlvbiBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xcbiAgICAgICAgX3RoaXMuaXNTdG9wcGVkID0gZmFsc2U7XFxuICAgICAgICBpZiAoZGVzdGluYXRpb24pIHtcXG4gICAgICAgICAgICBfdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xcbiAgICAgICAgICAgIGlmICgoMCxfU3Vic2NyaXB0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uaXNTdWJzY3JpcHRpb24pKGRlc3RpbmF0aW9uKSkge1xcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5hZGQoX3RoaXMpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gRU1QVFlfT0JTRVJWRVI7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gX3RoaXM7XFxuICAgIH1cXG4gICAgU3Vic2NyaWJlci5jcmVhdGUgPSBmdW5jdGlvbiAobmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XFxuICAgICAgICByZXR1cm4gbmV3IFNhZmVTdWJzY3JpYmVyKG5leHQsIGVycm9yLCBjb21wbGV0ZSk7XFxuICAgIH07XFxuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZCkge1xcbiAgICAgICAgICAgIGhhbmRsZVN0b3BwZWROb3RpZmljYXRpb24oKDAsX05vdGlmaWNhdGlvbkZhY3Rvcmllc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLm5leHROb3RpZmljYXRpb24pKHZhbHVlKSwgdGhpcyk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICB0aGlzLl9uZXh0KHZhbHVlKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XFxuICAgICAgICBpZiAodGhpcy5pc1N0b3BwZWQpIHtcXG4gICAgICAgICAgICBoYW5kbGVTdG9wcGVkTm90aWZpY2F0aW9uKCgwLF9Ob3RpZmljYXRpb25GYWN0b3JpZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5lcnJvck5vdGlmaWNhdGlvbikoZXJyKSwgdGhpcyk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XFxuICAgICAgICAgICAgdGhpcy5fZXJyb3IoZXJyKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAodGhpcy5pc1N0b3BwZWQpIHtcXG4gICAgICAgICAgICBoYW5kbGVTdG9wcGVkTm90aWZpY2F0aW9uKF9Ob3RpZmljYXRpb25GYWN0b3JpZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5DT01QTEVURV9OT1RJRklDQVRJT04sIHRoaXMpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xcbiAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlKCk7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKCF0aGlzLmNsb3NlZCkge1xcbiAgICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcyk7XFxuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG51bGw7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xcbiAgICB9O1xcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGZpbmFsbHkge1xcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XFxuICAgICAgICB9XFxuICAgICAgICBmaW5hbGx5IHtcXG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIHJldHVybiBTdWJzY3JpYmVyO1xcbn0oX1N1YnNjcmlwdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlN1YnNjcmlwdGlvbikpO1xcblxcbnZhciBTYWZlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XFxuICAgICgwLHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uX19leHRlbmRzKShTYWZlU3Vic2NyaWJlciwgX3N1cGVyKTtcXG4gICAgZnVuY3Rpb24gU2FmZVN1YnNjcmliZXIob2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcXG4gICAgICAgIHZhciBuZXh0O1xcbiAgICAgICAgaWYgKCgwLF91dGlsX2lzRnVuY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5pc0Z1bmN0aW9uKShvYnNlcnZlck9yTmV4dCkpIHtcXG4gICAgICAgICAgICBuZXh0ID0gb2JzZXJ2ZXJPck5leHQ7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChvYnNlcnZlck9yTmV4dCkge1xcbiAgICAgICAgICAgIChuZXh0ID0gb2JzZXJ2ZXJPck5leHQubmV4dCwgZXJyb3IgPSBvYnNlcnZlck9yTmV4dC5lcnJvciwgY29tcGxldGUgPSBvYnNlcnZlck9yTmV4dC5jb21wbGV0ZSk7XFxuICAgICAgICAgICAgdmFyIGNvbnRleHRfMTtcXG4gICAgICAgICAgICBpZiAoX3RoaXMgJiYgX2NvbmZpZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLmNvbmZpZy51c2VEZXByZWNhdGVkTmV4dENvbnRleHQpIHtcXG4gICAgICAgICAgICAgICAgY29udGV4dF8xID0gT2JqZWN0LmNyZWF0ZShvYnNlcnZlck9yTmV4dCk7XFxuICAgICAgICAgICAgICAgIGNvbnRleHRfMS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnVuc3Vic2NyaWJlKCk7IH07XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICBjb250ZXh0XzEgPSBvYnNlcnZlck9yTmV4dDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgbmV4dCA9IG5leHQgPT09IG51bGwgfHwgbmV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmV4dC5iaW5kKGNvbnRleHRfMSk7XFxuICAgICAgICAgICAgZXJyb3IgPSBlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IuYmluZChjb250ZXh0XzEpO1xcbiAgICAgICAgICAgIGNvbXBsZXRlID0gY29tcGxldGUgPT09IG51bGwgfHwgY29tcGxldGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbXBsZXRlLmJpbmQoY29udGV4dF8xKTtcXG4gICAgICAgIH1cXG4gICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0ge1xcbiAgICAgICAgICAgIG5leHQ6IG5leHQgPyB3cmFwRm9yRXJyb3JIYW5kbGluZyhuZXh0LCBfdGhpcykgOiBfdXRpbF9ub29wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18ubm9vcCxcXG4gICAgICAgICAgICBlcnJvcjogd3JhcEZvckVycm9ySGFuZGxpbmcoZXJyb3IgIT09IG51bGwgJiYgZXJyb3IgIT09IHZvaWQgMCA/IGVycm9yIDogZGVmYXVsdEVycm9ySGFuZGxlciwgX3RoaXMpLFxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZSA/IHdyYXBGb3JFcnJvckhhbmRsaW5nKGNvbXBsZXRlLCBfdGhpcykgOiBfdXRpbF9ub29wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18ubm9vcCxcXG4gICAgICAgIH07XFxuICAgICAgICByZXR1cm4gX3RoaXM7XFxuICAgIH1cXG4gICAgcmV0dXJuIFNhZmVTdWJzY3JpYmVyO1xcbn0oU3Vic2NyaWJlcikpO1xcblxcbmZ1bmN0aW9uIHdyYXBGb3JFcnJvckhhbmRsaW5nKGhhbmRsZXIsIGluc3RhbmNlKSB7XFxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYXJncyA9IFtdO1xcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcXG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XFxuICAgICAgICB9XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGhhbmRsZXIuYXBwbHkodm9pZCAwLCAoMCx0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLl9fc3ByZWFkQXJyYXkpKFtdLCAoMCx0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLl9fcmVhZCkoYXJncykpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgICBpZiAoX2NvbmZpZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLmNvbmZpZy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nKSB7XFxuICAgICAgICAgICAgICAgICgwLF91dGlsX2Vycm9yQ29udGV4dF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLmNhcHR1cmVFcnJvcikoZXJyKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgICgwLF91dGlsX3JlcG9ydFVuaGFuZGxlZEVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18ucmVwb3J0VW5oYW5kbGVkRXJyb3IpKGVycik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9O1xcbn1cXG5mdW5jdGlvbiBkZWZhdWx0RXJyb3JIYW5kbGVyKGVycikge1xcbiAgICB0aHJvdyBlcnI7XFxufVxcbmZ1bmN0aW9uIGhhbmRsZVN0b3BwZWROb3RpZmljYXRpb24obm90aWZpY2F0aW9uLCBzdWJzY3JpYmVyKSB7XFxuICAgIHZhciBvblN0b3BwZWROb3RpZmljYXRpb24gPSBfY29uZmlnX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uY29uZmlnLm9uU3RvcHBlZE5vdGlmaWNhdGlvbjtcXG4gICAgb25TdG9wcGVkTm90aWZpY2F0aW9uICYmIF9zY2hlZHVsZXJfdGltZW91dFByb3ZpZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18udGltZW91dFByb3ZpZGVyLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gb25TdG9wcGVkTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbiwgc3Vic2NyaWJlcik7IH0pO1xcbn1cXG52YXIgRU1QVFlfT0JTRVJWRVIgPSB7XFxuICAgIGNsb3NlZDogdHJ1ZSxcXG4gICAgbmV4dDogX3V0aWxfbm9vcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLm5vb3AsXFxuICAgIGVycm9yOiBkZWZhdWx0RXJyb3JIYW5kbGVyLFxcbiAgICBjb21wbGV0ZTogX3V0aWxfbm9vcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLm5vb3AsXFxufTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJzY3JpYmVyLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvU3Vic2NyaWJlci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL1N1YnNjcmlwdGlvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvU3Vic2NyaXB0aW9uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiU3Vic2NyaXB0aW9uXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU3Vic2NyaXB0aW9uKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJFTVBUWV9TVUJTQ1JJUFRJT05cXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBFTVBUWV9TVUJTQ1JJUFRJT04pLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImlzU3Vic2NyaXB0aW9uXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gaXNTdWJzY3JpcHRpb24pXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2lzRnVuY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbC9pc0Z1bmN0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2lzRnVuY3Rpb24uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfVW5zdWJzY3JpcHRpb25FcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsL1Vuc3Vic2NyaXB0aW9uRXJyb3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvci5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9hcnJSZW1vdmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbC9hcnJSZW1vdmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvYXJyUmVtb3ZlLmpzXFxcIik7XFxuXFxuXFxuXFxuXFxudmFyIFN1YnNjcmlwdGlvbiA9IChmdW5jdGlvbiAoKSB7XFxuICAgIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbihpbml0aWFsVGVhcmRvd24pIHtcXG4gICAgICAgIHRoaXMuaW5pdGlhbFRlYXJkb3duID0gaW5pdGlhbFRlYXJkb3duO1xcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcXG4gICAgICAgIHRoaXMuX3BhcmVudGFnZSA9IG51bGw7XFxuICAgICAgICB0aGlzLl90ZWFyZG93bnMgPSBudWxsO1xcbiAgICB9XFxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgZV8xLCBfYSwgZV8yLCBfYjtcXG4gICAgICAgIHZhciBlcnJvcnM7XFxuICAgICAgICBpZiAoIXRoaXMuY2xvc2VkKSB7XFxuICAgICAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xcbiAgICAgICAgICAgIHZhciBfcGFyZW50YWdlID0gdGhpcy5fcGFyZW50YWdlO1xcbiAgICAgICAgICAgIGlmIChfcGFyZW50YWdlKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudGFnZSA9IG51bGw7XFxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KF9wYXJlbnRhZ2UpKSB7XFxuICAgICAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9wYXJlbnRhZ2VfMSA9ICgwLHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uX192YWx1ZXMpKF9wYXJlbnRhZ2UpLCBfcGFyZW50YWdlXzFfMSA9IF9wYXJlbnRhZ2VfMS5uZXh0KCk7ICFfcGFyZW50YWdlXzFfMS5kb25lOyBfcGFyZW50YWdlXzFfMSA9IF9wYXJlbnRhZ2VfMS5uZXh0KCkpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gX3BhcmVudGFnZV8xXzEudmFsdWU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudF8xLnJlbW92ZSh0aGlzKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxcbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9wYXJlbnRhZ2VfMV8xICYmICFfcGFyZW50YWdlXzFfMS5kb25lICYmIChfYSA9IF9wYXJlbnRhZ2VfMS5yZXR1cm4pKSBfYS5jYWxsKF9wYXJlbnRhZ2VfMSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIF9wYXJlbnRhZ2UucmVtb3ZlKHRoaXMpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHZhciBpbml0aWFsVGVhcmRvd24gPSB0aGlzLmluaXRpYWxUZWFyZG93bjtcXG4gICAgICAgICAgICBpZiAoKDAsX3V0aWxfaXNGdW5jdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmlzRnVuY3Rpb24pKGluaXRpYWxUZWFyZG93bikpIHtcXG4gICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxUZWFyZG93bigpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMgPSBlIGluc3RhbmNlb2YgX3V0aWxfVW5zdWJzY3JpcHRpb25FcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLlVuc3Vic2NyaXB0aW9uRXJyb3IgPyBlLmVycm9ycyA6IFtlXTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB2YXIgX3RlYXJkb3ducyA9IHRoaXMuX3RlYXJkb3ducztcXG4gICAgICAgICAgICBpZiAoX3RlYXJkb3ducykge1xcbiAgICAgICAgICAgICAgICB0aGlzLl90ZWFyZG93bnMgPSBudWxsO1xcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX3RlYXJkb3duc18xID0gKDAsdHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5fX3ZhbHVlcykoX3RlYXJkb3ducyksIF90ZWFyZG93bnNfMV8xID0gX3RlYXJkb3duc18xLm5leHQoKTsgIV90ZWFyZG93bnNfMV8xLmRvbmU7IF90ZWFyZG93bnNfMV8xID0gX3RlYXJkb3duc18xLm5leHQoKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZWFyZG93bl8xID0gX3RlYXJkb3duc18xXzEudmFsdWU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhlY1RlYXJkb3duKHRlYXJkb3duXzEpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycyAhPT0gbnVsbCAmJiBlcnJvcnMgIT09IHZvaWQgMCA/IGVycm9ycyA6IFtdO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgX3V0aWxfVW5zdWJzY3JpcHRpb25FcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLlVuc3Vic2NyaXB0aW9uRXJyb3IpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9ICgwLHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uX19zcHJlYWRBcnJheSkoKDAsdHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5fX3NwcmVhZEFycmF5KShbXSwgKDAsdHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5fX3JlYWQpKGVycm9ycykpLCAoMCx0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLl9fcmVhZCkoZXJyLmVycm9ycykpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxcbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90ZWFyZG93bnNfMV8xICYmICFfdGVhcmRvd25zXzFfMS5kb25lICYmIChfYiA9IF90ZWFyZG93bnNfMS5yZXR1cm4pKSBfYi5jYWxsKF90ZWFyZG93bnNfMSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKGVycm9ycykge1xcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgX3V0aWxfVW5zdWJzY3JpcHRpb25FcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLlVuc3Vic2NyaXB0aW9uRXJyb3IoZXJyb3JzKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHRlYXJkb3duKSB7XFxuICAgICAgICB2YXIgX2E7XFxuICAgICAgICBpZiAodGVhcmRvd24gJiYgdGVhcmRvd24gIT09IHRoaXMpIHtcXG4gICAgICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcXG4gICAgICAgICAgICAgICAgZXhlY1RlYXJkb3duKHRlYXJkb3duKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIGlmICh0ZWFyZG93biBpbnN0YW5jZW9mIFN1YnNjcmlwdGlvbikge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlYXJkb3duLmNsb3NlZCB8fCB0ZWFyZG93bi5faGFzUGFyZW50KHRoaXMpKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgdGVhcmRvd24uX2FkZFBhcmVudCh0aGlzKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAodGhpcy5fdGVhcmRvd25zID0gKF9hID0gdGhpcy5fdGVhcmRvd25zKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSkucHVzaCh0ZWFyZG93bik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLl9oYXNQYXJlbnQgPSBmdW5jdGlvbiAocGFyZW50KSB7XFxuICAgICAgICB2YXIgX3BhcmVudGFnZSA9IHRoaXMuX3BhcmVudGFnZTtcXG4gICAgICAgIHJldHVybiBfcGFyZW50YWdlID09PSBwYXJlbnQgfHwgKEFycmF5LmlzQXJyYXkoX3BhcmVudGFnZSkgJiYgX3BhcmVudGFnZS5pbmNsdWRlcyhwYXJlbnQpKTtcXG4gICAgfTtcXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5fYWRkUGFyZW50ID0gZnVuY3Rpb24gKHBhcmVudCkge1xcbiAgICAgICAgdmFyIF9wYXJlbnRhZ2UgPSB0aGlzLl9wYXJlbnRhZ2U7XFxuICAgICAgICB0aGlzLl9wYXJlbnRhZ2UgPSBBcnJheS5pc0FycmF5KF9wYXJlbnRhZ2UpID8gKF9wYXJlbnRhZ2UucHVzaChwYXJlbnQpLCBfcGFyZW50YWdlKSA6IF9wYXJlbnRhZ2UgPyBbX3BhcmVudGFnZSwgcGFyZW50XSA6IHBhcmVudDtcXG4gICAgfTtcXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5fcmVtb3ZlUGFyZW50ID0gZnVuY3Rpb24gKHBhcmVudCkge1xcbiAgICAgICAgdmFyIF9wYXJlbnRhZ2UgPSB0aGlzLl9wYXJlbnRhZ2U7XFxuICAgICAgICBpZiAoX3BhcmVudGFnZSA9PT0gcGFyZW50KSB7XFxuICAgICAgICAgICAgdGhpcy5fcGFyZW50YWdlID0gbnVsbDtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoX3BhcmVudGFnZSkpIHtcXG4gICAgICAgICAgICAoMCxfdXRpbF9hcnJSZW1vdmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5hcnJSZW1vdmUpKF9wYXJlbnRhZ2UsIHBhcmVudCk7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHRlYXJkb3duKSB7XFxuICAgICAgICB2YXIgX3RlYXJkb3ducyA9IHRoaXMuX3RlYXJkb3ducztcXG4gICAgICAgIF90ZWFyZG93bnMgJiYgKDAsX3V0aWxfYXJyUmVtb3ZlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uYXJyUmVtb3ZlKShfdGVhcmRvd25zLCB0ZWFyZG93bik7XFxuICAgICAgICBpZiAodGVhcmRvd24gaW5zdGFuY2VvZiBTdWJzY3JpcHRpb24pIHtcXG4gICAgICAgICAgICB0ZWFyZG93bi5fcmVtb3ZlUGFyZW50KHRoaXMpO1xcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICBTdWJzY3JpcHRpb24uRU1QVFkgPSAoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGVtcHR5ID0gbmV3IFN1YnNjcmlwdGlvbigpO1xcbiAgICAgICAgZW1wdHkuY2xvc2VkID0gdHJ1ZTtcXG4gICAgICAgIHJldHVybiBlbXB0eTtcXG4gICAgfSkoKTtcXG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbjtcXG59KCkpO1xcblxcbnZhciBFTVBUWV9TVUJTQ1JJUFRJT04gPSBTdWJzY3JpcHRpb24uRU1QVFk7XFxuZnVuY3Rpb24gaXNTdWJzY3JpcHRpb24odmFsdWUpIHtcXG4gICAgcmV0dXJuICh2YWx1ZSBpbnN0YW5jZW9mIFN1YnNjcmlwdGlvbiB8fFxcbiAgICAgICAgKHZhbHVlICYmICdjbG9zZWQnIGluIHZhbHVlICYmICgwLF91dGlsX2lzRnVuY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5pc0Z1bmN0aW9uKSh2YWx1ZS5yZW1vdmUpICYmICgwLF91dGlsX2lzRnVuY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5pc0Z1bmN0aW9uKSh2YWx1ZS5hZGQpICYmICgwLF91dGlsX2lzRnVuY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5pc0Z1bmN0aW9uKSh2YWx1ZS51bnN1YnNjcmliZSkpKTtcXG59XFxuZnVuY3Rpb24gZXhlY1RlYXJkb3duKHRlYXJkb3duKSB7XFxuICAgIGlmICgoMCxfdXRpbF9pc0Z1bmN0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uaXNGdW5jdGlvbikodGVhcmRvd24pKSB7XFxuICAgICAgICB0ZWFyZG93bigpO1xcbiAgICB9XFxuICAgIGVsc2Uge1xcbiAgICAgICAgdGVhcmRvd24udW5zdWJzY3JpYmUoKTtcXG4gICAgfVxcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJzY3JpcHRpb24uanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9TdWJzY3JpcHRpb24uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9jb25maWcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL2NvbmZpZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImNvbmZpZ1xcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGNvbmZpZylcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG52YXIgY29uZmlnID0ge1xcbiAgICBvblVuaGFuZGxlZEVycm9yOiBudWxsLFxcbiAgICBvblN0b3BwZWROb3RpZmljYXRpb246IG51bGwsXFxuICAgIFByb21pc2U6IHVuZGVmaW5lZCxcXG4gICAgdXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZzogZmFsc2UsXFxuICAgIHVzZURlcHJlY2F0ZWROZXh0Q29udGV4dDogZmFsc2UsXFxufTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25maWcuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9jb25maWcuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL2VtcHR5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb2JzZXJ2YWJsZS9lbXB0eS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJFTVBUWVxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIEVNUFRZKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJlbXB0eVxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGVtcHR5KVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfT2JzZXJ2YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vT2JzZXJ2YWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvT2JzZXJ2YWJsZS5qc1xcXCIpO1xcblxcbnZhciBFTVBUWSA9IG5ldyBfT2JzZXJ2YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLk9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHsgcmV0dXJuIHN1YnNjcmliZXIuY29tcGxldGUoKTsgfSk7XFxuZnVuY3Rpb24gZW1wdHkoc2NoZWR1bGVyKSB7XFxuICAgIHJldHVybiBzY2hlZHVsZXIgPyBlbXB0eVNjaGVkdWxlZChzY2hlZHVsZXIpIDogRU1QVFk7XFxufVxcbmZ1bmN0aW9uIGVtcHR5U2NoZWR1bGVkKHNjaGVkdWxlcikge1xcbiAgICByZXR1cm4gbmV3IF9PYnNlcnZhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikgeyByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YnNjcmliZXIuY29tcGxldGUoKTsgfSk7IH0pO1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbXB0eS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9EZXJpdkFQSUJhc2ljLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29ic2VydmFibGUvZW1wdHkuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL2Zyb20uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29ic2VydmFibGUvZnJvbS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImZyb21cXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBmcm9tKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJpbm5lckZyb21cXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBpbm5lckZyb20pLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImZyb21BcnJheUxpa2VcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBmcm9tQXJyYXlMaWtlKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaXNBcnJheUxpa2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvaXNBcnJheUxpa2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvaXNBcnJheUxpa2UuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaXNQcm9taXNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2lzUHJvbWlzZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pc1Byb21pc2UuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N5bWJvbF9vYnNlcnZhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9zeW1ib2wvb2JzZXJ2YWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvc3ltYm9sL29ic2VydmFibGUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX09ic2VydmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL09ic2VydmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL09ic2VydmFibGUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NjaGVkdWxlZF9zY2hlZHVsZWRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3NjaGVkdWxlZC9zY2hlZHVsZWQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3NjaGVkdWxlZC9zY2hlZHVsZWQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaXNGdW5jdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvaXNGdW5jdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pc0Z1bmN0aW9uLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX3JlcG9ydFVuaGFuZGxlZEVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9yZXBvcnRVbmhhbmRsZWRFcnJvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9yZXBvcnRVbmhhbmRsZWRFcnJvci5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9pc0ludGVyb3BPYnNlcnZhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2lzSW50ZXJvcE9ic2VydmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvaXNJbnRlcm9wT2JzZXJ2YWJsZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9pc0FzeW5jSXRlcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvaXNBc3luY0l0ZXJhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2lzQXN5bmNJdGVyYWJsZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF90aHJvd1Vub2JzZXJ2YWJsZUVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL3Rocm93VW5vYnNlcnZhYmxlRXJyb3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvdGhyb3dVbm9ic2VydmFibGVFcnJvci5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9pc0l0ZXJhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2lzSXRlcmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvaXNJdGVyYWJsZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9pc1JlYWRhYmxlU3RyZWFtTGlrZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9pc1JlYWRhYmxlU3RyZWFtTGlrZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pc1JlYWRhYmxlU3RyZWFtTGlrZS5qc1xcXCIpO1xcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbmZ1bmN0aW9uIGZyb20oaW5wdXQsIHNjaGVkdWxlcikge1xcbiAgICByZXR1cm4gc2NoZWR1bGVyID8gKDAsX3NjaGVkdWxlZF9zY2hlZHVsZWRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5zY2hlZHVsZWQpKGlucHV0LCBzY2hlZHVsZXIpIDogaW5uZXJGcm9tKGlucHV0KTtcXG59XFxuZnVuY3Rpb24gaW5uZXJGcm9tKGlucHV0KSB7XFxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIF9PYnNlcnZhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uT2JzZXJ2YWJsZSkge1xcbiAgICAgICAgcmV0dXJuIGlucHV0O1xcbiAgICB9XFxuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XFxuICAgICAgICBpZiAoKDAsX3V0aWxfaXNJbnRlcm9wT2JzZXJ2YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmlzSW50ZXJvcE9ic2VydmFibGUpKGlucHV0KSkge1xcbiAgICAgICAgICAgIHJldHVybiBmcm9tSW50ZXJvcE9ic2VydmFibGUoaW5wdXQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCgwLF91dGlsX2lzQXJyYXlMaWtlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uaXNBcnJheUxpa2UpKGlucHV0KSkge1xcbiAgICAgICAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKGlucHV0KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICgoMCxfdXRpbF9pc1Byb21pc2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5pc1Byb21pc2UpKGlucHV0KSkge1xcbiAgICAgICAgICAgIHJldHVybiBmcm9tUHJvbWlzZShpbnB1dCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoKDAsX3V0aWxfaXNBc3luY0l0ZXJhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uaXNBc3luY0l0ZXJhYmxlKShpbnB1dCkpIHtcXG4gICAgICAgICAgICByZXR1cm4gZnJvbUFzeW5jSXRlcmFibGUoaW5wdXQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCgwLF91dGlsX2lzSXRlcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5pc0l0ZXJhYmxlKShpbnB1dCkpIHtcXG4gICAgICAgICAgICByZXR1cm4gZnJvbUl0ZXJhYmxlKGlucHV0KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICgoMCxfdXRpbF9pc1JlYWRhYmxlU3RyZWFtTGlrZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fLmlzUmVhZGFibGVTdHJlYW1MaWtlKShpbnB1dCkpIHtcXG4gICAgICAgICAgICByZXR1cm4gZnJvbVJlYWRhYmxlU3RyZWFtTGlrZShpbnB1dCk7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgdGhyb3cgKDAsX3V0aWxfdGhyb3dVbm9ic2VydmFibGVFcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fLmNyZWF0ZUludmFsaWRPYnNlcnZhYmxlVHlwZUVycm9yKShpbnB1dCk7XFxufVxcbmZ1bmN0aW9uIGZyb21JbnRlcm9wT2JzZXJ2YWJsZShvYmopIHtcXG4gICAgcmV0dXJuIG5ldyBfT2JzZXJ2YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLk9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHZhciBvYnMgPSBvYmpbX3N5bWJvbF9vYnNlcnZhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18ub2JzZXJ2YWJsZV0oKTtcXG4gICAgICAgIGlmICgoMCxfdXRpbF9pc0Z1bmN0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fLmlzRnVuY3Rpb24pKG9icy5zdWJzY3JpYmUpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG9icy5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XFxuICAgICAgICB9XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm92aWRlZCBvYmplY3QgZG9lcyBub3QgY29ycmVjdGx5IGltcGxlbWVudCBTeW1ib2wub2JzZXJ2YWJsZScpO1xcbiAgICB9KTtcXG59XFxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZShhcnJheSkge1xcbiAgICByZXR1cm4gbmV3IF9PYnNlcnZhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGggJiYgIXN1YnNjcmliZXIuY2xvc2VkOyBpKyspIHtcXG4gICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoYXJyYXlbaV0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xcbiAgICB9KTtcXG59XFxuZnVuY3Rpb24gZnJvbVByb21pc2UocHJvbWlzZSkge1xcbiAgICByZXR1cm4gbmV3IF9PYnNlcnZhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xcbiAgICAgICAgcHJvbWlzZVxcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHN1YnNjcmliZXIuZXJyb3IoZXJyKTsgfSlcXG4gICAgICAgICAgICAudGhlbihudWxsLCBfdXRpbF9yZXBvcnRVbmhhbmRsZWRFcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXy5yZXBvcnRVbmhhbmRsZWRFcnJvcik7XFxuICAgIH0pO1xcbn1cXG5mdW5jdGlvbiBmcm9tSXRlcmFibGUoaXRlcmFibGUpIHtcXG4gICAgcmV0dXJuIG5ldyBfT2JzZXJ2YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLk9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHZhciBlXzEsIF9hO1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBmb3IgKHZhciBpdGVyYWJsZV8xID0gKDAsdHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX18uX192YWx1ZXMpKGl0ZXJhYmxlKSwgaXRlcmFibGVfMV8xID0gaXRlcmFibGVfMS5uZXh0KCk7ICFpdGVyYWJsZV8xXzEuZG9uZTsgaXRlcmFibGVfMV8xID0gaXRlcmFibGVfMS5uZXh0KCkpIHtcXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gaXRlcmFibGVfMV8xLnZhbHVlO1xcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XFxuICAgICAgICBmaW5hbGx5IHtcXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICBpZiAoaXRlcmFibGVfMV8xICYmICFpdGVyYWJsZV8xXzEuZG9uZSAmJiAoX2EgPSBpdGVyYWJsZV8xLnJldHVybikpIF9hLmNhbGwoaXRlcmFibGVfMSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cXG4gICAgICAgIH1cXG4gICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcXG4gICAgfSk7XFxufVxcbmZ1bmN0aW9uIGZyb21Bc3luY0l0ZXJhYmxlKGFzeW5jSXRlcmFibGUpIHtcXG4gICAgcmV0dXJuIG5ldyBfT2JzZXJ2YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLk9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHByb2Nlc3MoYXN5bmNJdGVyYWJsZSwgc3Vic2NyaWJlcikuY2F0Y2goZnVuY3Rpb24gKGVycikgeyByZXR1cm4gc3Vic2NyaWJlci5lcnJvcihlcnIpOyB9KTtcXG4gICAgfSk7XFxufVxcbmZ1bmN0aW9uIGZyb21SZWFkYWJsZVN0cmVhbUxpa2UocmVhZGFibGVTdHJlYW0pIHtcXG4gICAgcmV0dXJuIGZyb21Bc3luY0l0ZXJhYmxlKCgwLF91dGlsX2lzUmVhZGFibGVTdHJlYW1MaWtlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18ucmVhZGFibGVTdHJlYW1MaWtlVG9Bc3luY0dlbmVyYXRvcikocmVhZGFibGVTdHJlYW0pKTtcXG59XFxuZnVuY3Rpb24gcHJvY2Vzcyhhc3luY0l0ZXJhYmxlLCBzdWJzY3JpYmVyKSB7XFxuICAgIHZhciBhc3luY0l0ZXJhYmxlXzEsIGFzeW5jSXRlcmFibGVfMV8xO1xcbiAgICB2YXIgZV8yLCBfYTtcXG4gICAgcmV0dXJuICgwLHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fLl9fYXdhaXRlcikodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciB2YWx1ZSwgZV8yXzE7XFxuICAgICAgICByZXR1cm4gKDAsdHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX18uX19nZW5lcmF0b3IpKHRoaXMsIGZ1bmN0aW9uIChfYikge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFswLCA1LCA2LCAxMV0pO1xcbiAgICAgICAgICAgICAgICAgICAgYXN5bmNJdGVyYWJsZV8xID0gKDAsdHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX18uX19hc3luY1ZhbHVlcykoYXN5bmNJdGVyYWJsZSk7XFxuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XFxuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFs0LCBhc3luY0l0ZXJhYmxlXzEubmV4dCgpXTtcXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYXN5bmNJdGVyYWJsZV8xXzEgPSBfYi5zZW50KCksICFhc3luY0l0ZXJhYmxlXzFfMS5kb25lKSkgcmV0dXJuIFszLCA0XTtcXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXN5bmNJdGVyYWJsZV8xXzEudmFsdWU7XFxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcXG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzMsIDFdO1xcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMywgMTFdO1xcbiAgICAgICAgICAgICAgICBjYXNlIDU6XFxuICAgICAgICAgICAgICAgICAgICBlXzJfMSA9IF9iLnNlbnQoKTtcXG4gICAgICAgICAgICAgICAgICAgIGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDExXTtcXG4gICAgICAgICAgICAgICAgY2FzZSA2OlxcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFs2LCAsIDksIDEwXSk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoIShhc3luY0l0ZXJhYmxlXzFfMSAmJiAhYXN5bmNJdGVyYWJsZV8xXzEuZG9uZSAmJiAoX2EgPSBhc3luY0l0ZXJhYmxlXzEucmV0dXJuKSkpIHJldHVybiBbMywgOF07XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIF9hLmNhbGwoYXN5bmNJdGVyYWJsZV8xKV07XFxuICAgICAgICAgICAgICAgIGNhc2UgNzpcXG4gICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcXG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gODtcXG4gICAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gWzMsIDEwXTtcXG4gICAgICAgICAgICAgICAgY2FzZSA5OlxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yO1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3XTtcXG4gICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFs3XTtcXG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcXG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMl07XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgIH0pO1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcm9tLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb2JzZXJ2YWJsZS9mcm9tLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiT3BlcmF0b3JTdWJzY3JpYmVyXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gT3BlcmF0b3JTdWJzY3JpYmVyKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfU3Vic2NyaWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vU3Vic2NyaWJlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvU3Vic2NyaWJlci5qc1xcXCIpO1xcblxcblxcbnZhciBPcGVyYXRvclN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xcbiAgICAoMCx0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLl9fZXh0ZW5kcykoT3BlcmF0b3JTdWJzY3JpYmVyLCBfc3VwZXIpO1xcbiAgICBmdW5jdGlvbiBPcGVyYXRvclN1YnNjcmliZXIoZGVzdGluYXRpb24sIG9uTmV4dCwgb25Db21wbGV0ZSwgb25FcnJvciwgb25GaW5hbGl6ZSkge1xcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pIHx8IHRoaXM7XFxuICAgICAgICBfdGhpcy5vbkZpbmFsaXplID0gb25GaW5hbGl6ZTtcXG4gICAgICAgIF90aGlzLl9uZXh0ID0gb25OZXh0XFxuICAgICAgICAgICAgPyBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgIG9uTmV4dCh2YWx1ZSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xcbiAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICA6IF9zdXBlci5wcm90b3R5cGUuX25leHQ7XFxuICAgICAgICBfdGhpcy5fZXJyb3IgPSBvbkVycm9yXFxuICAgICAgICAgICAgPyBmdW5jdGlvbiAoZXJyKSB7XFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycik7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xcbiAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICA6IF9zdXBlci5wcm90b3R5cGUuX2Vycm9yO1xcbiAgICAgICAgX3RoaXMuX2NvbXBsZXRlID0gb25Db21wbGV0ZVxcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZSgpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKGVycik7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZmluYWxseSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgOiBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZTtcXG4gICAgICAgIHJldHVybiBfdGhpcztcXG4gICAgfVxcbiAgICBPcGVyYXRvclN1YnNjcmliZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIF9hO1xcbiAgICAgICAgdmFyIGNsb3NlZCA9IHRoaXMuY2xvc2VkO1xcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51bnN1YnNjcmliZS5jYWxsKHRoaXMpO1xcbiAgICAgICAgIWNsb3NlZCAmJiAoKF9hID0gdGhpcy5vbkZpbmFsaXplKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKSk7XFxuICAgIH07XFxuICAgIHJldHVybiBPcGVyYXRvclN1YnNjcmliZXI7XFxufShfU3Vic2NyaWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlN1YnNjcmliZXIpKTtcXG5cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1PcGVyYXRvclN1YnNjcmliZXIuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL2RlZmF1bHRJZkVtcHR5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvZGVmYXVsdElmRW1wdHkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0SWZFbXB0eVxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGRlZmF1bHRJZkVtcHR5KVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9saWZ0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvbGlmdC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfT3BlcmF0b3JTdWJzY3JpYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL09wZXJhdG9yU3Vic2NyaWJlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qc1xcXCIpO1xcblxcblxcbmZ1bmN0aW9uIGRlZmF1bHRJZkVtcHR5KGRlZmF1bHRWYWx1ZSkge1xcbiAgICByZXR1cm4gKDAsX3V0aWxfbGlmdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLm9wZXJhdGUpKGZ1bmN0aW9uIChzb3VyY2UsIHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHZhciBoYXNWYWx1ZSA9IGZhbHNlO1xcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShuZXcgX09wZXJhdG9yU3Vic2NyaWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLk9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgICAgICAgICBoYXNWYWx1ZSA9IHRydWU7XFxuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpZiAoIWhhc1ZhbHVlKSB7XFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChkZWZhdWx0VmFsdWUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICB9KSk7XFxuICAgIH0pO1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0SWZFbXB0eS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9EZXJpdkFQSUJhc2ljLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29wZXJhdG9ycy9kZWZhdWx0SWZFbXB0eS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29wZXJhdG9ycy9maWx0ZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvZmlsdGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImZpbHRlclxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGZpbHRlcilcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbGlmdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9saWZ0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2xpZnQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX09wZXJhdG9yU3Vic2NyaWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9PcGVyYXRvclN1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXIuanNcXFwiKTtcXG5cXG5cXG5mdW5jdGlvbiBmaWx0ZXIocHJlZGljYXRlLCB0aGlzQXJnKSB7XFxuICAgIHJldHVybiAoMCxfdXRpbF9saWZ0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ub3BlcmF0ZSkoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcXG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUobmV3IF9PcGVyYXRvclN1YnNjcmliZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5PcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBwcmVkaWNhdGUuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgaW5kZXgrKykgJiYgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTsgfSkpO1xcbiAgICB9KTtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVyLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL2ZpbHRlci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29wZXJhdG9ycy9maW5hbGl6ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL2ZpbmFsaXplLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZmluYWxpemVcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBmaW5hbGl6ZSlcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbGlmdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9saWZ0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2xpZnQuanNcXFwiKTtcXG5cXG5mdW5jdGlvbiBmaW5hbGl6ZShjYWxsYmFjaykge1xcbiAgICByZXR1cm4gKDAsX3V0aWxfbGlmdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLm9wZXJhdGUpKGZ1bmN0aW9uIChzb3VyY2UsIHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGZpbmFsbHkge1xcbiAgICAgICAgICAgIHN1YnNjcmliZXIuYWRkKGNhbGxiYWNrKTtcXG4gICAgICAgIH1cXG4gICAgfSk7XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbmFsaXplLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL2ZpbmFsaXplLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL2ZpcnN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvZmlyc3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJmaXJzdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGZpcnN0KVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9FbXB0eUVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL0VtcHR5RXJyb3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvRW1wdHlFcnJvci5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZmlsdGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZpbHRlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL2ZpbHRlci5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdGFrZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90YWtlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvdGFrZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVmYXVsdElmRW1wdHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZGVmYXVsdElmRW1wdHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29wZXJhdG9ycy9kZWZhdWx0SWZFbXB0eS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdGhyb3dJZkVtcHR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Rocm93SWZFbXB0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL3Rocm93SWZFbXB0eS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9pZGVudGl0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9pZGVudGl0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pZGVudGl0eS5qc1xcXCIpO1xcblxcblxcblxcblxcblxcblxcbmZ1bmN0aW9uIGZpcnN0KHByZWRpY2F0ZSwgZGVmYXVsdFZhbHVlKSB7XFxuICAgIHZhciBoYXNEZWZhdWx0VmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID49IDI7XFxuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XFxuICAgICAgICByZXR1cm4gc291cmNlLnBpcGUocHJlZGljYXRlID8gKDAsX2ZpbHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmZpbHRlcikoZnVuY3Rpb24gKHYsIGkpIHsgcmV0dXJuIHByZWRpY2F0ZSh2LCBpLCBzb3VyY2UpOyB9KSA6IF91dGlsX2lkZW50aXR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uaWRlbnRpdHksICgwLF90YWtlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18udGFrZSkoMSksIGhhc0RlZmF1bHRWYWx1ZSA/ICgwLF9kZWZhdWx0SWZFbXB0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLmRlZmF1bHRJZkVtcHR5KShkZWZhdWx0VmFsdWUpIDogKDAsX3Rocm93SWZFbXB0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLnRocm93SWZFbXB0eSkoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IF91dGlsX0VtcHR5RXJyb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5FbXB0eUVycm9yKCk7IH0pKTtcXG4gICAgfTtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zmlyc3QuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvZmlyc3QuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvc2hhcmUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29wZXJhdG9ycy9zaGFyZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcInNoYXJlXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gc2hhcmUpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9vYnNlcnZhYmxlX2Zyb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL29ic2VydmFibGUvZnJvbSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb2JzZXJ2YWJsZS9mcm9tLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9vcGVyYXRvcnNfdGFrZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb3BlcmF0b3JzL3Rha2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29wZXJhdG9ycy90YWtlLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9TdWJqZWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9TdWJqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9TdWJqZWN0LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9TdWJzY3JpYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9TdWJzY3JpYmVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9TdWJzY3JpYmVyLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2xpZnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbGlmdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxuXFxuXFxuXFxuXFxuXFxuXFxuZnVuY3Rpb24gc2hhcmUob3B0aW9ucykge1xcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxcbiAgICB2YXIgX2EgPSBvcHRpb25zLmNvbm5lY3RvciwgY29ubmVjdG9yID0gX2EgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBfU3ViamVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLlN1YmplY3QoKTsgfSA6IF9hLCBfYiA9IG9wdGlvbnMucmVzZXRPbkVycm9yLCByZXNldE9uRXJyb3IgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iLCBfYyA9IG9wdGlvbnMucmVzZXRPbkNvbXBsZXRlLCByZXNldE9uQ29tcGxldGUgPSBfYyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jLCBfZCA9IG9wdGlvbnMucmVzZXRPblJlZkNvdW50WmVybywgcmVzZXRPblJlZkNvdW50WmVybyA9IF9kID09PSB2b2lkIDAgPyB0cnVlIDogX2Q7XFxuICAgIHJldHVybiBmdW5jdGlvbiAod3JhcHBlclNvdXJjZSkge1xcbiAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSBudWxsO1xcbiAgICAgICAgdmFyIHJlc2V0Q29ubmVjdGlvbiA9IG51bGw7XFxuICAgICAgICB2YXIgc3ViamVjdCA9IG51bGw7XFxuICAgICAgICB2YXIgcmVmQ291bnQgPSAwO1xcbiAgICAgICAgdmFyIGhhc0NvbXBsZXRlZCA9IGZhbHNlO1xcbiAgICAgICAgdmFyIGhhc0Vycm9yZWQgPSBmYWxzZTtcXG4gICAgICAgIHZhciBjYW5jZWxSZXNldCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICByZXNldENvbm5lY3Rpb24gPT09IG51bGwgfHwgcmVzZXRDb25uZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNldENvbm5lY3Rpb24udW5zdWJzY3JpYmUoKTtcXG4gICAgICAgICAgICByZXNldENvbm5lY3Rpb24gPSBudWxsO1xcbiAgICAgICAgfTtcXG4gICAgICAgIHZhciByZXNldCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBjYW5jZWxSZXNldCgpO1xcbiAgICAgICAgICAgIGNvbm5lY3Rpb24gPSBzdWJqZWN0ID0gbnVsbDtcXG4gICAgICAgICAgICBoYXNDb21wbGV0ZWQgPSBoYXNFcnJvcmVkID0gZmFsc2U7XFxuICAgICAgICB9O1xcbiAgICAgICAgdmFyIHJlc2V0QW5kVW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgdmFyIGNvbm4gPSBjb25uZWN0aW9uO1xcbiAgICAgICAgICAgIHJlc2V0KCk7XFxuICAgICAgICAgICAgY29ubiA9PT0gbnVsbCB8fCBjb25uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25uLnVuc3Vic2NyaWJlKCk7XFxuICAgICAgICB9O1xcbiAgICAgICAgcmV0dXJuICgwLF91dGlsX2xpZnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5vcGVyYXRlKShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XFxuICAgICAgICAgICAgcmVmQ291bnQrKztcXG4gICAgICAgICAgICBpZiAoIWhhc0Vycm9yZWQgJiYgIWhhc0NvbXBsZXRlZCkge1xcbiAgICAgICAgICAgICAgICBjYW5jZWxSZXNldCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB2YXIgZGVzdCA9IChzdWJqZWN0ID0gc3ViamVjdCAhPT0gbnVsbCAmJiBzdWJqZWN0ICE9PSB2b2lkIDAgPyBzdWJqZWN0IDogY29ubmVjdG9yKCkpO1xcbiAgICAgICAgICAgIHN1YnNjcmliZXIuYWRkKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgcmVmQ291bnQtLTtcXG4gICAgICAgICAgICAgICAgaWYgKHJlZkNvdW50ID09PSAwICYmICFoYXNFcnJvcmVkICYmICFoYXNDb21wbGV0ZWQpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0Q29ubmVjdGlvbiA9IGhhbmRsZVJlc2V0KHJlc2V0QW5kVW5zdWJzY3JpYmUsIHJlc2V0T25SZWZDb3VudFplcm8pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgZGVzdC5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XFxuICAgICAgICAgICAgaWYgKCFjb25uZWN0aW9uKSB7XFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24gPSBuZXcgX1N1YnNjcmliZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5TYWZlU3Vic2NyaWJlcih7XFxuICAgICAgICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGRlc3QubmV4dCh2YWx1ZSk7IH0sXFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGVycikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0Vycm9yZWQgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbFJlc2V0KCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXRDb25uZWN0aW9uID0gaGFuZGxlUmVzZXQocmVzZXQsIHJlc2V0T25FcnJvciwgZXJyKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0LmVycm9yKGVycik7XFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDb21wbGV0ZWQgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbFJlc2V0KCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXRDb25uZWN0aW9uID0gaGFuZGxlUmVzZXQocmVzZXQsIHJlc2V0T25Db21wbGV0ZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdC5jb21wbGV0ZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICgwLF9vYnNlcnZhYmxlX2Zyb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5mcm9tKShzb3VyY2UpLnN1YnNjcmliZShjb25uZWN0aW9uKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KSh3cmFwcGVyU291cmNlKTtcXG4gICAgfTtcXG59XFxuZnVuY3Rpb24gaGFuZGxlUmVzZXQocmVzZXQsIG9uKSB7XFxuICAgIHZhciBhcmdzID0gW107XFxuICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XFxuICAgICAgICBhcmdzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xcbiAgICB9XFxuICAgIGlmIChvbiA9PT0gdHJ1ZSkge1xcbiAgICAgICAgcmVzZXQoKTtcXG4gICAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuICAgIGlmIChvbiA9PT0gZmFsc2UpIHtcXG4gICAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuICAgIHJldHVybiBvbi5hcHBseSh2b2lkIDAsICgwLHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uX19zcHJlYWRBcnJheSkoW10sICgwLHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uX19yZWFkKShhcmdzKSkpLnBpcGUoKDAsX29wZXJhdG9yc190YWtlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18udGFrZSkoMSkpXFxuICAgICAgICAuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc2V0KCk7IH0pO1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFyZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9EZXJpdkFQSUJhc2ljLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29wZXJhdG9ycy9zaGFyZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29wZXJhdG9ycy90YWtlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29wZXJhdG9ycy90YWtlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJ0YWtlXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gdGFrZSlcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX29ic2VydmFibGVfZW1wdHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL29ic2VydmFibGUvZW1wdHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29ic2VydmFibGUvZW1wdHkuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbGlmdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9saWZ0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2xpZnQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX09wZXJhdG9yU3Vic2NyaWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9PcGVyYXRvclN1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXIuanNcXFwiKTtcXG5cXG5cXG5cXG5mdW5jdGlvbiB0YWtlKGNvdW50KSB7XFxuICAgIHJldHVybiBjb3VudCA8PSAwXFxuICAgICAgICA/XFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gX29ic2VydmFibGVfZW1wdHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5FTVBUWTsgfVxcbiAgICAgICAgOiAoMCxfdXRpbF9saWZ0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18ub3BlcmF0ZSkoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgICAgIHZhciBzZWVuID0gMDtcXG4gICAgICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBfT3BlcmF0b3JTdWJzY3JpYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgICAgICBpZiAoKytzZWVuIDw9IGNvdW50KSB7XFxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50IDw9IHNlZW4pIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KSk7XFxuICAgICAgICB9KTtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFrZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9EZXJpdkFQSUJhc2ljLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29wZXJhdG9ycy90YWtlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL3Rocm93SWZFbXB0eS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29wZXJhdG9ycy90aHJvd0lmRW1wdHkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwidGhyb3dJZkVtcHR5XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gdGhyb3dJZkVtcHR5KVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9FbXB0eUVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL0VtcHR5RXJyb3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvRW1wdHlFcnJvci5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9saWZ0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvbGlmdC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfT3BlcmF0b3JTdWJzY3JpYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL09wZXJhdG9yU3Vic2NyaWJlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qc1xcXCIpO1xcblxcblxcblxcbmZ1bmN0aW9uIHRocm93SWZFbXB0eShlcnJvckZhY3RvcnkpIHtcXG4gICAgaWYgKGVycm9yRmFjdG9yeSA9PT0gdm9pZCAwKSB7IGVycm9yRmFjdG9yeSA9IGRlZmF1bHRFcnJvckZhY3Rvcnk7IH1cXG4gICAgcmV0dXJuICgwLF91dGlsX2xpZnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5vcGVyYXRlKShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XFxuICAgICAgICB2YXIgaGFzVmFsdWUgPSBmYWxzZTtcXG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUobmV3IF9PcGVyYXRvclN1YnNjcmliZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5PcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XFxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiAoaGFzVmFsdWUgPyBzdWJzY3JpYmVyLmNvbXBsZXRlKCkgOiBzdWJzY3JpYmVyLmVycm9yKGVycm9yRmFjdG9yeSgpKSk7IH0pKTtcXG4gICAgfSk7XFxufVxcbmZ1bmN0aW9uIGRlZmF1bHRFcnJvckZhY3RvcnkoKSB7XFxuICAgIHJldHVybiBuZXcgX3V0aWxfRW1wdHlFcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLkVtcHR5RXJyb3IoKTtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhyb3dJZkVtcHR5LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL3Rocm93SWZFbXB0eS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3NjaGVkdWxlZC9zY2hlZHVsZUFycmF5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3NjaGVkdWxlZC9zY2hlZHVsZUFycmF5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJzY2hlZHVsZUFycmF5XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gc2NoZWR1bGVBcnJheSlcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX09ic2VydmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL09ic2VydmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL09ic2VydmFibGUuanNcXFwiKTtcXG5cXG5mdW5jdGlvbiBzY2hlZHVsZUFycmF5KGlucHV0LCBzY2hlZHVsZXIpIHtcXG4gICAgcmV0dXJuIG5ldyBfT2JzZXJ2YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLk9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHZhciBpID0gMDtcXG4gICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGlmIChpID09PSBpbnB1dC5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KGlucHV0W2krK10pO1xcbiAgICAgICAgICAgICAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlKCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgfSk7XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjaGVkdWxlQXJyYXkuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9zY2hlZHVsZWQvc2NoZWR1bGVBcnJheS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3NjaGVkdWxlZC9zY2hlZHVsZUFzeW5jSXRlcmFibGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9zY2hlZHVsZWQvc2NoZWR1bGVBc3luY0l0ZXJhYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcInNjaGVkdWxlQXN5bmNJdGVyYWJsZVxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHNjaGVkdWxlQXN5bmNJdGVyYWJsZSlcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX09ic2VydmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL09ic2VydmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL09ic2VydmFibGUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1N1YnNjcmlwdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vU3Vic2NyaXB0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9TdWJzY3JpcHRpb24uanNcXFwiKTtcXG5cXG5cXG5mdW5jdGlvbiBzY2hlZHVsZUFzeW5jSXRlcmFibGUoaW5wdXQsIHNjaGVkdWxlcikge1xcbiAgICBpZiAoIWlucHV0KSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0l0ZXJhYmxlIGNhbm5vdCBiZSBudWxsJyk7XFxuICAgIH1cXG4gICAgcmV0dXJuIG5ldyBfT2JzZXJ2YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLk9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHZhciBzdWIgPSBuZXcgX1N1YnNjcmlwdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlN1YnNjcmlwdGlvbigpO1xcbiAgICAgICAgc3ViLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IGlucHV0W1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xcbiAgICAgICAgICAgIHN1Yi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICAgICAgICAgICAgaXRlcmF0b3IubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHJlc3VsdC52YWx1ZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2NoZWR1bGUoKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfSkpO1xcbiAgICAgICAgfSkpO1xcbiAgICAgICAgcmV0dXJuIHN1YjtcXG4gICAgfSk7XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjaGVkdWxlQXN5bmNJdGVyYWJsZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9EZXJpdkFQSUJhc2ljLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3NjaGVkdWxlZC9zY2hlZHVsZUFzeW5jSXRlcmFibGUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9zY2hlZHVsZWQvc2NoZWR1bGVJdGVyYWJsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9zY2hlZHVsZWQvc2NoZWR1bGVJdGVyYWJsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwic2NoZWR1bGVJdGVyYWJsZVxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHNjaGVkdWxlSXRlcmFibGUpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9PYnNlcnZhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9PYnNlcnZhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9PYnNlcnZhYmxlLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zeW1ib2xfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3N5bWJvbC9pdGVyYXRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvc3ltYm9sL2l0ZXJhdG9yLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2lzRnVuY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvaXNGdW5jdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pc0Z1bmN0aW9uLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2NhdWdodFNjaGVkdWxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2NhdWdodFNjaGVkdWxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2NhdWdodFNjaGVkdWxlLmpzXFxcIik7XFxuXFxuXFxuXFxuXFxuZnVuY3Rpb24gc2NoZWR1bGVJdGVyYWJsZShpbnB1dCwgc2NoZWR1bGVyKSB7XFxuICAgIHJldHVybiBuZXcgX09ic2VydmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5PYnNlcnZhYmxlKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XFxuICAgICAgICB2YXIgaXRlcmF0b3I7XFxuICAgICAgICBzdWJzY3JpYmVyLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGl0ZXJhdG9yID0gaW5wdXRbX3N5bWJvbF9pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLml0ZXJhdG9yXSgpO1xcbiAgICAgICAgICAgICgwLF91dGlsX2NhdWdodFNjaGVkdWxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uY2F1Z2h0U2NoZWR1bGUpKHN1YnNjcmliZXIsIHNjaGVkdWxlciwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBpdGVyYXRvci5uZXh0KCksIHZhbHVlID0gX2EudmFsdWUsIGRvbmUgPSBfYS5kb25lO1xcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGUoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSkpO1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuICgwLF91dGlsX2lzRnVuY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5pc0Z1bmN0aW9uKShpdGVyYXRvciA9PT0gbnVsbCB8fCBpdGVyYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXRlcmF0b3IucmV0dXJuKSAmJiBpdGVyYXRvci5yZXR1cm4oKTsgfTtcXG4gICAgfSk7XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjaGVkdWxlSXRlcmFibGUuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9zY2hlZHVsZWQvc2NoZWR1bGVJdGVyYWJsZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3NjaGVkdWxlZC9zY2hlZHVsZU9ic2VydmFibGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9zY2hlZHVsZWQvc2NoZWR1bGVPYnNlcnZhYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcInNjaGVkdWxlT2JzZXJ2YWJsZVxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHNjaGVkdWxlT2JzZXJ2YWJsZSlcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX09ic2VydmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL09ic2VydmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL09ic2VydmFibGUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1N1YnNjcmlwdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vU3Vic2NyaXB0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9TdWJzY3JpcHRpb24uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N5bWJvbF9vYnNlcnZhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9zeW1ib2wvb2JzZXJ2YWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvc3ltYm9sL29ic2VydmFibGUuanNcXFwiKTtcXG5cXG5cXG5cXG5mdW5jdGlvbiBzY2hlZHVsZU9ic2VydmFibGUoaW5wdXQsIHNjaGVkdWxlcikge1xcbiAgICByZXR1cm4gbmV3IF9PYnNlcnZhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIHN1YiA9IG5ldyBfU3Vic2NyaXB0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uU3Vic2NyaXB0aW9uKCk7XFxuICAgICAgICBzdWIuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgdmFyIG9ic2VydmFibGUgPSBpbnB1dFtfc3ltYm9sX29ic2VydmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5vYnNlcnZhYmxlXSgpO1xcbiAgICAgICAgICAgIHN1Yi5hZGQob2JzZXJ2YWJsZS5zdWJzY3JpYmUoe1xcbiAgICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHsgc3ViLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gc3Vic2NyaWJlci5uZXh0KHZhbHVlKTsgfSkpOyB9LFxcbiAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGVycikgeyBzdWIuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJzY3JpYmVyLmVycm9yKGVycik7IH0pKTsgfSxcXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHsgc3ViLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gc3Vic2NyaWJlci5jb21wbGV0ZSgpOyB9KSk7IH0sXFxuICAgICAgICAgICAgfSkpO1xcbiAgICAgICAgfSkpO1xcbiAgICAgICAgcmV0dXJuIHN1YjtcXG4gICAgfSk7XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjaGVkdWxlT2JzZXJ2YWJsZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9EZXJpdkFQSUJhc2ljLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3NjaGVkdWxlZC9zY2hlZHVsZU9ic2VydmFibGUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9zY2hlZHVsZWQvc2NoZWR1bGVQcm9taXNlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvc2NoZWR1bGVkL3NjaGVkdWxlUHJvbWlzZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJzY2hlZHVsZVByb21pc2VcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBzY2hlZHVsZVByb21pc2UpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9PYnNlcnZhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9PYnNlcnZhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9PYnNlcnZhYmxlLmpzXFxcIik7XFxuXFxuZnVuY3Rpb24gc2NoZWR1bGVQcm9taXNlKGlucHV0LCBzY2hlZHVsZXIpIHtcXG4gICAgcmV0dXJuIG5ldyBfT2JzZXJ2YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLk9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcXG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7IH0pKTtcXG4gICAgICAgICAgICAgICAgfSkpO1xcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YnNjcmliZXIuZXJyb3IoZXJyKTsgfSkpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSk7XFxuICAgIH0pO1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2hlZHVsZVByb21pc2UuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9zY2hlZHVsZWQvc2NoZWR1bGVQcm9taXNlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvc2NoZWR1bGVkL3NjaGVkdWxlUmVhZGFibGVTdHJlYW1MaWtlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9zY2hlZHVsZWQvc2NoZWR1bGVSZWFkYWJsZVN0cmVhbUxpa2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJzY2hlZHVsZVJlYWRhYmxlU3RyZWFtTGlrZVxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHNjaGVkdWxlUmVhZGFibGVTdHJlYW1MaWtlKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2NoZWR1bGVBc3luY0l0ZXJhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NjaGVkdWxlQXN5bmNJdGVyYWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvc2NoZWR1bGVkL3NjaGVkdWxlQXN5bmNJdGVyYWJsZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9pc1JlYWRhYmxlU3RyZWFtTGlrZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9pc1JlYWRhYmxlU3RyZWFtTGlrZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pc1JlYWRhYmxlU3RyZWFtTGlrZS5qc1xcXCIpO1xcblxcblxcbmZ1bmN0aW9uIHNjaGVkdWxlUmVhZGFibGVTdHJlYW1MaWtlKGlucHV0LCBzY2hlZHVsZXIpIHtcXG4gICAgcmV0dXJuICgwLF9zY2hlZHVsZUFzeW5jSXRlcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5zY2hlZHVsZUFzeW5jSXRlcmFibGUpKCgwLF91dGlsX2lzUmVhZGFibGVTdHJlYW1MaWtlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18ucmVhZGFibGVTdHJlYW1MaWtlVG9Bc3luY0dlbmVyYXRvcikoaW5wdXQpLCBzY2hlZHVsZXIpO1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2hlZHVsZVJlYWRhYmxlU3RyZWFtTGlrZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9EZXJpdkFQSUJhc2ljLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3NjaGVkdWxlZC9zY2hlZHVsZVJlYWRhYmxlU3RyZWFtTGlrZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3NjaGVkdWxlZC9zY2hlZHVsZWQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9zY2hlZHVsZWQvc2NoZWR1bGVkLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcInNjaGVkdWxlZFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHNjaGVkdWxlZClcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NjaGVkdWxlT2JzZXJ2YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zY2hlZHVsZU9ic2VydmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3NjaGVkdWxlZC9zY2hlZHVsZU9ic2VydmFibGUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NjaGVkdWxlUHJvbWlzZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zY2hlZHVsZVByb21pc2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3NjaGVkdWxlZC9zY2hlZHVsZVByb21pc2UuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NjaGVkdWxlQXJyYXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc2NoZWR1bGVBcnJheSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvc2NoZWR1bGVkL3NjaGVkdWxlQXJyYXkuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NjaGVkdWxlSXRlcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc2NoZWR1bGVJdGVyYWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvc2NoZWR1bGVkL3NjaGVkdWxlSXRlcmFibGUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NjaGVkdWxlQXN5bmNJdGVyYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zY2hlZHVsZUFzeW5jSXRlcmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3NjaGVkdWxlZC9zY2hlZHVsZUFzeW5jSXRlcmFibGUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaXNJbnRlcm9wT2JzZXJ2YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9pc0ludGVyb3BPYnNlcnZhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2lzSW50ZXJvcE9ic2VydmFibGUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaXNQcm9taXNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2lzUHJvbWlzZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pc1Byb21pc2UuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaXNBcnJheUxpa2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvaXNBcnJheUxpa2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvaXNBcnJheUxpa2UuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaXNJdGVyYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9pc0l0ZXJhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2lzSXRlcmFibGUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaXNBc3luY0l0ZXJhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2lzQXN5bmNJdGVyYWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pc0FzeW5jSXRlcmFibGUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfdGhyb3dVbm9ic2VydmFibGVFcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvdGhyb3dVbm9ic2VydmFibGVFcnJvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC90aHJvd1Vub2JzZXJ2YWJsZUVycm9yLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2lzUmVhZGFibGVTdHJlYW1MaWtlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9pc1JlYWRhYmxlU3RyZWFtTGlrZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pc1JlYWRhYmxlU3RyZWFtTGlrZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2NoZWR1bGVSZWFkYWJsZVN0cmVhbUxpa2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NjaGVkdWxlUmVhZGFibGVTdHJlYW1MaWtlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9zY2hlZHVsZWQvc2NoZWR1bGVSZWFkYWJsZVN0cmVhbUxpa2UuanNcXFwiKTtcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5mdW5jdGlvbiBzY2hlZHVsZWQoaW5wdXQsIHNjaGVkdWxlcikge1xcbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xcbiAgICAgICAgaWYgKCgwLF91dGlsX2lzSW50ZXJvcE9ic2VydmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc0ludGVyb3BPYnNlcnZhYmxlKShpbnB1dCkpIHtcXG4gICAgICAgICAgICByZXR1cm4gKDAsX3NjaGVkdWxlT2JzZXJ2YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLnNjaGVkdWxlT2JzZXJ2YWJsZSkoaW5wdXQsIHNjaGVkdWxlcik7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoKDAsX3V0aWxfaXNBcnJheUxpa2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5pc0FycmF5TGlrZSkoaW5wdXQpKSB7XFxuICAgICAgICAgICAgcmV0dXJuICgwLF9zY2hlZHVsZUFycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uc2NoZWR1bGVBcnJheSkoaW5wdXQsIHNjaGVkdWxlcik7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoKDAsX3V0aWxfaXNQcm9taXNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18uaXNQcm9taXNlKShpbnB1dCkpIHtcXG4gICAgICAgICAgICByZXR1cm4gKDAsX3NjaGVkdWxlUHJvbWlzZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLnNjaGVkdWxlUHJvbWlzZSkoaW5wdXQsIHNjaGVkdWxlcik7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoKDAsX3V0aWxfaXNBc3luY0l0ZXJhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uaXNBc3luY0l0ZXJhYmxlKShpbnB1dCkpIHtcXG4gICAgICAgICAgICByZXR1cm4gKDAsX3NjaGVkdWxlQXN5bmNJdGVyYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fLnNjaGVkdWxlQXN5bmNJdGVyYWJsZSkoaW5wdXQsIHNjaGVkdWxlcik7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoKDAsX3V0aWxfaXNJdGVyYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fLmlzSXRlcmFibGUpKGlucHV0KSkge1xcbiAgICAgICAgICAgIHJldHVybiAoMCxfc2NoZWR1bGVJdGVyYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fLnNjaGVkdWxlSXRlcmFibGUpKGlucHV0LCBzY2hlZHVsZXIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCgwLF91dGlsX2lzUmVhZGFibGVTdHJlYW1MaWtlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fLmlzUmVhZGFibGVTdHJlYW1MaWtlKShpbnB1dCkpIHtcXG4gICAgICAgICAgICByZXR1cm4gKDAsX3NjaGVkdWxlUmVhZGFibGVTdHJlYW1MaWtlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fLnNjaGVkdWxlUmVhZGFibGVTdHJlYW1MaWtlKShpbnB1dCwgc2NoZWR1bGVyKTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICB0aHJvdyAoMCxfdXRpbF90aHJvd1Vub2JzZXJ2YWJsZUVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fLmNyZWF0ZUludmFsaWRPYnNlcnZhYmxlVHlwZUVycm9yKShpbnB1dCk7XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjaGVkdWxlZC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9EZXJpdkFQSUJhc2ljLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3NjaGVkdWxlZC9zY2hlZHVsZWQuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9zY2hlZHVsZXIvdGltZW91dFByb3ZpZGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvc2NoZWR1bGVyL3RpbWVvdXRQcm92aWRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJ0aW1lb3V0UHJvdmlkZXJcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyB0aW1lb3V0UHJvdmlkZXIpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzXFxcIik7XFxuXFxudmFyIHRpbWVvdXRQcm92aWRlciA9IHtcXG4gICAgc2V0VGltZW91dDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XFxuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gdGltZW91dFByb3ZpZGVyLmRlbGVnYXRlO1xcbiAgICAgICAgcmV0dXJuICgoZGVsZWdhdGUgPT09IG51bGwgfHwgZGVsZWdhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlbGVnYXRlLnNldFRpbWVvdXQpIHx8IHNldFRpbWVvdXQpLmFwcGx5KHZvaWQgMCwgKDAsdHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5fX3NwcmVhZEFycmF5KShbXSwgKDAsdHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5fX3JlYWQpKGFyZ3MpKSk7XFxuICAgIH0sXFxuICAgIGNsZWFyVGltZW91dDogZnVuY3Rpb24gKGhhbmRsZSkge1xcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gdGltZW91dFByb3ZpZGVyLmRlbGVnYXRlO1xcbiAgICAgICAgcmV0dXJuICgoZGVsZWdhdGUgPT09IG51bGwgfHwgZGVsZWdhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlbGVnYXRlLmNsZWFyVGltZW91dCkgfHwgY2xlYXJUaW1lb3V0KShoYW5kbGUpO1xcbiAgICB9LFxcbiAgICBkZWxlZ2F0ZTogdW5kZWZpbmVkLFxcbn07XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZW91dFByb3ZpZGVyLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvc2NoZWR1bGVyL3RpbWVvdXRQcm92aWRlci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3N5bWJvbC9pdGVyYXRvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvc3ltYm9sL2l0ZXJhdG9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZ2V0U3ltYm9sSXRlcmF0b3JcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBnZXRTeW1ib2xJdGVyYXRvciksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiaXRlcmF0b3JcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBpdGVyYXRvcilcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG5mdW5jdGlvbiBnZXRTeW1ib2xJdGVyYXRvcigpIHtcXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicgfHwgIVN5bWJvbC5pdGVyYXRvcikge1xcbiAgICAgICAgcmV0dXJuICdAQGl0ZXJhdG9yJztcXG4gICAgfVxcbiAgICByZXR1cm4gU3ltYm9sLml0ZXJhdG9yO1xcbn1cXG52YXIgaXRlcmF0b3IgPSBnZXRTeW1ib2xJdGVyYXRvcigpO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWl0ZXJhdG9yLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvc3ltYm9sL2l0ZXJhdG9yLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvc3ltYm9sL29ic2VydmFibGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvc3ltYm9sL29ic2VydmFibGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIm9ic2VydmFibGVcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBvYnNlcnZhYmxlKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbnZhciBvYnNlcnZhYmxlID0gKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5vYnNlcnZhYmxlKSB8fCAnQEBvYnNlcnZhYmxlJzsgfSkoKTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYnNlcnZhYmxlLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvc3ltYm9sL29ic2VydmFibGUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL0VtcHR5RXJyb3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvRW1wdHlFcnJvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIkVtcHR5RXJyb3JcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBFbXB0eUVycm9yKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY3JlYXRlRXJyb3JDbGFzc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jcmVhdGVFcnJvckNsYXNzICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2NyZWF0ZUVycm9yQ2xhc3MuanNcXFwiKTtcXG5cXG52YXIgRW1wdHlFcnJvciA9ICgwLF9jcmVhdGVFcnJvckNsYXNzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uY3JlYXRlRXJyb3JDbGFzcykoZnVuY3Rpb24gKF9zdXBlcikgeyByZXR1cm4gZnVuY3Rpb24gRW1wdHlFcnJvckltcGwoKSB7XFxuICAgIF9zdXBlcih0aGlzKTtcXG4gICAgdGhpcy5uYW1lID0gJ0VtcHR5RXJyb3InO1xcbiAgICB0aGlzLm1lc3NhZ2UgPSAnbm8gZWxlbWVudHMgaW4gc2VxdWVuY2UnO1xcbn07IH0pO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVtcHR5RXJyb3IuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL0VtcHR5RXJyb3IuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9PYmplY3RVbnN1YnNjcmliZWRFcnJvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJPYmplY3RVbnN1YnNjcmliZWRFcnJvclxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY3JlYXRlRXJyb3JDbGFzc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jcmVhdGVFcnJvckNsYXNzICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2NyZWF0ZUVycm9yQ2xhc3MuanNcXFwiKTtcXG5cXG52YXIgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IgPSAoMCxfY3JlYXRlRXJyb3JDbGFzc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmNyZWF0ZUVycm9yQ2xhc3MpKGZ1bmN0aW9uIChfc3VwZXIpIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uIE9iamVjdFVuc3Vic2NyaWJlZEVycm9ySW1wbCgpIHtcXG4gICAgICAgIF9zdXBlcih0aGlzKTtcXG4gICAgICAgIHRoaXMubmFtZSA9ICdPYmplY3RVbnN1YnNjcmliZWRFcnJvcic7XFxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSAnb2JqZWN0IHVuc3Vic2NyaWJlZCc7XFxuICAgIH07XFxufSk7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9VbnN1YnNjcmlwdGlvbkVycm9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL1Vuc3Vic2NyaXB0aW9uRXJyb3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJVbnN1YnNjcmlwdGlvbkVycm9yXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVW5zdWJzY3JpcHRpb25FcnJvcilcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NyZWF0ZUVycm9yQ2xhc3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY3JlYXRlRXJyb3JDbGFzcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9jcmVhdGVFcnJvckNsYXNzLmpzXFxcIik7XFxuXFxudmFyIFVuc3Vic2NyaXB0aW9uRXJyb3IgPSAoMCxfY3JlYXRlRXJyb3JDbGFzc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmNyZWF0ZUVycm9yQ2xhc3MpKGZ1bmN0aW9uIChfc3VwZXIpIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uIFVuc3Vic2NyaXB0aW9uRXJyb3JJbXBsKGVycm9ycykge1xcbiAgICAgICAgX3N1cGVyKHRoaXMpO1xcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gZXJyb3JzXFxuICAgICAgICAgICAgPyBlcnJvcnMubGVuZ3RoICsgXFxcIiBlcnJvcnMgb2NjdXJyZWQgZHVyaW5nIHVuc3Vic2NyaXB0aW9uOlxcXFxuXFxcIiArIGVycm9ycy5tYXAoZnVuY3Rpb24gKGVyciwgaSkgeyByZXR1cm4gaSArIDEgKyBcXFwiKSBcXFwiICsgZXJyLnRvU3RyaW5nKCk7IH0pLmpvaW4oJ1xcXFxuICAnKVxcbiAgICAgICAgICAgIDogJyc7XFxuICAgICAgICB0aGlzLm5hbWUgPSAnVW5zdWJzY3JpcHRpb25FcnJvcic7XFxuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcXG4gICAgfTtcXG59KTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1VbnN1YnNjcmlwdGlvbkVycm9yLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9VbnN1YnNjcmlwdGlvbkVycm9yLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9hcnJSZW1vdmUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9hcnJSZW1vdmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImFyclJlbW92ZVxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGFyclJlbW92ZSlcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG5mdW5jdGlvbiBhcnJSZW1vdmUoYXJyLCBpdGVtKSB7XFxuICAgIGlmIChhcnIpIHtcXG4gICAgICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xcbiAgICAgICAgMCA8PSBpbmRleCAmJiBhcnIuc3BsaWNlKGluZGV4LCAxKTtcXG4gICAgfVxcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJSZW1vdmUuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2FyclJlbW92ZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvY2F1Z2h0U2NoZWR1bGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2NhdWdodFNjaGVkdWxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImNhdWdodFNjaGVkdWxlXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gY2F1Z2h0U2NoZWR1bGUpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuZnVuY3Rpb24gY2F1Z2h0U2NoZWR1bGUoc3Vic2NyaWJlciwgc2NoZWR1bGVyLCBleGVjdXRlLCBkZWxheSkge1xcbiAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cXG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoKSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGV4ZWN1dGUuY2FsbCh0aGlzKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycik7XFxuICAgICAgICB9XFxuICAgIH0sIGRlbGF5KTtcXG4gICAgc3Vic2NyaWJlci5hZGQoc3Vic2NyaXB0aW9uKTtcXG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2F1Z2h0U2NoZWR1bGUuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2NhdWdodFNjaGVkdWxlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9jcmVhdGVFcnJvckNsYXNzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2NyZWF0ZUVycm9yQ2xhc3MuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJjcmVhdGVFcnJvckNsYXNzXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gY3JlYXRlRXJyb3JDbGFzcylcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG5mdW5jdGlvbiBjcmVhdGVFcnJvckNsYXNzKGNyZWF0ZUltcGwpIHtcXG4gICAgdmFyIF9zdXBlciA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xcbiAgICAgICAgRXJyb3IuY2FsbChpbnN0YW5jZSk7XFxuICAgICAgICBpbnN0YW5jZS5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xcbiAgICB9O1xcbiAgICB2YXIgY3RvckZ1bmMgPSBjcmVhdGVJbXBsKF9zdXBlcik7XFxuICAgIGN0b3JGdW5jLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcXG4gICAgY3RvckZ1bmMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvckZ1bmM7XFxuICAgIHJldHVybiBjdG9yRnVuYztcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlRXJyb3JDbGFzcy5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9EZXJpdkFQSUJhc2ljLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvY3JlYXRlRXJyb3JDbGFzcy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvZXJyb3JDb250ZXh0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvZXJyb3JDb250ZXh0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJlcnJvckNvbnRleHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBlcnJvckNvbnRleHQpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImNhcHR1cmVFcnJvclxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGNhcHR1cmVFcnJvcilcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbmZpZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vY29uZmlnICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9jb25maWcuanNcXFwiKTtcXG5cXG52YXIgY29udGV4dCA9IG51bGw7XFxuZnVuY3Rpb24gZXJyb3JDb250ZXh0KGNiKSB7XFxuICAgIGlmIChfY29uZmlnX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcpIHtcXG4gICAgICAgIHZhciBpc1Jvb3QgPSAhY29udGV4dDtcXG4gICAgICAgIGlmIChpc1Jvb3QpIHtcXG4gICAgICAgICAgICBjb250ZXh0ID0geyBlcnJvclRocm93bjogZmFsc2UsIGVycm9yOiBudWxsIH07XFxuICAgICAgICB9XFxuICAgICAgICBjYigpO1xcbiAgICAgICAgaWYgKGlzUm9vdCkge1xcbiAgICAgICAgICAgIHZhciBfYSA9IGNvbnRleHQsIGVycm9yVGhyb3duID0gX2EuZXJyb3JUaHJvd24sIGVycm9yID0gX2EuZXJyb3I7XFxuICAgICAgICAgICAgY29udGV4dCA9IG51bGw7XFxuICAgICAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XFxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBlbHNlIHtcXG4gICAgICAgIGNiKCk7XFxuICAgIH1cXG59XFxuZnVuY3Rpb24gY2FwdHVyZUVycm9yKGVycikge1xcbiAgICBpZiAoX2NvbmZpZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmNvbmZpZy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nICYmIGNvbnRleHQpIHtcXG4gICAgICAgIGNvbnRleHQuZXJyb3JUaHJvd24gPSB0cnVlO1xcbiAgICAgICAgY29udGV4dC5lcnJvciA9IGVycjtcXG4gICAgfVxcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvckNvbnRleHQuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2Vycm9yQ29udGV4dC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvaWRlbnRpdHkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2lkZW50aXR5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImlkZW50aXR5XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gaWRlbnRpdHkpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xcbiAgICByZXR1cm4geDtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWRlbnRpdHkuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2lkZW50aXR5LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pc0FycmF5TGlrZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvaXNBcnJheUxpa2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiaXNBcnJheUxpa2VcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBpc0FycmF5TGlrZSlcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG52YXIgaXNBcnJheUxpa2UgPSAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggJiYgdHlwZW9mIHgubGVuZ3RoID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgeCAhPT0gJ2Z1bmN0aW9uJzsgfSk7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNBcnJheUxpa2UuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2lzQXJyYXlMaWtlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pc0FzeW5jSXRlcmFibGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pc0FzeW5jSXRlcmFibGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImlzQXN5bmNJdGVyYWJsZVxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGlzQXN5bmNJdGVyYWJsZSlcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2lzRnVuY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNGdW5jdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pc0Z1bmN0aW9uLmpzXFxcIik7XFxuXFxuZnVuY3Rpb24gaXNBc3luY0l0ZXJhYmxlKG9iaikge1xcbiAgICByZXR1cm4gU3ltYm9sLmFzeW5jSXRlcmF0b3IgJiYgKDAsX2lzRnVuY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc0Z1bmN0aW9uKShvYmogPT09IG51bGwgfHwgb2JqID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKTtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNBc3luY0l0ZXJhYmxlLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pc0FzeW5jSXRlcmFibGUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2lzRnVuY3Rpb24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvaXNGdW5jdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImlzRnVuY3Rpb25cXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBpc0Z1bmN0aW9uKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNGdW5jdGlvbi5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9EZXJpdkFQSUJhc2ljLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvaXNGdW5jdGlvbi5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvaXNJbnRlcm9wT2JzZXJ2YWJsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pc0ludGVyb3BPYnNlcnZhYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiaXNJbnRlcm9wT2JzZXJ2YWJsZVxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGlzSW50ZXJvcE9ic2VydmFibGUpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zeW1ib2xfb2JzZXJ2YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vc3ltYm9sL29ic2VydmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3N5bWJvbC9vYnNlcnZhYmxlLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pc0Z1bmN0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzRnVuY3Rpb24gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvaXNGdW5jdGlvbi5qc1xcXCIpO1xcblxcblxcbmZ1bmN0aW9uIGlzSW50ZXJvcE9ic2VydmFibGUoaW5wdXQpIHtcXG4gICAgcmV0dXJuICgwLF9pc0Z1bmN0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNGdW5jdGlvbikoaW5wdXRbX3N5bWJvbF9vYnNlcnZhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18ub2JzZXJ2YWJsZV0pO1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0ludGVyb3BPYnNlcnZhYmxlLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pc0ludGVyb3BPYnNlcnZhYmxlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pc0l0ZXJhYmxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2lzSXRlcmFibGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJpc0l0ZXJhYmxlXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gaXNJdGVyYWJsZSlcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N5bWJvbF9pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vc3ltYm9sL2l0ZXJhdG9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9zeW1ib2wvaXRlcmF0b3IuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2lzRnVuY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNGdW5jdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pc0Z1bmN0aW9uLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gaXNJdGVyYWJsZShpbnB1dCkge1xcbiAgICByZXR1cm4gKDAsX2lzRnVuY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pc0Z1bmN0aW9uKShpbnB1dCA9PT0gbnVsbCB8fCBpbnB1dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5wdXRbX3N5bWJvbF9pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLml0ZXJhdG9yXSk7XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzSXRlcmFibGUuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2lzSXRlcmFibGUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2lzUHJvbWlzZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2lzUHJvbWlzZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiaXNQcm9taXNlXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gaXNQcm9taXNlKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaXNGdW5jdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0Z1bmN0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2lzRnVuY3Rpb24uanNcXFwiKTtcXG5cXG5mdW5jdGlvbiBpc1Byb21pc2UodmFsdWUpIHtcXG4gICAgcmV0dXJuICgwLF9pc0Z1bmN0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNGdW5jdGlvbikodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLnRoZW4pO1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc1Byb21pc2UuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2lzUHJvbWlzZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvaXNSZWFkYWJsZVN0cmVhbUxpa2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2lzUmVhZGFibGVTdHJlYW1MaWtlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcInJlYWRhYmxlU3RyZWFtTGlrZVRvQXN5bmNHZW5lcmF0b3JcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyByZWFkYWJsZVN0cmVhbUxpa2VUb0FzeW5jR2VuZXJhdG9yKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJpc1JlYWRhYmxlU3RyZWFtTGlrZVxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGlzUmVhZGFibGVTdHJlYW1MaWtlKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaXNGdW5jdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0Z1bmN0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2lzRnVuY3Rpb24uanNcXFwiKTtcXG5cXG5cXG5mdW5jdGlvbiByZWFkYWJsZVN0cmVhbUxpa2VUb0FzeW5jR2VuZXJhdG9yKHJlYWRhYmxlU3RyZWFtKSB7XFxuICAgIHJldHVybiAoMCx0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLl9fYXN5bmNHZW5lcmF0b3IpKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gcmVhZGFibGVTdHJlYW1MaWtlVG9Bc3luY0dlbmVyYXRvcl8xKCkge1xcbiAgICAgICAgdmFyIHJlYWRlciwgX2EsIHZhbHVlLCBkb25lO1xcbiAgICAgICAgcmV0dXJuICgwLHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uX19nZW5lcmF0b3IpKHRoaXMsIGZ1bmN0aW9uIChfYikge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gcmVhZGFibGVTdHJlYW0uZ2V0UmVhZGVyKCk7XFxuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XFxuICAgICAgICAgICAgICAgIGNhc2UgMTpcXG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMSwgLCA5LCAxMF0pO1xcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAyO1xcbiAgICAgICAgICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgICAgICAgICAgICBpZiAoZmFsc2UpIHt9XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsICgwLHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uX19hd2FpdCkocmVhZGVyLnJlYWQoKSldO1xcbiAgICAgICAgICAgICAgICBjYXNlIDM6XFxuICAgICAgICAgICAgICAgICAgICBfYSA9IF9iLnNlbnQoKSwgdmFsdWUgPSBfYS52YWx1ZSwgZG9uZSA9IF9hLmRvbmU7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRvbmUpIHJldHVybiBbMywgNV07XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsICgwLHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uX19hd2FpdCkodm9pZCAwKV07XFxuICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyLCBfYi5zZW50KCldO1xcbiAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbNCwgKDAsdHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5fX2F3YWl0KSh2YWx1ZSldO1xcbiAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbNCwgX2Iuc2VudCgpXTtcXG4gICAgICAgICAgICAgICAgY2FzZSA3OlxcbiAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszLCAyXTtcXG4gICAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gWzMsIDEwXTtcXG4gICAgICAgICAgICAgICAgY2FzZSA5OlxcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzddO1xcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzJdO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICB9KTtcXG59XFxuZnVuY3Rpb24gaXNSZWFkYWJsZVN0cmVhbUxpa2Uob2JqKSB7XFxuICAgIHJldHVybiAoMCxfaXNGdW5jdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmlzRnVuY3Rpb24pKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iai5nZXRSZWFkZXIpO1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc1JlYWRhYmxlU3RyZWFtTGlrZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9EZXJpdkFQSUJhc2ljLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvaXNSZWFkYWJsZVN0cmVhbUxpa2UuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2xpZnQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvbGlmdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImhhc0xpZnRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBoYXNMaWZ0KSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJvcGVyYXRlXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gb3BlcmF0ZSlcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2lzRnVuY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNGdW5jdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pc0Z1bmN0aW9uLmpzXFxcIik7XFxuXFxuZnVuY3Rpb24gaGFzTGlmdChzb3VyY2UpIHtcXG4gICAgcmV0dXJuICgwLF9pc0Z1bmN0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaXNGdW5jdGlvbikoc291cmNlID09PSBudWxsIHx8IHNvdXJjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc291cmNlLmxpZnQpO1xcbn1cXG5mdW5jdGlvbiBvcGVyYXRlKGluaXQpIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHtcXG4gICAgICAgIGlmIChoYXNMaWZ0KHNvdXJjZSkpIHtcXG4gICAgICAgICAgICByZXR1cm4gc291cmNlLmxpZnQoZnVuY3Rpb24gKGxpZnRlZFNvdXJjZSkge1xcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluaXQobGlmdGVkU291cmNlLCB0aGlzKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGVycik7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VuYWJsZSB0byBsaWZ0IHVua25vd24gT2JzZXJ2YWJsZSB0eXBlJyk7XFxuICAgIH07XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpZnQuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2xpZnQuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL25vb3AuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvbm9vcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIm5vb3BcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBub29wKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbmZ1bmN0aW9uIG5vb3AoKSB7IH1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub29wLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9ub29wLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9waXBlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL3BpcGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJwaXBlXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gcGlwZSksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwicGlwZUZyb21BcnJheVxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHBpcGVGcm9tQXJyYXkpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pZGVudGl0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pZGVudGl0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pZGVudGl0eS5qc1xcXCIpO1xcblxcbmZ1bmN0aW9uIHBpcGUoKSB7XFxuICAgIHZhciBmbnMgPSBbXTtcXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcXG4gICAgICAgIGZuc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xcbiAgICB9XFxuICAgIHJldHVybiBwaXBlRnJvbUFycmF5KGZucyk7XFxufVxcbmZ1bmN0aW9uIHBpcGVGcm9tQXJyYXkoZm5zKSB7XFxuICAgIGlmIChmbnMubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICByZXR1cm4gX2lkZW50aXR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaWRlbnRpdHk7XFxuICAgIH1cXG4gICAgaWYgKGZucy5sZW5ndGggPT09IDEpIHtcXG4gICAgICAgIHJldHVybiBmbnNbMF07XFxuICAgIH1cXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBpcGVkKGlucHV0KSB7XFxuICAgICAgICByZXR1cm4gZm5zLnJlZHVjZShmdW5jdGlvbiAocHJldiwgZm4pIHsgcmV0dXJuIGZuKHByZXYpOyB9LCBpbnB1dCk7XFxuICAgIH07XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBpcGUuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL3BpcGUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL3JlcG9ydFVuaGFuZGxlZEVycm9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9yZXBvcnRVbmhhbmRsZWRFcnJvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJyZXBvcnRVbmhhbmRsZWRFcnJvclxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHJlcG9ydFVuaGFuZGxlZEVycm9yKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29uZmlnX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9jb25maWcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL2NvbmZpZy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2NoZWR1bGVyX3RpbWVvdXRQcm92aWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vc2NoZWR1bGVyL3RpbWVvdXRQcm92aWRlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvc2NoZWR1bGVyL3RpbWVvdXRQcm92aWRlci5qc1xcXCIpO1xcblxcblxcbmZ1bmN0aW9uIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycikge1xcbiAgICBfc2NoZWR1bGVyX3RpbWVvdXRQcm92aWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnRpbWVvdXRQcm92aWRlci5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBvblVuaGFuZGxlZEVycm9yID0gX2NvbmZpZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmNvbmZpZy5vblVuaGFuZGxlZEVycm9yO1xcbiAgICAgICAgaWYgKG9uVW5oYW5kbGVkRXJyb3IpIHtcXG4gICAgICAgICAgICBvblVuaGFuZGxlZEVycm9yKGVycik7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICB0aHJvdyBlcnI7XFxuICAgICAgICB9XFxuICAgIH0pO1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXBvcnRVbmhhbmRsZWRFcnJvci5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9EZXJpdkFQSUJhc2ljLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvcmVwb3J0VW5oYW5kbGVkRXJyb3IuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL3Rocm93VW5vYnNlcnZhYmxlRXJyb3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvdGhyb3dVbm9ic2VydmFibGVFcnJvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImNyZWF0ZUludmFsaWRPYnNlcnZhYmxlVHlwZUVycm9yXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gY3JlYXRlSW52YWxpZE9ic2VydmFibGVUeXBlRXJyb3IpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuZnVuY3Rpb24gY3JlYXRlSW52YWxpZE9ic2VydmFibGVUeXBlRXJyb3IoaW5wdXQpIHtcXG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXFxcIllvdSBwcm92aWRlZCBcXFwiICsgKGlucHV0ICE9PSBudWxsICYmIHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgPyAnYW4gaW52YWxpZCBvYmplY3QnIDogXFxcIidcXFwiICsgaW5wdXQgKyBcXFwiJ1xcXCIpICsgXFxcIiB3aGVyZSBhIHN0cmVhbSB3YXMgZXhwZWN0ZWQuIFlvdSBjYW4gcHJvdmlkZSBhbiBPYnNlcnZhYmxlLCBQcm9taXNlLCBSZWFkYWJsZVN0cmVhbSwgQXJyYXksIEFzeW5jSXRlcmFibGUsIG9yIEl0ZXJhYmxlLlxcXCIpO1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJvd1Vub2JzZXJ2YWJsZUVycm9yLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC90aHJvd1Vub2JzZXJ2YWJsZUVycm9yLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJfX2V4dGVuZHNcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBfX2V4dGVuZHMpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIl9fYXNzaWduXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gX19hc3NpZ24pLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIl9fcmVzdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIF9fcmVzdCksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiX19kZWNvcmF0ZVxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIF9fZGVjb3JhdGUpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIl9fcGFyYW1cXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBfX3BhcmFtKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJfX21ldGFkYXRhXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gX19tZXRhZGF0YSksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiX19hd2FpdGVyXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gX19hd2FpdGVyKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJfX2dlbmVyYXRvclxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIF9fZ2VuZXJhdG9yKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJfX2NyZWF0ZUJpbmRpbmdcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBfX2NyZWF0ZUJpbmRpbmcpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIl9fZXhwb3J0U3RhclxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIF9fZXhwb3J0U3RhciksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiX192YWx1ZXNcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBfX3ZhbHVlcyksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiX19yZWFkXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gX19yZWFkKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJfX3NwcmVhZFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIF9fc3ByZWFkKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJfX3NwcmVhZEFycmF5c1xcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIF9fc3ByZWFkQXJyYXlzKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJfX3NwcmVhZEFycmF5XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gX19zcHJlYWRBcnJheSksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiX19hd2FpdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIF9fYXdhaXQpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIl9fYXN5bmNHZW5lcmF0b3JcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBfX2FzeW5jR2VuZXJhdG9yKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJfX2FzeW5jRGVsZWdhdG9yXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gX19hc3luY0RlbGVnYXRvciksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiX19hc3luY1ZhbHVlc1xcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIF9fYXN5bmNWYWx1ZXMpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIl9fbWFrZVRlbXBsYXRlT2JqZWN0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gX19tYWtlVGVtcGxhdGVPYmplY3QpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIl9faW1wb3J0U3RhclxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIF9faW1wb3J0U3RhciksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiX19pbXBvcnREZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gX19pbXBvcnREZWZhdWx0KSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gX19jbGFzc1ByaXZhdGVGaWVsZEdldCksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiX19jbGFzc1ByaXZhdGVGaWVsZFNldFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIF9fY2xhc3NQcml2YXRlRmllbGRTZXQpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxyXFxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXFxyXFxuXFxyXFxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XFxyXFxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxcclxcblxcclxcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcXFwiQVMgSVNcXFwiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXFxyXFxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXFxyXFxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxcclxcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxcclxcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXFxyXFxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxcclxcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXFxyXFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cXHJcXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xcclxcblxcclxcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xcclxcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XFxyXFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XFxyXFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xcclxcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcXHJcXG59O1xcclxcblxcclxcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XFxyXFxuICAgIGlmICh0eXBlb2YgYiAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBiICE9PSBudWxsKVxcclxcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcXFwiICsgU3RyaW5nKGIpICsgXFxcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXFxcIik7XFxyXFxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XFxyXFxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxcclxcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XFxyXFxufVxcclxcblxcclxcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xcclxcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xcclxcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XFxyXFxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcXHJcXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgcmV0dXJuIHQ7XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XFxyXFxuICAgIHZhciB0ID0ge307XFxyXFxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxcclxcbiAgICAgICAgdFtwXSA9IHNbcF07XFxyXFxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFxcXCJmdW5jdGlvblxcXCIpXFxyXFxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XFxyXFxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxcclxcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgcmV0dXJuIHQ7XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcXHJcXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcXHJcXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcXFwib2JqZWN0XFxcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXFxcImZ1bmN0aW9uXFxcIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xcclxcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xcclxcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xcclxcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xcclxcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFxcXCJvYmplY3RcXFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcXFwiZnVuY3Rpb25cXFwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcXHJcXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XFxyXFxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xcclxcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxcclxcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXFxcInRocm93XFxcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxcclxcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cXHJcXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcXHJcXG4gICAgfSk7XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcXHJcXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcXHJcXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFxcXCJ0aHJvd1xcXCI6IHZlcmIoMSksIFxcXCJyZXR1cm5cXFwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XFxyXFxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxcclxcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XFxyXFxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlxcXCIpO1xcclxcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XFxyXFxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcXFwicmV0dXJuXFxcIl0gOiBvcFswXSA/IHlbXFxcInRocm93XFxcIl0gfHwgKCh0ID0geVtcXFwicmV0dXJuXFxcIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xcclxcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcXHJcXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xcclxcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcXHJcXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XFxyXFxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XFxyXFxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcXHJcXG4gICAgfVxcclxcbn1cXHJcXG5cXHJcXG52YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xcclxcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xcclxcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XFxyXFxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcXHJcXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcXHJcXG4gICAgb1trMl0gPSBtW2tdO1xcclxcbn0pO1xcclxcblxcclxcbmZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XFxyXFxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFxcXCJkZWZhdWx0XFxcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcXHJcXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XFxyXFxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xcclxcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFxcXCJudW1iZXJcXFwiKSByZXR1cm4ge1xcclxcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xcclxcbiAgICAgICAgfVxcclxcbiAgICB9O1xcclxcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcXFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cXFwiIDogXFxcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cXFwiKTtcXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcXHJcXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcXHJcXG4gICAgaWYgKCFtKSByZXR1cm4gbztcXHJcXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XFxyXFxuICAgIHRyeSB7XFxyXFxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcXHJcXG4gICAgfVxcclxcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cXHJcXG4gICAgZmluYWxseSB7XFxyXFxuICAgICAgICB0cnkge1xcclxcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1xcXCJyZXR1cm5cXFwiXSkpIG0uY2FsbChpKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBhcjtcXHJcXG59XFxyXFxuXFxyXFxuLyoqIEBkZXByZWNhdGVkICovXFxyXFxuZnVuY3Rpb24gX19zcHJlYWQoKSB7XFxyXFxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxcclxcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xcclxcbiAgICByZXR1cm4gYXI7XFxyXFxufVxcclxcblxcclxcbi8qKiBAZGVwcmVjYXRlZCAqL1xcclxcbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xcclxcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcXHJcXG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxcclxcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXFxyXFxuICAgICAgICAgICAgcltrXSA9IGFbal07XFxyXFxuICAgIHJldHVybiByO1xcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tKSB7XFxyXFxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGZyb20ubGVuZ3RoLCBqID0gdG8ubGVuZ3RoOyBpIDwgaWw7IGkrKywgaisrKVxcclxcbiAgICAgICAgdG9bal0gPSBmcm9tW2ldO1xcclxcbiAgICByZXR1cm4gdG87XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIF9fYXdhaXQodikge1xcclxcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcXHJcXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXFxcIik7XFxyXFxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XFxyXFxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXFxcIm5leHRcXFwiKSwgdmVyYihcXFwidGhyb3dcXFwiKSwgdmVyYihcXFwicmV0dXJuXFxcIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcXHJcXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XFxyXFxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cXHJcXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XFxyXFxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFxcXCJuZXh0XFxcIiwgdmFsdWUpOyB9XFxyXFxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXFxcInRocm93XFxcIiwgdmFsdWUpOyB9XFxyXFxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XFxyXFxuICAgIHZhciBpLCBwO1xcclxcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFxcXCJuZXh0XFxcIiksIHZlcmIoXFxcInRocm93XFxcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXFxcInJldHVyblxcXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xcclxcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcXFwicmV0dXJuXFxcIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcXHJcXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXFxcIik7XFxyXFxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XFxyXFxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFxcXCJmdW5jdGlvblxcXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXFxcIm5leHRcXFwiKSwgdmVyYihcXFwidGhyb3dcXFwiKSwgdmVyYihcXFwicmV0dXJuXFxcIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XFxyXFxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cXHJcXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xcclxcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFxcXCJyYXdcXFwiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cXHJcXG4gICAgcmV0dXJuIGNvb2tlZDtcXHJcXG59O1xcclxcblxcclxcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcXHJcXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFxcXCJkZWZhdWx0XFxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcXHJcXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcXHJcXG4gICAgb1tcXFwiZGVmYXVsdFxcXCJdID0gdjtcXHJcXG59O1xcclxcblxcclxcbmZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcXHJcXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcXHJcXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xcclxcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXFxcImRlZmF1bHRcXFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xcclxcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xcclxcbiAgICByZXR1cm4gcmVzdWx0O1xcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XFxyXFxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcXHJcXG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcXHJcXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcImF0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcXFwiKTtcXHJcXG4gICAgfVxcclxcbiAgICByZXR1cm4gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xcclxcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xcclxcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVxcXCIpO1xcclxcbiAgICB9XFxyXFxuICAgIHByaXZhdGVNYXAuc2V0KHJlY2VpdmVyLCB2YWx1ZSk7XFxyXFxuICAgIHJldHVybiB2YWx1ZTtcXHJcXG59XFxyXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9yeGpzL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheUxpa2VUb0FycmF5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlMaWtlVG9BcnJheS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gX2FycmF5TGlrZVRvQXJyYXkpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcXG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xcblxcbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XFxuICAgIGFycjJbaV0gPSBhcnJbaV07XFxuICB9XFxuXFxuICByZXR1cm4gYXJyMjtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheUxpa2VUb0FycmF5LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlXaXRoSG9sZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlXaXRoSG9sZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBfYXJyYXlXaXRoSG9sZXMpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhIb2xlcy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19fX3dlYnBhY2tfbW9kdWxlX18sIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XFxuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XFxuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7XFxuICB9XFxuXFxuICByZXR1cm4gc2VsZjtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3luY1RvR2VuZXJhdG9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXN5bmNUb0dlbmVyYXRvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gX2FzeW5jVG9HZW5lcmF0b3IpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xcbiAgdHJ5IHtcXG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xcbiAgfSBjYXRjaCAoZXJyb3IpIHtcXG4gICAgcmVqZWN0KGVycm9yKTtcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgaWYgKGluZm8uZG9uZSkge1xcbiAgICByZXNvbHZlKHZhbHVlKTtcXG4gIH0gZWxzZSB7XFxuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcyxcXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XFxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XFxuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xcblxcbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XFxuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFxcXCJuZXh0XFxcIiwgdmFsdWUpO1xcbiAgICAgIH1cXG5cXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XFxuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFxcXCJ0aHJvd1xcXCIsIGVycik7XFxuICAgICAgfVxcblxcbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XFxuICAgIH0pO1xcbiAgfTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3luY1RvR2VuZXJhdG9yLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2suanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2suanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBfY2xhc3NDYWxsQ2hlY2spXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7XFxuICB9XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2suanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jb25zdHJ1Y3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NvbnN0cnVjdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBfY29uc3RydWN0KVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2V0UHJvdG90eXBlT2ZfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc2V0UHJvdG90eXBlT2YuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NldFByb3RvdHlwZU9mLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QuanNcXFwiKTtcXG5cXG5cXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcXG4gIGlmICgoMCxfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uZGVmYXVsdCkoKSkge1xcbiAgICBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7XFxuICB9IGVsc2Uge1xcbiAgICBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XFxuICAgICAgdmFyIGEgPSBbbnVsbF07XFxuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcXG4gICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcXG4gICAgICBpZiAoQ2xhc3MpICgwLF9zZXRQcm90b3R5cGVPZl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmRlZmF1bHQpKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY29uc3RydWN0LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBfY3JlYXRlQ2xhc3MpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XFxuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcXG4gICAgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XFxuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XFxuICByZXR1cm4gQ29uc3RydWN0b3I7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19fX3dlYnBhY2tfbW9kdWxlX18sIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIF9kZWZpbmVQcm9wZXJ0eSlcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XFxuICBpZiAoa2V5IGluIG9iaikge1xcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcXG4gICAgICB2YWx1ZTogdmFsdWUsXFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgd3JpdGFibGU6IHRydWVcXG4gICAgfSk7XFxuICB9IGVsc2Uge1xcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xcbiAgfVxcblxcbiAgcmV0dXJuIG9iajtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gX2dldFByb3RvdHlwZU9mKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XFxuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xcbiAgfTtcXG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZ2V0UHJvdG90eXBlT2YuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19fX3dlYnBhY2tfbW9kdWxlX18sIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIF9pbmhlcml0cylcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NldFByb3RvdHlwZU9mX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NldFByb3RvdHlwZU9mLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zZXRQcm90b3R5cGVPZi5qc1xcXCIpO1xcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cXFwiKTtcXG4gIH1cXG5cXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xcbiAgICBjb25zdHJ1Y3Rvcjoge1xcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcXG4gICAgfVxcbiAgfSk7XFxuICBpZiAoc3VwZXJDbGFzcykgKDAsX3NldFByb3RvdHlwZU9mX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZGVmYXVsdCkoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9EZXJpdkFQSUJhc2ljLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXNOYXRpdmVGdW5jdGlvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2lzTmF0aXZlRnVuY3Rpb24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19fX3dlYnBhY2tfbW9kdWxlX18sIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIF9pc05hdGl2ZUZ1bmN0aW9uKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7XFxuICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcXFwiW25hdGl2ZSBjb2RlXVxcXCIpICE9PSAtMTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pc05hdGl2ZUZ1bmN0aW9uLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdClcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcXFwidW5kZWZpbmVkXFxcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcXG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XFxuICBpZiAodHlwZW9mIFByb3h5ID09PSBcXFwiZnVuY3Rpb25cXFwiKSByZXR1cm4gdHJ1ZTtcXG5cXG4gIHRyeSB7XFxuICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcXG4gICAgcmV0dXJuIHRydWU7XFxuICB9IGNhdGNoIChlKSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19fX3dlYnBhY2tfbW9kdWxlX18sIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIF9pdGVyYWJsZVRvQXJyYXlMaW1pdClcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XFxuICB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXFxcIkBAaXRlcmF0b3JcXFwiXTtcXG5cXG4gIGlmIChfaSA9PSBudWxsKSByZXR1cm47XFxuICB2YXIgX2FyciA9IFtdO1xcbiAgdmFyIF9uID0gdHJ1ZTtcXG4gIHZhciBfZCA9IGZhbHNlO1xcblxcbiAgdmFyIF9zLCBfZTtcXG5cXG4gIHRyeSB7XFxuICAgIGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcXG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xcblxcbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcXG4gICAgfVxcbiAgfSBjYXRjaCAoZXJyKSB7XFxuICAgIF9kID0gdHJ1ZTtcXG4gICAgX2UgPSBlcnI7XFxuICB9IGZpbmFsbHkge1xcbiAgICB0cnkge1xcbiAgICAgIGlmICghX24gJiYgX2lbXFxcInJldHVyblxcXCJdICE9IG51bGwpIF9pW1xcXCJyZXR1cm5cXFwiXSgpO1xcbiAgICB9IGZpbmFsbHkge1xcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBfYXJyO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9EZXJpdkFQSUJhc2ljLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVSZXN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9ub25JdGVyYWJsZVJlc3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gX25vbkl0ZXJhYmxlUmVzdClcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXFxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cXFwiKTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vRGVyaXZBUElCYXNpYy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9ub25JdGVyYWJsZVJlc3QuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4pXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfdHlwZW9mX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanNcXFwiKTtcXG5cXG5cXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XFxuICBpZiAoY2FsbCAmJiAoKDAsX2JhYmVsX3J1bnRpbWVfaGVscGVyc190eXBlb2ZfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5kZWZhdWx0KShjYWxsKSA9PT0gXFxcIm9iamVjdFxcXCIgfHwgdHlwZW9mIGNhbGwgPT09IFxcXCJmdW5jdGlvblxcXCIpKSB7XFxuICAgIHJldHVybiBjYWxsO1xcbiAgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcXFwiKTtcXG4gIH1cXG5cXG4gIHJldHVybiAoMCxfYXNzZXJ0VGhpc0luaXRpYWxpemVkX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uZGVmYXVsdCkoc2VsZik7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NldFByb3RvdHlwZU9mLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NldFByb3RvdHlwZU9mLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gX3NldFByb3RvdHlwZU9mKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XFxuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcXG4gICAgby5fX3Byb3RvX18gPSBwO1xcbiAgICByZXR1cm4gbztcXG4gIH07XFxuXFxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9EZXJpdkFQSUJhc2ljLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NldFByb3RvdHlwZU9mLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19fX3dlYnBhY2tfbW9kdWxlX18sIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIF9zbGljZWRUb0FycmF5KVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYXJyYXlXaXRoSG9sZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYXJyYXlXaXRoSG9sZXMuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5V2l0aEhvbGVzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pdGVyYWJsZVRvQXJyYXlMaW1pdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5TGltaXQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9uSXRlcmFibGVSZXN0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL25vbkl0ZXJhYmxlUmVzdC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVSZXN0LmpzXFxcIik7XFxuXFxuXFxuXFxuXFxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XFxuICByZXR1cm4gKDAsX2FycmF5V2l0aEhvbGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZGVmYXVsdCkoYXJyKSB8fCAoMCxfaXRlcmFibGVUb0FycmF5TGltaXRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5kZWZhdWx0KShhcnIsIGkpIHx8ICgwLF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmRlZmF1bHQpKGFyciwgaSkgfHwgKDAsX25vbkl0ZXJhYmxlUmVzdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLmRlZmF1bHQpKCk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3R5cGVvZi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19fX3dlYnBhY2tfbW9kdWxlX18sIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIF90eXBlb2YpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcXG4gIFxcXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlxcXCI7XFxuXFxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIikge1xcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcXG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcXG4gICAgfTtcXG4gIH0gZWxzZSB7XFxuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gX3R5cGVvZihvYmopO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9EZXJpdkFQSUJhc2ljLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3R5cGVvZi5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYXJyYXlMaWtlVG9BcnJheV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9hcnJheUxpa2VUb0FycmF5LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheUxpa2VUb0FycmF5LmpzXFxcIik7XFxuXFxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xcbiAgaWYgKCFvKSByZXR1cm47XFxuICBpZiAodHlwZW9mIG8gPT09IFxcXCJzdHJpbmdcXFwiKSByZXR1cm4gKDAsX2FycmF5TGlrZVRvQXJyYXlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5kZWZhdWx0KShvLCBtaW5MZW4pO1xcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xcbiAgaWYgKG4gPT09IFxcXCJPYmplY3RcXFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XFxuICBpZiAobiA9PT0gXFxcIk1hcFxcXCIgfHwgbiA9PT0gXFxcIlNldFxcXCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xcbiAgaWYgKG4gPT09IFxcXCJBcmd1bWVudHNcXFwiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gKDAsX2FycmF5TGlrZVRvQXJyYXlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5kZWZhdWx0KShvLCBtaW5MZW4pO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9EZXJpdkFQSUJhc2ljLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vd3JhcE5hdGl2ZVN1cGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS93cmFwTmF0aXZlU3VwZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gX3dyYXBOYXRpdmVTdXBlcilcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldFByb3RvdHlwZU9mX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldFByb3RvdHlwZU9mLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9nZXRQcm90b3R5cGVPZi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2V0UHJvdG90eXBlT2ZfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc2V0UHJvdG90eXBlT2YuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NldFByb3RvdHlwZU9mLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pc05hdGl2ZUZ1bmN0aW9uX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzTmF0aXZlRnVuY3Rpb24uanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2lzTmF0aXZlRnVuY3Rpb24uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbnN0cnVjdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb25zdHJ1Y3QuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NvbnN0cnVjdC5qc1xcXCIpO1xcblxcblxcblxcblxcbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcXG4gIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcXFwiZnVuY3Rpb25cXFwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xcblxcbiAgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcXG4gICAgaWYgKENsYXNzID09PSBudWxsIHx8ICEoMCxfaXNOYXRpdmVGdW5jdGlvbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmRlZmF1bHQpKENsYXNzKSkgcmV0dXJuIENsYXNzO1xcblxcbiAgICBpZiAodHlwZW9mIENsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cXFwiKTtcXG4gICAgfVxcblxcbiAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTtcXG5cXG4gICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBXcmFwcGVyKCkge1xcbiAgICAgIHJldHVybiAoMCxfY29uc3RydWN0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18uZGVmYXVsdCkoQ2xhc3MsIGFyZ3VtZW50cywgKDAsX2dldFByb3RvdHlwZU9mX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZGVmYXVsdCkodGhpcykuY29uc3RydWN0b3IpO1xcbiAgICB9XFxuXFxuICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcXG4gICAgICBjb25zdHJ1Y3Rvcjoge1xcbiAgICAgICAgdmFsdWU6IFdyYXBwZXIsXFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXFxuICAgICAgfVxcbiAgICB9KTtcXG4gICAgcmV0dXJuICgwLF9zZXRQcm90b3R5cGVPZl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmRlZmF1bHQpKFdyYXBwZXIsIENsYXNzKTtcXG4gIH07XFxuXFxuICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0Rlcml2QVBJQmFzaWMvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vd3JhcE5hdGl2ZVN1cGVyLmpzP1wiKTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcbi8qKioqKiovIFx0XHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcbi8qKioqKiovIFx0XHRcdFx0KCkgPT4gKG1vZHVsZSk7XG4vKioqKioqLyBcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuLyoqKioqKi8gXHRcdFx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuLyoqKioqKi8gXHRcdFx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcbi8qKioqKiovIFx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuLyoqKioqKi8gXHRcdFx0XHR9XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpXG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0ICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG4vKioqKioqLyBcdFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGNhbid0IGJlIGlubGluZWQgYmVjYXVzZSB0aGUgZXZhbCBkZXZ0b29sIGlzIHVzZWQuXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2Rlcml2X2FwaS9EZXJpdkFQSUJhc2ljLmpzXCIpO1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX2V4cG9ydHNfXy5kZWZhdWx0O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/@deriv/deriv-api/dist/DerivAPIBasic.js\n");

/***/ })

}]);