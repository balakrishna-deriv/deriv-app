{"version":3,"sources":["webpack://smartcharts/./chart_app/build/web/flutter.js"],"names":["_flutter","loader","timeout","promise","duration","debugName","timeoutId","_clock","Promise","_","reject","setTimeout","Error","cause","race","finally","clearTimeout","FlutterTrustedTypesPolicy","constructor","validPatterns","policyName","patterns","window","trustedTypes","policy","createPolicy","createScriptURL","url","parsed","URL","location","file","pathname","split","pop","matches","some","pattern","test","toString","console","error","FlutterServiceWorkerLoader","setTrustedTypesPolicy","_ttPolicy","loadServiceWorker","settings","navigator","serviceWorkerVersion","serviceWorkerUrl","timeoutMillis","serviceWorkerActivation","serviceWorker","register","then","_getNewServiceWorker","_waitForServiceWorkerActivation","serviceWorkerRegistrationPromise","reg","active","installing","waiting","debug","scriptURL","endsWith","update","newReg","latestServiceWorkerPromise","state","resolve","addEventListener","FlutterEntrypointLoader","_scriptLoaded","loadEntrypoint","options","entrypointUrl","onEntrypointLoaded","_loadEntrypoint","didCreateEngineInitializer","engineInitializer","_didCreateEngineInitializerResolve","_onEntrypointLoaded","useCallback","scriptTag","_createScriptTag","document","body","append","createElement","type","trustedUrl","src","FlutterLoader","entrypoint","flutterTT","serviceWorkerLoader","catch","e","warn","entrypointLoader","bind"],"mappings":"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","file":"flutter-chart-adapter-f60173.smartcharts.js","sourcesContent":["// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nif (!_flutter) {\n  var _flutter = {};\n}\n_flutter.loader = null;\n\n(function () {\n  \n  /**\n   * Wraps `promise` in a timeout of the given `duration` in ms.\n   *\n   * Resolves/rejects with whatever the original `promises` does, or rejects\n   * if `promise` takes longer to complete than `duration`. In that case,\n   * `debugName` is used to compose a legible error message.\n   *\n   * If `duration` is < 0, the original `promise` is returned unchanged.\n   * @param {Promise} promise\n   * @param {number} duration\n   * @param {string} debugName\n   * @returns {Promise} a wrapped promise.\n   */\n  async function timeout(promise, duration, debugName) {\n    if (duration < 0) {\n      return promise;\n    }\n    let timeoutId;\n    const _clock = new Promise((_, reject) => {\n      timeoutId = setTimeout(() => {\n        reject(\n          new Error(\n            `${debugName} took more than ${duration}ms to resolve. Moving on.`,\n            {\n              cause: timeout,\n            }\n          )\n        );\n      }, duration);\n    });\n\n    return Promise.race([promise, _clock]).finally(() => {\n      clearTimeout(timeoutId);\n    });\n  }\n\n  /**\n   * Handles the creation of a TrustedTypes `policy` that validates URLs based\n   * on an (optional) incoming array of RegExes.\n   */\n  class FlutterTrustedTypesPolicy {\n    /**\n     * Constructs the policy.\n     * @param {[RegExp]} validPatterns the patterns to test URLs\n     * @param {String} policyName the policy name (optional)\n     */\n    constructor(validPatterns, policyName = \"flutter-js\") {\n      const patterns = validPatterns || [\n        /\\.dart\\.js$/,\n        /^flutter_service_worker.js$/,\n      ];\n      if (window.trustedTypes) {\n        this.policy = trustedTypes.createPolicy(policyName, {\n          createScriptURL(url) {\n            const parsed = new URL(url, window.location);\n            const file = parsed.pathname.split(\"/\").pop();\n            const matches = patterns.some((pattern) => pattern.test(file));\n            if (matches) {\n              return parsed.toString();\n            }\n            console.error(\n              \"URL rejected by TrustedTypes policy\",\n              policyName, \":\", url, \"(download prevented)\");\n          },\n        });\n      }\n    }\n  }\n\n  /**\n   * Handles loading/reloading Flutter's service worker, if configured.\n   *\n   * @see: https://developers.google.com/web/fundamentals/primers/service-workers\n   */\n  class FlutterServiceWorkerLoader {\n    /**\n     * Injects a TrustedTypesPolicy (or undefined if the feature is not supported).\n     * @param {TrustedTypesPolicy | undefined} policy\n     */\n    setTrustedTypesPolicy(policy) {\n      this._ttPolicy = policy;\n    }\n\n    /**\n     * Returns a Promise that resolves when the latest Flutter service worker,\n     * configured by `settings` has been loaded and activated.\n     *\n     * Otherwise, the promise is rejected with an error message.\n     * @param {*} settings Service worker settings\n     * @returns {Promise} that resolves when the latest serviceWorker is ready.\n     */\n    loadServiceWorker(settings) {\n      if (!(\"serviceWorker\" in navigator) || settings == null) {\n        // In the future, settings = null -> uninstall service worker?\n        return Promise.reject(\n          new Error(\"Service worker not supported (or configured).\")\n        );\n      }\n      const {\n        serviceWorkerVersion,\n        serviceWorkerUrl = `flutter_service_worker.js?v=${ \n          serviceWorkerVersion}`,\n        timeoutMillis = 4000,\n      } = settings;\n\n      // Apply the TrustedTypes policy, if present.\n      let url = serviceWorkerUrl;\n      if (this._ttPolicy != null) {\n        url = this._ttPolicy.createScriptURL(url);\n      }\n\n      const serviceWorkerActivation = navigator.serviceWorker\n        .register(url)\n        .then(this._getNewServiceWorker)\n        .then(this._waitForServiceWorkerActivation);\n\n      // Timeout race promise\n      return timeout(\n        serviceWorkerActivation,\n        timeoutMillis,\n        \"prepareServiceWorker\"\n      );\n    }\n\n    /**\n     * Returns the latest service worker for the given `serviceWorkerRegistrationPromise`.\n     *\n     * This might return the current service worker, if there's no new service worker\n     * awaiting to be installed/updated.\n     *\n     * @param {Promise<ServiceWorkerRegistration>} serviceWorkerRegistrationPromise\n     * @returns {Promise<ServiceWorker>}\n     */\n    async _getNewServiceWorker(serviceWorkerRegistrationPromise) {\n      const reg = await serviceWorkerRegistrationPromise;\n\n      if (!reg.active && (reg.installing || reg.waiting)) {\n        // No active web worker and we have installed or are installing\n        // one for the first time. Simply wait for it to activate.\n        console.debug(\"Installing/Activating first service worker.\");\n        return reg.installing || reg.waiting;\n      } if (!reg.active.scriptURL.endsWith(serviceWorkerVersion)) {\n        // When the app updates the serviceWorkerVersion changes, so we\n        // need to ask the service worker to update.\n        return reg.update().then((newReg) => {\n          console.debug(\"Updating service worker.\");\n          return newReg.installing || newReg.waiting || newReg.active;\n        });\n      } \n        console.debug(\"Loading from existing service worker.\");\n        return reg.active;\n      \n    }\n\n    /**\n     * Returns a Promise that resolves when the `latestServiceWorker` changes its\n     * state to \"activated\".\n     *\n     * @param {Promise<ServiceWorker>} latestServiceWorkerPromise\n     * @returns {Promise<void>}\n     */\n    async _waitForServiceWorkerActivation(latestServiceWorkerPromise) {\n      const serviceWorker = await latestServiceWorkerPromise;\n\n      if (!serviceWorker || serviceWorker.state == \"activated\") {\n        if (!serviceWorker) {\n          return Promise.reject(\n            new Error(\"Cannot activate a null service worker!\")\n          );\n        } \n          console.debug(\"Service worker already active.\");\n          return Promise.resolve();\n        \n      }\n      return new Promise((resolve, _) => {\n        serviceWorker.addEventListener(\"statechange\", () => {\n          if (serviceWorker.state == \"activated\") {\n            console.debug(\"Activated new service worker.\");\n            resolve();\n          }\n        });\n      });\n    }\n  }\n\n  /**\n   * Handles injecting the main Flutter web entrypoint (main.dart.js), and notifying\n   * the user when Flutter is ready, through `didCreateEngineInitializer`.\n   *\n   * @see https://docs.flutter.dev/development/platform-integration/web/initialization\n   */\n  class FlutterEntrypointLoader {\n    /**\n     * Creates a FlutterEntrypointLoader.\n     */\n    constructor() {\n      // Watchdog to prevent injecting the main entrypoint multiple times.\n      this._scriptLoaded = false;\n    }\n\n    /**\n     * Injects a TrustedTypesPolicy (or undefined if the feature is not supported).\n     * @param {TrustedTypesPolicy | undefined} policy\n     */\n    setTrustedTypesPolicy(policy) {\n      this._ttPolicy = policy;\n    }\n\n    /**\n     * Loads flutter main entrypoint, specified by `entrypointUrl`, and calls a\n     * user-specified `onEntrypointLoaded` callback with an EngineInitializer\n     * object when it's done.\n     *\n     * @param {*} options\n     * @returns {Promise | undefined} that will eventually resolve with an\n     * EngineInitializer, or will be rejected with the error caused by the loader.\n     * Returns undefined when an `onEntrypointLoaded` callback is supplied in `options`.\n     */\n    async loadEntrypoint(options) {\n      const { entrypointUrl = \"main.dart.js\", onEntrypointLoaded } =\n        options || {};\n\n      return this._loadEntrypoint(entrypointUrl, onEntrypointLoaded);\n    }\n\n    /**\n     * Resolves the promise created by loadEntrypoint, and calls the `onEntrypointLoaded`\n     * function supplied by the user (if needed).\n     *\n     * Called by Flutter through `_flutter.loader.didCreateEngineInitializer` method,\n     * which is bound to the correct instance of the FlutterEntrypointLoader by\n     * the FlutterLoader object.\n     *\n     * @param {Function} engineInitializer @see https://github.com/flutter/engine/blob/main/lib/web_ui/lib/src/engine/js_interop/js_loader.dart#L42\n     */\n    didCreateEngineInitializer(engineInitializer) {\n      if (typeof this._didCreateEngineInitializerResolve === \"function\") {\n        this._didCreateEngineInitializerResolve(engineInitializer);\n        // Remove the resolver after the first time, so Flutter Web can hot restart.\n        this._didCreateEngineInitializerResolve = null;\n        // Make the engine revert to \"auto\" initialization on hot restart.\n        delete _flutter.loader.didCreateEngineInitializer;\n      }\n      if (typeof this._onEntrypointLoaded === \"function\") {\n        this._onEntrypointLoaded(engineInitializer);\n      }\n    }\n\n    /**\n     * Injects a script tag into the DOM, and configures this loader to be able to\n     * handle the \"entrypoint loaded\" notifications received from Flutter web.\n     *\n     * @param {string} entrypointUrl the URL of the script that will initialize\n     *                 Flutter.\n     * @param {Function} onEntrypointLoaded a callback that will be called when\n     *                   Flutter web notifies this object that the entrypoint is\n     *                   loaded.\n     * @returns {Promise | undefined} a Promise that resolves when the entrypoint\n     *                                is loaded, or undefined if `onEntrypointLoaded`\n     *                                is a function.\n     */\n    _loadEntrypoint(entrypointUrl, onEntrypointLoaded) {\n      const useCallback = typeof onEntrypointLoaded === \"function\";\n\n      if (!this._scriptLoaded) {\n        this._scriptLoaded = true;\n        const scriptTag = this._createScriptTag(entrypointUrl);\n        if (useCallback) {\n          // Just inject the script tag, and return nothing; Flutter will call\n          // `didCreateEngineInitializer` when it's done.\n          console.debug(\"Injecting <script> tag. Using callback.\");\n          this._onEntrypointLoaded = onEntrypointLoaded;\n          document.body.append(scriptTag);\n        } else {\n          // Inject the script tag and return a promise that will get resolved\n          // with the EngineInitializer object from Flutter when it calls\n          // `didCreateEngineInitializer` later.\n          return new Promise((resolve, reject) => {\n            console.debug(\n              \"Injecting <script> tag. Using Promises. Use the callback approach instead!\"\n            );\n            this._didCreateEngineInitializerResolve = resolve;\n            scriptTag.addEventListener(\"error\", reject);\n            document.body.append(scriptTag);\n          });\n        }\n      }\n    }\n\n    /**\n     * Creates a script tag for the given URL.\n     * @param {string} url\n     * @returns {HTMLScriptElement}\n     */\n    _createScriptTag(url) {\n      const scriptTag = document.createElement(\"script\");\n      scriptTag.type = \"application/javascript\";\n      // Apply TrustedTypes validation, if available.\n      let trustedUrl = url;\n      if (this._ttPolicy != null) {\n        trustedUrl = this._ttPolicy.createScriptURL(url);\n      }\n      scriptTag.src = trustedUrl;\n      return scriptTag;\n    }\n  }\n\n  /**\n   * The public interface of _flutter.loader. Exposes two methods:\n   * * loadEntrypoint (which coordinates the default Flutter web loading procedure)\n   * * didCreateEngineInitializer (which is called by Flutter to notify that its\n   *                              Engine is ready to be initialized)\n   */\n  class FlutterLoader {\n    /**\n     * Initializes the Flutter web app.\n     * @param {*} options\n     * @returns {Promise?} a (Deprecated) Promise that will eventually resolve\n     *                     with an EngineInitializer, or will be rejected with\n     *                     any error caused by the loader. Or Null, if the user\n     *                     supplies an `onEntrypointLoaded` Function as an option.\n     */\n    async loadEntrypoint(options) {\n      const { serviceWorker, ...entrypoint } = options || {};\n\n      // A Trusted Types policy that is going to be used by the loader.\n      const flutterTT = new FlutterTrustedTypesPolicy();\n\n      // The FlutterServiceWorkerLoader instance could be injected as a dependency\n      // (and dynamically imported from a module if not present).\n      const serviceWorkerLoader = new FlutterServiceWorkerLoader();\n      serviceWorkerLoader.setTrustedTypesPolicy(flutterTT.policy);\n      await serviceWorkerLoader.loadServiceWorker(serviceWorker).catch(e => {\n        // Regardless of what happens with the injection of the SW, the show must go on\n        console.warn(\"Exception while loading service worker:\", e);\n      });\n\n      // The FlutterEntrypointLoader instance could be injected as a dependency\n      // (and dynamically imported from a module if not present).\n      const entrypointLoader = new FlutterEntrypointLoader();\n      entrypointLoader.setTrustedTypesPolicy(flutterTT.policy);\n      // Install the `didCreateEngineInitializer` listener where Flutter web expects it to be.\n      this.didCreateEngineInitializer =\n        entrypointLoader.didCreateEngineInitializer.bind(entrypointLoader);\n      return entrypointLoader.loadEntrypoint(entrypoint);\n    }\n  }\n\n  _flutter.loader = new FlutterLoader();\n})();\n\n"],"sourceRoot":""}